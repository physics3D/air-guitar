function Dg(n,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(r){if(r!=="default"&&!(r in n)){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}})}),Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pg=1e-7,Lg=1e-4;class Bg{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Qc{refCount(e){return vt("refCount")}incRef(e){return vt("incRef")}timerAvailable(){return!0}time(e){return vt("time")}read(e){return vt("read")}readSync(e){return vt("readSync")}readToGPU(e,t){return vt("readToGPU")}numDataIds(){return vt("numDataIds")}disposeData(e,t){return vt("disposeData")}write(e,t,r){return vt("write")}move(e,t,r,s,o){return vt("move")}memory(){return vt("memory")}floatPrecision(){return vt("floatPrecision")}epsilon(){return this.floatPrecision()===32?Pg:Lg}dispose(){return vt("dispose")}}function vt(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(n,e,t){return Math.max(n,Math.min(e,t))}function Zc(n){return n%2===0?n:n+1}function Kr(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function Mg(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function I(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Yt(n,e,t=""){I(We(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function ei(n){I(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function wr(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||nn(n)&&!t)for(let r=0;r<n.length;++r)wr(n[r],e,t);else e.push(n);return e}function j(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function We(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function ts(n){return n%1===0}function oa(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function xr(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function uu(n,e=r=>0,t){return new Promise((r,s)=>{let o=0;const a=()=>{if(n()){r();return}o++;const i=e(o);if(t!=null&&o>=t){s();return}setTimeout(a,i)};a()})}function Vg(n,e){let t=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function Ze(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),I(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),I(n.every(r=>ts(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function kn(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:Ze(e,n).sort();let a=0;for(let i=0;i<n.length;++i){if(o!=null){if(o[a]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(o[a]==null||o[a]>i)&&n[i]===1&&(t.push(n[i]),r.push(i)),o[a]<=i&&a++}n[i]!==1&&(t.push(n[i]),r.push(i))}return{newShape:t,keptDims:r}}function Tn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function _t(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Ug(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Wg(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function zg(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function nn(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function aa(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Gg(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function oo(n){return typeof n=="string"||n instanceof String}function Hg(n){return typeof n=="boolean"}function jg(n){return typeof n=="number"}function ao(n){return Array.isArray(n)?ao(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":jg(n)?"float32":oo(n)?"string":Hg(n)?"bool":"float32"}function cu(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ia(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function tt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function Jc(n,e,t,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let a=0;a<o;a++)s[a]=t[n+a]}else{const o=e[0],a=e.slice(1),i=a.reduce((u,c)=>u*c)*(r?2:1);for(let u=0;u<o;u++)s[u]=Jc(n+u*i,a,t,r)}return s}function ua(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,o)=>s*o)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Jc(0,n,e,t)}function el(n,e){const t=Cn(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Cn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function tl(n){n.forEach(e=>{I(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ca(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function nl(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function ns(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lu="tfjsflags";class Kg{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Xg,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ns(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);lu in e&&e[lu].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=Yg(s,o)})}}function Xg(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(qg(e,r[0],r[1]),r.join("="))),e}function qg(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Yg(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function B(){return rl}let rl=null;function Qg(n){rl=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Po;function sl(){if(Po==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");Po=n}return Po}function Zg(){const n=sl();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function ti(n,e){const t=Zg();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const ol="Abs",al="Acos",il="Acosh",ni="Add",ul="AddN",cl="All",ll="Any",hl="ArgMax",pl="ArgMin",dl="Asin",fl="Asinh",ml="Atan",gl="Atanh",yl="Atan2",xl="AvgPool",Jg="AvgPoolGrad",bl="AvgPool3D",ey="AvgPool3DGrad",vl="BatchMatMul",wl="BatchToSpaceND",$l="Bincount",Sl="BroadcastArgs",ri="Cast",Tl="Ceil",Cl="ClipByValue",Nl="Complex",El="ComplexAbs",kl="Concat",Il="Conv2D",Rl="Conv2DBackpropFilter",_l="Conv2DBackpropInput",Al="Conv3D",ty="Conv3DBackpropFilterV2",ny="Conv3DBackpropInputV2",Ol="Cos",Fl="Cosh",Dl="Cumsum",Pl="CropAndResize",Ll="DenseBincount",Bl="DepthToSpace",Ml="DepthwiseConv2dNative",Vl="DepthwiseConv2dNativeBackpropFilter",Ul="DepthwiseConv2dNativeBackpropInput",ry="Diag",Wl="Dilation2D",zl="RealDiv",Gl="Einsum",Hl="Elu",sy="EluGrad",jl="Erf",Kl="Equal",Xl="Exp",ql="ExpandDims",Yl="Expm1",Ql="FFT",Zl="Fill",Jl="FlipLeftRight",eh="Floor",th="FloorDiv",nh="FusedBatchNorm",rh="GatherV2",sh="GatherNd",oh="Greater",ah="GreaterEqual",si="Identity",ih="IFFT",uh="Imag",oy="IsFinite",ay="IsInf",ch="IsNan",lh="LeakyRelu",hh="Less",ph="LessEqual",dh="LinSpace",fh="Log",mh="Log1p",gh="LogicalAnd",yh="LogicalNot",xh="LogicalOr",bh="LRN",iy="LRNGrad",vh="Max",wh="Maximum",$h="MaxPool",uy="MaxPoolGrad",Sh="MaxPool3D",cy="MaxPool3DGrad",Th="MaxPoolWithArgmax",Ch="Mean",Nh="Min",Eh="Minimum",kh="MirrorPad",Ih="Mod",Rh="Multinomial",_h="Multiply",Ah="Neg",Oh="NotEqual",Fh="NonMaxSuppressionV3",Dh="NonMaxSuppressionV4",Ph="NonMaxSuppressionV5",Lh="OnesLike",Bh="OneHot",Mh="Pack",Vh="PadV2",Uh="Pow",Wh="Prelu",zh="Prod",Gh="Range",Hh="Real",jh="Reciprocal",Kh="Relu",Xh="Reshape",qh="ResizeNearestNeighbor",ly="ResizeNearestNeighborGrad",Yh="ResizeBilinear",hy="ResizeBilinearGrad",Qh="Relu6",Zh="Reverse",Jh="Round",ep="Rsqrt",tp="ScatterNd",np="Select",rp="Selu",sp="Slice",op="Sin",ap="Sinh",ip="Sign",up="Sigmoid",cp="Softplus",lp="Sqrt",hp="Sum",pp="SpaceToBatchND",dp="SplitV",fp="Softmax",mp="SparseFillEmptyRows",gp="SparseReshape",yp="SparseSegmentMean",xp="SparseSegmentSum",bp="SparseToDense",vp="SquaredDifference",py="Square",wp="StridedSlice",$p="StringNGrams",Sp="StringSplit",Tp="StringToHashBucketFast",Cp="Sub",Np="Tan",Ep="Tanh",oi="Tile",kp="TopK",Ip="Transform",Rp="Transpose",_p="Unique",Ap="Unpack",dy="UnsortedSegmentSum",Op="ZerosLike",Fp="Step",la="FromPixels",Dp="RotateWithOffset",ha="_FusedMatMul",pa="FusedConv2D",da="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(...n){B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(...n)}function fy(...n){B().getBool("IS_TEST")||B().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hs=ti("kernelRegistry",()=>new Map),my=ti("gradRegistry",()=>new Map);function fa(n,e){const t=Pp(n,e);return Hs.get(t)}function hu(n){return my.get(n)}function pu(n){const e=Hs.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,a]=s,[i]=o.split("_");i===n&&t.push(a)}return t}function gy(n){const{kernelName:e,backendName:t}=n,r=Pp(e,t);Hs.has(r)&&jt(`The kernel '${e}' for backend '${t}' is already registered`),Hs.set(r,n)}function Pp(n,e){return`${e}_${n}`}var hn=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function yy(n){if(n.__esModule)return n;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach(function(t){var r=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:function(){return n[t]}})}),e}function _s(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var ma=De,At=null;try{At=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function De(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}De.prototype.__isLong__;Object.defineProperty(De.prototype,"__isLong__",{value:!0});function bt(n){return(n&&n.__isLong__)===!0}De.isLong=bt;var du={},fu={};function Zn(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=fu[n],r)?r:(t=Pe(n,(n|0)<0?-1:0,!0),s&&(fu[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=du[n],r)?r:(t=Pe(n,n<0?-1:0,!1),s&&(du[n]=t),t))}De.fromInt=Zn;function Ot(n,e){if(isNaN(n))return e?Mn:Ft;if(e){if(n<0)return Mn;if(n>=Lp)return Vp}else{if(n<=-gu)return gt;if(n+1>=gu)return Mp}return n<0?Ot(-n,e).neg():Pe(n%$r|0,n/$r|0,e)}De.fromNumber=Ot;function Pe(n,e,t){return new De(n,e,t)}De.fromBits=Pe;var js=Math.pow;function ai(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Ft;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return ai(n.substring(1),e,t).neg();for(var s=Ot(js(t,8)),o=Ft,a=0;a<n.length;a+=8){var i=Math.min(8,n.length-a),u=parseInt(n.substring(a,a+i),t);if(i<8){var c=Ot(js(t,i));o=o.mul(c).add(Ot(u))}else o=o.mul(s),o=o.add(Ot(u))}return o.unsigned=e,o}De.fromString=ai;function Qt(n,e){return typeof n=="number"?Ot(n,e):typeof n=="string"?ai(n,e):Pe(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}De.fromValue=Qt;var mu=1<<16,xy=1<<24,$r=mu*mu,Lp=$r*$r,gu=Lp/2,yu=Zn(xy),Ft=Zn(0);De.ZERO=Ft;var Mn=Zn(0,!0);De.UZERO=Mn;var yr=Zn(1);De.ONE=yr;var Bp=Zn(1,!0);De.UONE=Bp;var ga=Zn(-1);De.NEG_ONE=ga;var Mp=Pe(-1,2147483647,!1);De.MAX_VALUE=Mp;var Vp=Pe(-1,-1,!0);De.MAX_UNSIGNED_VALUE=Vp;var gt=Pe(0,-2147483648,!1);De.MIN_VALUE=gt;var K=De.prototype;K.toInt=function(){return this.unsigned?this.low>>>0:this.low};K.toNumber=function(){return this.unsigned?(this.high>>>0)*$r+(this.low>>>0):this.high*$r+(this.low>>>0)};K.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(gt)){var t=Ot(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=Ot(js(e,6),this.unsigned),a=this,i="";;){var u=a.div(o),c=a.sub(u.mul(o)).toInt()>>>0,h=c.toString(e);if(a=u,a.isZero())return h+i;for(;h.length<6;)h="0"+h;i=""+h+i}};K.getHighBits=function(){return this.high};K.getHighBitsUnsigned=function(){return this.high>>>0};K.getLowBits=function(){return this.low};K.getLowBitsUnsigned=function(){return this.low>>>0};K.getNumBitsAbs=function(){if(this.isNegative())return this.eq(gt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};K.isZero=function(){return this.high===0&&this.low===0};K.eqz=K.isZero;K.isNegative=function(){return!this.unsigned&&this.high<0};K.isPositive=function(){return this.unsigned||this.high>=0};K.isOdd=function(){return(this.low&1)===1};K.isEven=function(){return(this.low&1)===0};K.equals=function(e){return bt(e)||(e=Qt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};K.eq=K.equals;K.notEquals=function(e){return!this.eq(e)};K.neq=K.notEquals;K.ne=K.notEquals;K.lessThan=function(e){return this.comp(e)<0};K.lt=K.lessThan;K.lessThanOrEqual=function(e){return this.comp(e)<=0};K.lte=K.lessThanOrEqual;K.le=K.lessThanOrEqual;K.greaterThan=function(e){return this.comp(e)>0};K.gt=K.greaterThan;K.greaterThanOrEqual=function(e){return this.comp(e)>=0};K.gte=K.greaterThanOrEqual;K.ge=K.greaterThanOrEqual;K.compare=function(e){if(bt(e)||(e=Qt(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};K.comp=K.compare;K.negate=function(){return!this.unsigned&&this.eq(gt)?gt:this.not().add(yr)};K.neg=K.negate;K.add=function(e){bt(e)||(e=Qt(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,a=e.high>>>16,i=e.high&65535,u=e.low>>>16,c=e.low&65535,h=0,l=0,p=0,d=0;return d+=o+c,p+=d>>>16,d&=65535,p+=s+u,l+=p>>>16,p&=65535,l+=r+i,h+=l>>>16,l&=65535,h+=t+a,h&=65535,Pe(p<<16|d,h<<16|l,this.unsigned)};K.subtract=function(e){return bt(e)||(e=Qt(e)),this.add(e.neg())};K.sub=K.subtract;K.multiply=function(e){if(this.isZero())return Ft;if(bt(e)||(e=Qt(e)),At){var t=At.mul(this.low,this.high,e.low,e.high);return Pe(t,At.get_high(),this.unsigned)}if(e.isZero())return Ft;if(this.eq(gt))return e.isOdd()?gt:Ft;if(e.eq(gt))return this.isOdd()?gt:Ft;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(yu)&&e.lt(yu))return Ot(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,a=this.low&65535,i=e.high>>>16,u=e.high&65535,c=e.low>>>16,h=e.low&65535,l=0,p=0,d=0,f=0;return f+=a*h,d+=f>>>16,f&=65535,d+=o*h,p+=d>>>16,d&=65535,d+=a*c,p+=d>>>16,d&=65535,p+=s*h,l+=p>>>16,p&=65535,p+=o*c,l+=p>>>16,p&=65535,p+=a*u,l+=p>>>16,p&=65535,l+=r*h+s*c+o*u+a*i,l&=65535,Pe(d<<16|f,l<<16|p,this.unsigned)};K.mul=K.multiply;K.divide=function(e){if(bt(e)||(e=Qt(e)),e.isZero())throw Error("division by zero");if(At){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?At.div_u:At.div_s)(this.low,this.high,e.low,e.high);return Pe(t,At.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Mn:Ft;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Mn;if(e.gt(this.shru(1)))return Bp;o=Mn}else{if(this.eq(gt)){if(e.eq(yr)||e.eq(ga))return gt;if(e.eq(gt))return yr;var a=this.shr(1);return r=a.div(e).shl(1),r.eq(Ft)?e.isNegative()?yr:ga:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}else if(e.eq(gt))return this.unsigned?Mn:Ft;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=Ft}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:js(2,i-48),c=Ot(r),h=c.mul(e);h.isNegative()||h.gt(s);)r-=u,c=Ot(r,this.unsigned),h=c.mul(e);c.isZero()&&(c=yr),o=o.add(c),s=s.sub(h)}return o};K.div=K.divide;K.modulo=function(e){if(bt(e)||(e=Qt(e)),At){var t=(this.unsigned?At.rem_u:At.rem_s)(this.low,this.high,e.low,e.high);return Pe(t,At.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};K.mod=K.modulo;K.rem=K.modulo;K.not=function(){return Pe(~this.low,~this.high,this.unsigned)};K.and=function(e){return bt(e)||(e=Qt(e)),Pe(this.low&e.low,this.high&e.high,this.unsigned)};K.or=function(e){return bt(e)||(e=Qt(e)),Pe(this.low|e.low,this.high|e.high,this.unsigned)};K.xor=function(e){return bt(e)||(e=Qt(e)),Pe(this.low^e.low,this.high^e.high,this.unsigned)};K.shiftLeft=function(e){return bt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Pe(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Pe(0,this.low<<e-32,this.unsigned)};K.shl=K.shiftLeft;K.shiftRight=function(e){return bt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Pe(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Pe(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};K.shr=K.shiftRight;K.shiftRightUnsigned=function(e){if(bt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return Pe(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Pe(t,0,this.unsigned):Pe(t>>>e-32,0,this.unsigned)};K.shru=K.shiftRightUnsigned;K.shr_u=K.shiftRightUnsigned;K.toSigned=function(){return this.unsigned?Pe(this.low,this.high,!1):this};K.toUnsigned=function(){return this.unsigned?this:Pe(this.low,this.high,!0)};K.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};K.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};K.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};De.fromBytes=function(e,t,r){return r?De.fromBytesLE(e,t):De.fromBytesBE(e,t)};De.fromBytesLE=function(e,t){return new De(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};De.fromBytesBE=function(e,t){return new De(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};var by=Dg({__proto__:null,default:ma},[ma]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ln=ma||by;function io(n){return Ln.fromString(n,!0,16)}const Up=io("c3a5c85c97cb3127"),Dn=io("b492b66fbe98f273"),at=io("9ae16a3b2f90404f");function ya(n){return n.xor(n.shru(47))}function Wp(n,e,t){const r=n.slice(e,e+t);return Ln.fromBytes(Array.from(r),!0,!0)}function Oe(n,e){return Wp(n,e,8)}function xu(n,e){return Wp(n,e,4)}function Xe(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function $n(n,e,t=io("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function vy(n,e,t,r,s,o){s=s.add(n),o=Xe(o.add(s).add(r),21);const a=s;return s=s.add(e),s=s.add(t),o=o.add(Xe(s,44)),[s.add(r),o.add(a)]}function As(n,e,t,r){return vy(Oe(n,e),Oe(n,e+8),Oe(n,e+16),Oe(n,e+24),t,r)}function wy(n,e=n.length){if(e>=8){const t=at.add(e*2),r=Oe(n,0).add(at),s=Oe(n,e-8),o=Xe(s,37).mul(t).add(r),a=Xe(r,25).add(s).mul(t);return $n(o,a,t)}if(e>=4){const t=at.add(e*2),r=xu(n,0);return $n(r.shl(3).add(e),xu(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],o=t+(r<<8),a=e+(s<<2);return ya(at.mul(o).xor(Up.mul(a))).mul(at)}return at}function $y(n,e=n.length){const t=at.add(e*2),r=Oe(n,0).mul(Dn),s=Oe(n,8),o=Oe(n,e-8).mul(t),a=Oe(n,e-16).mul(at);return $n(Xe(r.add(s),43).add(Xe(o,30)).add(a),r.add(Xe(s.add(at),18)).add(o),t)}function Sy(n,e=n.length){const t=at.add(e*2),r=Oe(n,0).mul(at),s=Oe(n,8),o=Oe(n,e-8).mul(t),a=Oe(n,e-16).mul(at),i=Xe(r.add(s),43).add(Xe(o,30)).add(a),u=$n(i,r.add(Xe(s.add(at),18)).add(o),t),c=Oe(n,16).mul(t),h=Oe(n,24),l=i.add(Oe(n,e-32)).mul(t),p=u.add(Oe(n,e-24)).mul(t);return $n(Xe(c.add(h),43).add(Xe(l,30)).add(p),c.add(Xe(h.add(r),18)).add(l),t)}function Ty(n,e=n.length){const t=Ln.fromNumber(81,!0);if(e<=32)return e<=16?wy(n,e):$y(n,e);if(e<=64)return Sy(n,e);let r=t,s=t.mul(Dn).add(113),o=ya(s.mul(at).add(113)).mul(at),a=[Ln.UZERO,Ln.UZERO],i=[Ln.UZERO,Ln.UZERO];r=r.mul(at).add(Oe(n,0));let u=0;const c=(e-1>>6)*64,h=c+(e-1&63)-63;do r=Xe(r.add(s).add(a[0]).add(Oe(n,u+8)),37).mul(Dn),s=Xe(s.add(a[1]).add(Oe(n,u+48)),42).mul(Dn),r=r.xor(i[1]),s=s.add(a[0]).add(Oe(n,u+40)),o=Xe(o.add(i[0]),33).mul(Dn),a=As(n,u,a[1].mul(Dn),r.add(i[0])),i=As(n,u+32,o.add(i[1]),s.add(Oe(n,u+16))),[o,r]=[r,o],u+=64;while(u!==c);const l=Dn.add(o.and(255).shl(1));return u=h,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),r=Xe(r.add(s).add(a[0]).add(Oe(n,u+8)),37).mul(l),s=Xe(s.add(a[1]).add(Oe(n,u+48)),42).mul(l),r=r.xor(i[1].mul(9)),s=s.add(a[0].mul(9).add(Oe(n,u+40))),o=Xe(o.add(i[0]),33).mul(l),a=As(n,u,a[1].mul(l),r.add(i[0])),i=As(n,u+32,o.add(i[1]),s.add(Oe(n,u+16))),[o,r]=[r,o],$n($n(a[0],i[0],l).add(ya(s).mul(Up)).add(o),$n(a[1],i[1],l).add(r),l)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(n,e){return e==="string"?zn(n):ii([n],e)}function Cy(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function ii(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=wr(n)),B().getBool("DEBUG")&&Ug(n,e),Cy(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Gt(){return B().platform.now()}function zn(n,e="utf-8"){return e=e||"utf-8",B().platform.encode(n,e)}function rs(n,e="utf-8"){return e=e||"utf-8",B().platform.decode(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ny{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new ky)}profileKernel(e,t,r){let s;const o=()=>{s=r()};let a;const i=Gt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const c of s)c.dataSync();a=Promise.resolve({kernelMs:Gt()-i})}if(B().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const h=s[c];h.data().then(l=>{Ey(l,h.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:a}=e;r.forEach(i=>{Promise.all([i.data(),s,a]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],o,u[2])})})}}function Ey(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class ky{logKernelProfile(e,t,r,s,o,a){const i=typeof s=="number"?xr(`${s}ms`,9):s.error,u=xr(e,25),c=t.rank,h=t.size,l=xr(t.shape.toString(),14);let p="";for(const d in o){const f=o[d];if(f!=null){const g=f.shape||t.shape,y=g.length;p+=`${d}: ${y}D ${y>0?g:""} `}}console.log(`%c${u}	%c${i}	%c${c}D ${l}	%c${h}	%c${p}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy(n,e,t){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<n.length;u++){const c=n[u],h=c.inputs;for(const l in h){const p=h[l];let d=!1;for(let f=0;f<e.length;f++)if(r[p.id]){c.outputs.forEach(g=>r[g.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const o={};o[t.id]=!0;const a={};for(let u=n.length-1;u>=0;u--){const c=n[u],h=c.inputs;for(let l=0;l<c.outputs.length;l++)if(o[c.outputs[l].id]){for(const p in h)o[h[p].id]=!0,a[c.id]=!0;break}}const i=[];for(let u=0;u<n.length;u++){const c=n[u];if(s[c.id]&&a[c.id]){const h={};for(const p in c.inputs){const d=c.inputs[p];r[d.id]&&(h[p]=d)}const l=Object.assign({},c);l.inputs=h,l.outputs=c.outputs,i.push(l)}}return i}function Ry(n,e,t,r){for(let s=e.length-1;s>=0;s--){const o=e[s],a=[];if(o.outputs.forEach(u=>{const c=n[u.id];c!=null?a.push(c):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const u in o.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const c=t(()=>i[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const h=o.inputs[u];if(!We(c.shape,h.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=c;else{const l=n[h.id];n[h.id]=r(l,c),l.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bu=20,Xr=3,Lo=7;function _y(n,e,t,r){const s=tt(e),o=Ay(n,e,t,s),a=e.length,i=Vs(n,e,t,s,o),u=["Tensor"];return r&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(c=>"    "+c).join(`
`)),u.join(`
`)}function Ay(n,e,t,r){const s=j(e),o=r[r.length-1],a=new Array(o).fill(0),i=e.length,u=t==="complex64"?Zr(n):n;if(i>1)for(let c=0;c<s/o;c++){const h=c*o;for(let l=0;l<o;l++)a[l]=Math.max(a[l],Qr(u[h+l],0,t).length)}return a}function Qr(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Lo))} + ${parseFloat(n[1].toFixed(Lo))}j`:oo(n)?r=`'${n}'`:t==="bool"?r=zp(n):r=parseFloat(n.toFixed(Lo)).toString(),xr(r,e)}function zp(n){return n===0?"false":"true"}function Vs(n,e,t,r,s,o=!0){const a=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){const g=Zr(n);return[Qr(g[0],0,t)]}return t==="bool"?[zp(n[0])]:[n[0].toString()]}if(u===1){if(i>bu){const y=Xr*a;let w=Array.from(n.slice(0,y)),$=Array.from(n.slice((i-Xr)*a,i*a));return t==="complex64"&&(w=Zr(w),$=Zr($)),["["+w.map((S,T)=>Qr(S,s[T],t)).join(", ")+", ..., "+$.map((S,T)=>Qr(S,s[i-Xr+T],t)).join(", ")+"]"]}const g=t==="complex64"?Zr(n):Array.from(n);return["["+g.map((y,w)=>Qr(y,s[w],t)).join(", ")+"]"]}const c=e.slice(1),h=r.slice(1),l=r[0]*a,p=[];if(i>bu){for(let g=0;g<Xr;g++){const y=g*l,w=y+l;p.push(...Vs(n.slice(y,w),c,t,h,s,!1))}p.push("...");for(let g=i-Xr;g<i;g++){const y=g*l,w=y+l;p.push(...Vs(n.slice(y,w),c,t,h,s,g===i-1))}}else for(let g=0;g<i;g++){const y=g*l,w=y+l;p.push(...Vs(n.slice(y,w),c,t,h,s,g===i-1))}const d=u===2?",":"";p[0]="["+p[0]+d;for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+d;let f=`,
`;for(let g=2;g<u;g++)f+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":f),p}function Zr(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ss{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=j(e),r!=null){const s=r.length;I(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||_t(t,this.size),this.strides=tt(e)}set(e,...t){t.length===0&&(t=[0]),I(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ht().makeTensor(this.values,this.shape,this.dtype)}}let Ht=null,fr=null;function Oy(n){Ht=n}function Fy(n){fr=n}class He{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=j(e),this.strides=tt(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return fr.buffer(this.shape,this.dtype,e)}bufferSync(){return fr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ua(this.shape,e,this.dtype==="complex64")}arraySync(){return ua(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ht().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>rs(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ht().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ht().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>rs(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ht().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ht().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return fr.print(this,e)}clone(){return this.throwIfDisposed(),fr.clone(this)}toString(e=!1){const t=this.dataSync();return _y(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),fr.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Ht().makeVariable(this,e,t,r)}}Object.defineProperty(He,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Dy(){return ti("Tensor",()=>He)}Dy();class xa extends He{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s);this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!We(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ht().disposeTensor(this),this.dataId=e.dataId,Ht().incRef(this,null)}dispose(){Ht().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(xa,Symbol.hasInstance,{value:n=>n instanceof He&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vu;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(vu||(vu={}));var ba;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(ba||(ba={}));var va;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(va||(va={}));var wa;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(wa||(wa={}));var $a;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})($a||($a={}));const Py={float32:wa,int32:ba,bool:va,complex64:$a};function rn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Py[n][e]}function ui(n){return rn(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(n,e){if(n.dtype===e.dtype)return[n,e];const t=rn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function Gp(n){const e=[];return Hp(n,e,new Set),e}function Hp(n,e,t){if(n==null)return;if(n instanceof He){e.push(n);return}if(!Ly(n))return;const r=n;for(const s in r){const o=r[s];t.has(o)||(t.add(o),Hp(o,e,t))}}function Ly(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(n){return n.kernelName!=null}class wu{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Sr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new wu}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(jt(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Ny(this.backendInstance),!0}setupRegisteredKernels(){pu(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){pu(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof Qc)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,jt(`Initialization of backend ${e} failed`),jt(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return jt(`Initialization of backend ${e} failed`),jt(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,o=this.readSync(t),a=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,o,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Sr.nextTensorId++}nextVariableId(){return Sr.nextVariableId++}clone(e){const t=O.runKernel(si,{x:e}),r={x:e},s=a=>({x:()=>{const i="float32",u={x:a},c={dtype:i};return O.runKernel(ri,u,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,o,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(fa(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let o=0;r.forEach(u=>{o+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-t-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const c=Bo(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Bo(e)){const{kernelName:f,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;const w=fa(f,this.backendName);I(w!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{const $=this.backend.numDataIds();u=w.kernelFunc({inputs:g,attrs:y,backend:this.backend});const S=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,$,S);const T=S.map(C=>{if(C.rank!=null)return C;const{dataId:_,shape:k,dtype:R}=C;return this.makeTensorFromDataId(_,k,R)});if(s){const C=this.getTensorsForGradient(f,g,T);r=this.saveTensorsForBackwardMode(C)}return T}}else{const{forwardFunc:f}=e,g=y=>{!s||(r=y.map(w=>this.keep(this.clone(w))))};i=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,g));const w=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,w),w}}const{inputs:h,attrs:l}=e,p=Bo(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(d=this.profiler.profileKernel(c,h,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,h,t,p,r,l),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(f=>h[f]!=null?h[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=hu(e);if(s!=null){const o=s.inputsToSave||[],a=s.outputsToSave||[];let i;s.saveAllInputs?(I(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(c=>t[c])):i=o.map(c=>t[c]);const u=r.filter((c,h)=>a[h]);return i.concat(u)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&oo(e[0])&&(o=e.map(u=>zn(u)));const a=s.write(o,t,r),i=new He(t,r,a,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const u=this.state.tensorInfo.get(a),c=Gg(o);this.state.numBytes+=c-u.bytes,u.bytes=c}return i}makeTensorFromDataId(e,t,r,s){r=r||"float32";const o=new He(t,r,e,this.nextTensorId());return this.trackTensor(o,s),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new xa(e,t,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*aa(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof xa||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*aa(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:o},u=hu(e);u!=null&&(s=u.gradFunc),s!=null&&(i.gradient=c=>(c=c.map((h,l)=>{if(h==null){const p=r[l],d=Cn(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return h}),s(c.length>1?c:c[0],o,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Gp(e),r=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!r.has(a.id)&&a.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,t,r,s=!1){if(I(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(o instanceof He,()=>"The result y returned by f() must be a tensor.");const a=Iy(this.state.activeTape,t,o);if(!s&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=r==null?By(o.shape):r,Ry(i,a,c=>this.tidy(c),My);const u=t.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return I(cu(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{I(t.every(i=>i instanceof He),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((i,u)=>{s[u]=i});const o=(i,u)=>(r=e(...t,u),I(r.value instanceof He,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(cu(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),a=(i,u)=>{const c=r.gradFunc(i,u),h=Array.isArray(c)?c:[c];I(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(h.every(p=>p instanceof He),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const l={};return h.forEach((p,d)=>{l[d]=()=>p}),l};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Gt(),r=await this.backend.time(e);return r.wallMs=Gt()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new wu;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Sr.nextTensorId=0;Sr.nextVariableId=0;function By(n){const e=el(j(n),"float32");return O.makeTensor(e,n,"float32")}function jp(){const n=sl();if(n._tfengine==null){const e=new Kg(n);n._tfengine=new Sr(e)}return Qg(n._tfengine.ENV),Oy(()=>n._tfengine),n._tfengine}const O=jp();function My(n,e){const t={a:n,b:e};return O.runKernel(ni,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(){return typeof navigator!="undefined"&&navigator!=null}function Kp(n){if(n||Vy()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Xp(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xt=B();Xt.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Xt.registerFlag("IS_BROWSER",()=>Xp());Xt.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Xt.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Xt.registerFlag("PROD",()=>!1);Xt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Xt.getBool("DEBUG"));Xt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Xt.registerFlag("IS_TEST",()=>!1);Xt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Xt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fs(n,e){let t=n;if(nn(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||nn(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&B().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&qp(n,r,[]),r}function qp(n,e,t){if(t=t||[],!Array.isArray(n)&&!nn(n)){I(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}I(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),I(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)qp(n[s],r,t.concat(s))}function $u(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function N(n,e,t,r="numeric"){if(n instanceof He)return $u(r,n.dtype,e,t),n;let s=ao(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),$u(r,s,e,t),n==null||!nn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=fs(n,s);!nn(n)&&!Array.isArray(n)&&(n=[n]);const i=s!=="string"?ii(n,s):wr(n,[],!0);return O.makeTensor(i,o,s)}function Yp(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,a)=>N(o,`${e}[${a}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uy="__op";function F(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Uy;const s=(...o)=>{O.startScope(t);try{const a=r(...o);return ns(a)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(a),a}catch(a){throw O.endScope(null),a}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wy(n,e){const t=N(n,"real","complex"),r=N(e,"imag","complex");Yt(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return O.runKernel(Nl,s)}const Kn=F({complex_:Wy});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n,e,t,r){if(r==null&&(r=ao(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!nn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){tl(e);const s=j(e),o=j(t);I(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let a=0;a<t.length;++a){const i=t[a],u=a===t.length-1?i!==j(e.slice(a)):!0;I(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!nn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?ii(n,r):wr(n,[],!0),O.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(n,e,t){const r=fs(n,t);return ms(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Su={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=4;function zy(n,e){const t={};let r,s=0;for(const o of e){const a=o.name,i=o.dtype,u=o.shape,c=j(u);let h;if("quantization"in o){const l=o.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${o.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=Su[l.dtype],d=n.slice(s,s+c*p),f=l.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(i==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){h=new Float32Array(f.length);for(let g=0;g<f.length;g++){const y=f[g];h[g]=y*l.scale+l.min}}else if(l.dtype==="float16")r===void 0&&(r=Qy()),h=r(f);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(i==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);h=new Int32Array(f.length);for(let g=0;g<f.length;g++){const y=f[g];h[g]=Math.round(y*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=c*p}else if(i==="string"){const l=j(o.shape);h=[];for(let p=0;p<l;p++){const d=new Uint32Array(n.slice(s,s+Tu))[0];s+=Tu;const f=new Uint8Array(n.slice(s,s+d));h.push(f),s+=d}}else{const l=Su[i],p=n.slice(s,s+c*l);if(i==="float32")h=new Float32Array(p);else if(i==="int32")h=new Int32Array(p);else if(i==="bool")h=new Uint8Array(p);else if(i==="complex64"){h=new Float32Array(p);const d=new Float32Array(h.length/2),f=new Float32Array(h.length/2);for(let w=0;w<d.length;w++)d[w]=h[w*2],f[w]=h[w*2+1];const g=Sn(d,u,"float32"),y=Sn(f,u,"float32");t[a]=Kn(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=c*l}i!=="complex64"&&(t[a]=Sn(h,u,i))}return t}const ci=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function Cu(n){return ci?Buffer.byteLength(n):new Blob([n]).size}function Gy(n){if(ci)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function Hy(n){if(ci){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function jy(n){if(n.length===1)return n[0];let e=0;n.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(s=>{t.set(new Uint8Array(s),r),r+=s.byteLength}),t.buffer}function Qp(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}async function Ky(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),n.weightsManifest!=null){const[r,s]=await e(n.weightsManifest);t.weightSpecs=r,t.weightData=s}return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),t}function uo(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Cu(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Cu(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function Xy(){const n=t=>{let r=t<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function qy(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Yy(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Qy(){const n=Xy(),e=qy(),t=Yy();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let a=0;a<r.length;a++){const i=r[a],u=n[t[i>>10]+(i&1023)]+e[i>>10];o[a]=u}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ge{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ge.instance==null&&(Ge.instance=new Ge),Ge.instance}static registerSaveRouter(e){Ge.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ge.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ge.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ge.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?Ge.getInstance().loadRouters:Ge.getInstance().saveRouters).forEach(a=>{const i=a(e,r);i!==null&&s.push(i)}),s}}const Zy=n=>Ge.getSaveHandlers(n),Jy=(n,e)=>Ge.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sa="tensorflowjs",Ta=1,Vn="models_store",bn="model_info_store";function Zp(){if(!B().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window=="undefined"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ca(n){const e=n.result;e.createObjectStore(Vn,{keyPath:"modelPath"}),e.createObjectStore(bn,{keyPath:"modelPath"})}class Xn{constructor(e){if(this.indexedDB=Zp(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const o=this.indexedDB.open(Sa,Ta);o.onupgradeneeded=()=>Ca(o),o.onsuccess=()=>{const a=o.result;if(t==null){const i=a.transaction(Vn,"readonly"),c=i.objectStore(Vn).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=h=>(a.close(),s(c.error)),i.oncomplete=()=>a.close()}else{const i=uo(t),u=a.transaction(bn,"readwrite");let c=u.objectStore(bn);const h=c.put({modelPath:this.modelPath,modelArtifactsInfo:i});let l;h.onsuccess=()=>{l=a.transaction(Vn,"readwrite");const d=l.objectStore(Vn).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});d.onsuccess=()=>r({modelArtifactsInfo:i}),d.onerror=f=>{c=u.objectStore(bn);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(d.error)),g.onerror=y=>(a.close(),s(d.error))}},h.onerror=p=>(a.close(),s(h.error)),u.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}}},o.onerror=a=>s(o.error)})}}Xn.URL_SCHEME="indexeddb://";const Jp=n=>B().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xn.URL_SCHEME)?ex(n.slice(Xn.URL_SCHEME.length)):null;Ge.registerSaveRouter(Jp);Ge.registerLoadRouter(Jp);function ex(n){return new Xn(n)}function tx(n){return n.startsWith(Xn.URL_SCHEME)?n.slice(Xn.URL_SCHEME.length):n}class nx{constructor(){this.indexedDB=Zp()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(Sa,Ta);r.onupgradeneeded=()=>Ca(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(bn,"readonly"),i=o.objectStore(bn).getAll();i.onsuccess=()=>{const u={};for(const c of i.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},i.onerror=u=>(s.close(),t(i.error)),o.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=tx(e),new Promise((t,r)=>{const s=this.indexedDB.open(Sa,Ta);s.onupgradeneeded=()=>Ca(s),s.onsuccess=()=>{const o=s.result,a=o.transaction(bn,"readwrite"),i=a.objectStore(bn),u=i.get(e);let c;u.onsuccess=()=>{if(u.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=i.delete(e),l=()=>{c=o.transaction(Vn,"readwrite");const d=c.objectStore(Vn).delete(e);d.onsuccess=()=>t(u.result.modelArtifactsInfo),d.onerror=f=>r(u.error)};h.onsuccess=l,h.onerror=p=>(l(),o.close(),r(u.error))}},u.onerror=h=>(o.close(),r(u.error)),a.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cn="/",mr="tensorflowjs_models",ed="info",rx="model_topology",sx="weight_specs",ox="weight_data",ax="model_metadata";function td(n){return{info:[mr,n,ed].join(cn),topology:[mr,n,rx].join(cn),weightSpecs:[mr,n,sx].join(cn),weightData:[mr,n,ox].join(cn),modelMetadata:[mr,n,ax].join(cn)}}function nd(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function ix(n){const e=n.split(cn);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(cn)}function ux(n){return n.startsWith(qn.URL_SCHEME)?n.slice(qn.URL_SCHEME.length):n}class qn{constructor(e){if(!B().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=td(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=uo(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Gy(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw nd(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Hy(a),t}}qn.URL_SCHEME="localstorage://";const rd=n=>B().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(qn.URL_SCHEME)?cx(n.slice(qn.URL_SCHEME.length)):null;Ge.registerSaveRouter(rd);Ge.registerLoadRouter(rd);function cx(n){return new qn(n)}class lx{constructor(){I(B().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=mr+cn,r=cn+ed;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(t)&&o.endsWith(r)){const a=ix(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=ux(e);const t=td(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return nd(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu="://";class xn{constructor(){this.managers={}}static getInstance(){return xn.instance==null&&(xn.instance=new xn),xn.instance}static registerManager(e,t){I(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Nu)&&(e=e.slice(0,e.indexOf(Nu))),I(e.length>0,()=>"scheme must not be an empty string.");const r=xn.getInstance();I(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hx{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(B().get("IS_BROWSER")){B().setPlatform("browser",new hx);try{xn.registerManager(qn.URL_SCHEME,new lx)}catch{}try{xn.registerManager(Xn.URL_SCHEME,new nx)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const px={importFetch:()=>require("node-fetch")};let Mo;class dx{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return B().global.fetch!=null?B().global.fetch(e,t):(Mo==null&&(Mo=px.importFetch()),Mo(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}B().get("IS_NODE")&&!B().get("IS_BROWSER")&&B().setPlatform("node",new dx);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qe(n,e="float32",t){return e=e||"float32",tl(n),new ss(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fx(n,e){const t=N(n,"x","cast");if(!Wg(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return O.runKernel(ri,r,s)}const _e=F({cast_:fx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mx(n){const t={x:N(n,"x","clone","string_or_numeric")};return O.runKernel(si,t)}const Gn=F({clone_:mx});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gx(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jp();const yx={buffer:Qe,cast:_e,clone:Gn,print:gx};Fy(yx);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xx="model",bx=".json",vx=".weights.bin";function Eu(n){return new Promise(e=>setTimeout(e)).then(n)}class Yn{constructor(e){if(!B().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Yn.URL_SCHEME)&&(e=e.slice(Yn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=xx),this.modelJsonFileName=e+bx,this.weightDataFileName=e+vx}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=Qp(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await Eu(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await Eu(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:uo(e)}}}}Yn.URL_SCHEME="downloads://";const wx=n=>B().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Yn.URL_SCHEME)?$x(n.slice(Yn.URL_SCHEME.length)):null;Ge.registerSaveRouter(wx);function $x(n="model"){return new Yn(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ku(n,e,t,r){a(n),t=t==null?0:t,r=r==null?1:r,i(t,r);let s=0;const o=u=>(u.then(c=>{const h=t+ ++s/n.length*(r-t);return e(h),c}),u);function a(u){I(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,c){I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),I(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),I(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Sx(n,e){e==null&&(e={});const t=e.fetchFunc==null?B().platform.fetch:e.fetchFunc,r=n.map(l=>t(l,e.requestInit,{isBinary:!0})),s=0,o=.5,i=(e.onProgress==null?await Promise.all(r):await ku(r,e.onProgress,s,o)).map(l=>l.arrayBuffer()),u=.5,c=1;return e.onProgress==null?await Promise.all(i):await ku(i,e.onProgress,u,c)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tx="application/octet-stream",Cx="application/json";class li{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(I(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=B().platform.fetch,I(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Qp(e,r);t.body.append("model.json",new Blob([JSON.stringify(s)],{type:Cx}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Tx}),"model.weights.bin");const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:uo(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ky(t,o=>this.loadWeights(o))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=Nx(t),o=this.weightPathPrefix||r,a=[];for(const h of e)a.push(...h.weights);const i=[],u=[];for(const h of e)for(const l of h.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(l)):i.push(o+l+s);this.weightUrlConverter&&i.push(...await Promise.all(u));const c=await Sx(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,jy(c)]}}li.URL_SCHEME_REGEX=/^https?:\/\//;function Nx(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function Iu(n){return n.match(li.URL_SCHEME_REGEX)!=null}const sd=(n,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>Iu(r)):t=Iu(n),t)return od(n,e)}return null};Ge.registerSaveRouter(sd);Ge.registerLoadRouter(sd);function od(n,e){return new li(n,e)}function Ru(n,e){return od(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ex(n,e,t=!1,r=!1){let s=N(n,"a","matMul"),o=N(e,"b","matMul");[s,o]=Be(s,o);const a={a:s,b:o},i={transposeA:t,transposeB:r};return O.runKernel(vl,a,i)}const Ke=F({matMul_:Ex});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kx(n,e,t=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:N(n,"indices","oneHot","int32")},a={depth:e,onValue:t,offValue:r};return O.runKernel(Bh,o,a)}const Ix=F({oneHot_:kx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rx(n,e){const t=N(n,"x","transpose");if(e==null&&(e=t.shape.map((o,a)=>a).reverse()),I(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(o=>{I(o>=0&&o<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();const r={x:t},s={perm:e};return O.runKernel(Rp,r,s)}const Na=F({transpose_:Rx});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const o=t-1-s,a=n[o]||1;(e[e.length-1-s]||1)>1&&a===1&&r.unshift(o)}return r}function ad(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],o=e.length-r-1,a=e[o];(s==null||s===1&&a>1)&&t.unshift(o)}return t}function Se(n,e){const t=[],r=Math.max(n.length,e.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];o==null&&(o=1);let a=e[e.length-s-1];if(a==null&&(a=1),o===1)t.unshift(a);else if(a===1)t.unshift(o);else if(o!==a){const i=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(i)}else t.unshift(o)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(n,e,t){if(ei(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=fs(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ms(n,e,r,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let On;function Ax(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,a=!1,i=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(s&&s&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(fa(la,O.backendName)!=null){const f={pixels:n},g={numChannels:e};return O.runKernel(la,f,g)}const[c,h]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let l;if(a)l=n.getContext("2d").getImageData(0,0,c,h).data;else if(r||t)l=n.data;else if(o||s||i){if(On==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")On=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else On=document.createElement("canvas").getContext("2d");On.canvas.width=c,On.canvas.height=h,On.drawImage(n,0,0,c,h),l=On.getImageData(0,0,c,h).data}let p;if(e===4)p=new Int32Array(l);else{const f=c*h;p=new Int32Array(f*e);for(let g=0;g<f;g++)for(let y=0;y<e;++y)p[g*e+y]=l[g*4+y]}return _x(p,[h,c,e],"int32")}async function hi(n,e){let t=N(n,"img","toPixels");if(!(n instanceof He)){const c=t;t=_e(c,"int32"),c.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[r,s]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const a=await t.data(),i=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const h=[0,0,0,255];for(let p=0;p<o;p++){const d=a[c*o+p];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);o===1?(h[0]=d*i,h[1]=d*i,h[2]=d*i):h[p]=d*i}const l=c*4;u[l+0]=Math.round(h[0]),u[l+1]=Math.round(h[1]),u[l+2]=Math.round(h[2]),u[l+3]=Math.round(h[3])}if(e!=null){e.width=s,e.height=r;const c=e.getContext("2d"),h=new ImageData(u,s,r);c.putImageData(h,0,0)}return t!==n&&t.dispose(),u}const id=F({fromPixels_:Ax});function ud(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(j(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,o=s[s.length-1];let a=1;for(let l=0;l<s.length-1;++l)a*=s[l];const i=n.shape,u=s.slice();u.pop();let c=1;for(let l=o;l<t;++l)c*=i[l],u.push(i[l]);const h=[...tt(n.shape).map(l=>l/c),1].slice(0,o);return[u,a,c,h]}function cd(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(o+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(o+` update.rank != ${s+n.length-r}`);for(let a=0;a<s;++a)if(t.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-s;++a)if(t.shape[a+s]!==n[a+r])throw new Error(o+` updates.shape[${a+s}] (${t.shape[a+s]}) != shape[${a+s}] (${n[a+s]})`)}function ld(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}cd(t,e,n)}function pi(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=t.length;let a=1;for(let l=s;l<o;++l)a*=t[l];const i=s<1?1:s,u=j(e.shape)/i,c=[...tt(t.slice(0,s)),1],h=j(t);return{sliceRank:s,numUpdates:u,sliceSize:a,strides:c,outputSize:h}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ea=-2,Ox=-1;function hd(n,e,t){const r=n.shape.length;I(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),I(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)I(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Fx(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function pd(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function dd(n,e,t,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<t;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function fd(n,e,t){return t<=n?t:t-(e-1)}function md(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function Dx(n,e,t,r,s,o,a,i,u){const c=n.length;let h=new Array(c),l=new Array(c),p=new Array(c);if(e.length&&t>0){const d=e[0],f=t+1;h=gd(a,d,f,r,n),l=yd(i,d,f,s,n),p=dd(o,d,f,n)}else for(let d=0;d<c;d++)h[d]=bd(a,r,o,n,d,u),l[d]=vd(i,s,o,n,d,u),p[d]=xd(o,d,u);return{begin:h,end:l,strides:p}}function gd(n,e,t,r,s){const o=[...s],a=md(t,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{const u=fd(e,t,i);let c=r[u];n&1<<u&&(c=0),o[i]=c}return o}function yd(n,e,t,r,s){const o=[...s],a=md(t,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const u=fd(e,t,i);let c=r[u];n&1<<u&&(c=Number.MAX_SAFE_INTEGER),o[i]=c}for(let i=0;i<o.length;i++){const u=s[i];o[i]<0&&(o[i]+=u),o[i]=Gs(0,o[i],s[i])}return o}function xd(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function bd(n,e,t,r,s,o){let a=e[s];const i=t[s]||1;(n&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=r[s];return a<0&&(a+=u),a=Gs(0,a,u-1),a}function vd(n,e,t,r,s,o){let a=e[s];const i=t[s]||1;(n&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=r[s];return a<0&&(a+=u),i>0?a=Gs(0,a,u):a=Gs(-1,a,u-1),a}function di(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function fi(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function wd(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(a=>{I(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(s).fill(-1):typeof t=="number"?o=[t,...new Array(s-1).fill(-1)]:t.length<s?o=t.concat(new Array(s-t.length).fill(-1)):o=t,o=o.map((a,i)=>a>=0?a:(I(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),n.shape[i]-r[i])),[r,o]}function $d(n,e,t,r,s,o,a,i,u){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const l={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};for(let S=0;S<l.dims;S++)h&&(1<<S&i)!==0&&l.numAddAxisAfterEllipsis++,1<<S&a&&(h=!0);h||(l.ellipsisMask|=1<<l.dims,l.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Px(l,p);let d=!0,f=!0,g=!0;const y=[],w=[];for(let S=0;S<n.length;++S){if(p.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const T=!!(p.shrinkAxisMask&1<<S),C=n[S];if(C===-1){y.push(T?1:-1);continue}const _=[p.beginMask&1<<S,p.endMask&1<<S],k=[p.strides[S]>0?0:-1,p.strides[S]>0?C:C-1];if(T&&p.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[S]===1;const R=!!(p.beginMask&1<<S&&p.endMask&1<<S);if(p.beginValid&&p.endValid){if(T){const H=p.begin[S]<0?C+p.begin[S]:p.begin[S];if(p.begin[S]=H,p.end[S]=p.begin[S]+1,H<0||H>=C)throw Error(`slice index ${p.begin[S]} of dimension ${S} out of bounds.`)}else p.begin[S]=_u(p.begin[S],0,p.strides[S],C,_,k),p.end[S]=_u(p.end[S],1,p.strides[S],C,_,k);const U=p.strides[S]===1&&p.begin[S]===0&&p.end[S]===C;d=d&&U,f=f&&(S===0&&p.strides[S]===1||U)}else d=d&&p.strides[S]===1&&R,f=f&&(S===0&&p.strides[S]===1||R);let A,P=!1;if(p.beginValid&&p.endValid?(A=p.end[S]-p.begin[S],P=!0):T?(A=1,P=!0):R&&C>=0&&(p.strides[S]<0?A=-C:A=C,P=!0),P){let U;A===0||A<0!=p.strides[S]<0?U=0:U=Math.trunc(A/p.strides[S])+(A%p.strides[S]!==0?1:0),y.push(U)}else y.push(-1)}for(let S=0;S<p.finalShapeGatherIndices.length;++S){const T=p.finalShapeGatherIndices[S];T>=0?w.push(y[T]):T===Ea&&w.push(1)}return{finalShapeSparse:w.filter((S,T)=>p.finalShapeGatherIndices[T]!==Ea),finalShape:w,isIdentity:d,sliceDim0:f,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function Px(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(Ea),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(Ox),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function _u(n,e,t,r,s,o){if(s[e])return t>0?o[e]:o[e+1&1];{const a=n<0?r+n:n;return a<o[0]?o[0]:a>o[1]?o[1]:a}}var Lx=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:hd,maskToAxes:Fx,computeOutShape:pd,stridesWithElidedDims:dd,getNormalizedAxes:Dx,startIndicesWithElidedDims:gd,stopIndicesWithElidedDims:yd,stridesForAxis:xd,startForAxis:bd,stopForAxis:vd,isSliceContinous:di,computeFlatOffset:fi,parseSliceParams:wd,sliceInfo:$d},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pn(){return O}function ae(n,e){return O.tidy(n,e)}function ot(n){Gp(n).forEach(t=>t.dispose())}function vn(n){return O.keep(n)}function Xs(){return O.backendName}function Bx(n,e,t=1){return O.registerBackend(n,e,t)}function Mx(){return O.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(n,e){let t=N(n,"a","add"),r=N(e,"b","add");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(ni,s)}const Ie=F({add_:Vx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ux(n,e){let t=N(n,"a","floorDiv"),r=N(e,"b","floorDiv");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(th,s)}const Sd=F({floorDiv_:Ux});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(n,e){let t=N(n,"a","div"),r=N(e,"b","div");if([t,r]=Be(t,r),t.dtype==="int32"&&r.dtype==="int32")return Sd(t,r);const s={a:t,b:r},o={};return O.runKernel(zl,s,o)}const ke=F({div_:Wx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zx(n,e){let t=N(n,"a","mul"),r=N(e,"b","mul");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(_h,s)}const ee=F({mul_:zx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gx(n){const e=N(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return O.runKernel(El,t)}else{const t={x:e};return O.runKernel(ol,t)}}const kt=F({abs_:Gx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hx(n){const t={x:N(n,"x","acos")};return O.runKernel(al,t)}const jx=F({acos_:Hx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kx(n){const t={x:N(n,"x","acosh")};return O.runKernel(il,t)}const Xx=F({acosh_:Kx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qx(n){I(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),I(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,o)=>N(s,`tensors${o}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!We(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return O.runKernel(ul,r)}const Yx=F({addN_:qx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qx(n,e=null,t=!1){const s={x:N(n,"x","all","bool")},o={axis:e,keepDims:t};return O.runKernel(cl,s,o)}const Zx=F({all_:Qx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jx(n,e=null,t=!1){const s={x:N(n,"x","any","bool")},o={axis:e,keepDims:t};return O.runKernel(ll,s,o)}const e0=F({any_:Jx});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0(n,e=0){const r={x:N(n,"x","argMax")},s={axis:e};return O.runKernel(hl,r,s)}const Td=F({argMax_:t0});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0(n,e=0){const r={x:N(n,"x","argMin")},s={axis:e};return O.runKernel(pl,r,s)}const r0=F({argMin_:n0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0(n){const t={x:N(n,"x","asin")};return O.runKernel(dl,t)}const o0=F({asin_:s0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0(n){const t={x:N(n,"x","asinh")};return O.runKernel(fl,t)}const i0=F({asinh_:a0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0(n){const t={x:N(n,"x","atan")};return O.runKernel(ml,t)}const c0=F({atan_:u0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0(n,e){let t=N(n,"a","atan2"),r=N(e,"b","atan2");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(yl,s)}const h0=F({atan2_:l0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0(n){const t={x:N(n,"x","atanh")};return O.runKernel(gl,t)}const d0=F({atanh_:p0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(n,e,t,r,s="NHWC",o){const a=n[3],i=[...e,a],u=_r(s);return St(n,i,t,o,r,null,null,u)}function Rr(n,e,t,r,s,o,a="channelsLast"){const[i,u]=qs(e);let c;if(a==="channelsLast")c=[i,u,n[3],n[3]];else if(a==="channelsFirst")c=[i,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return St(n,c,t,r,s,o,!1,a)}function gs(n,e,t,r,s,o,a="NDHWC"){const[i,u,c]=ka(e);let h,l;if(a==="NDHWC")l="channelsLast",h=[i,u,c,n[4],n[4]];else if(a==="NCDHW")l="channelsFirst",h=[i,u,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return ys(n,h,t,r,s,!1,l,o)}function St(n,e,t,r,s,o,a=!1,i="channelsLast"){let[u,c,h,l]=[-1,-1,-1,-1];if(i==="channelsLast")[u,c,h,l]=n;else if(i==="channelsFirst")[u,l,c,h]=n;else throw new Error(`Unknown dataFormat ${i}`);const[p,d,,f]=e,[g,y]=qs(t),[w,$]=qs(r),S=br(p,w),T=br(d,$),{padInfo:C,outHeight:_,outWidth:k}=g0(s,c,h,g,y,S,T,o,i),R=a?f*l:f;let A;return i==="channelsFirst"?A=[u,R,_,k]:i==="channelsLast"&&(A=[u,_,k,R]),{batchSize:u,dataFormat:i,inHeight:c,inWidth:h,inChannels:l,outHeight:_,outWidth:k,outChannels:R,padInfo:C,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:d,effectiveFilterHeight:S,effectiveFilterWidth:T,dilationHeight:w,dilationWidth:$,inShape:n,outShape:A,filterShape:e}}function ys(n,e,t,r,s,o=!1,a="channelsLast",i){let[u,c,h,l,p]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,c,h,l,p]=n;else if(a==="channelsFirst")[u,p,c,h,l]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,f,g,,y]=e,[w,$,S]=ka(t),[T,C,_]=ka(r),k=br(d,T),R=br(f,C),A=br(g,_),{padInfo:P,outDepth:U,outHeight:H,outWidth:G}=y0(s,c,h,l,w,$,S,k,R,A,i),q=o?y*p:y;let te;return a==="channelsFirst"?te=[u,q,U,H,G]:a==="channelsLast"&&(te=[u,U,H,G,q]),{batchSize:u,dataFormat:a,inDepth:c,inHeight:h,inWidth:l,inChannels:p,outDepth:U,outHeight:H,outWidth:G,outChannels:q,padInfo:P,strideDepth:w,strideHeight:$,strideWidth:S,filterDepth:d,filterHeight:f,filterWidth:g,effectiveFilterDepth:k,effectiveFilterHeight:R,effectiveFilterWidth:A,dilationDepth:T,dilationHeight:C,dilationWidth:_,inShape:n,outShape:te,filterShape:e}}function f0(n,e,t,r,s){r==null&&(r=mi(n,e,t));const o=n[0],a=n[1],i=Hn((o-e+2*r)/t+1,s),u=Hn((a-e+2*r)/t+1,s);return[i,u]}function m0(n,e,t,r,s,o){s==null&&(s=mi(n,e,r));const a=n[0],i=n[1],u=n[2],c=Hn((a-e+2*s)/r+1,o),h=Hn((i-e+2*s)/r+1,o),l=Hn((u-e+2*s)/r+1,o);return[c,h,l,t]}function mi(n,e,t,r=1){const s=br(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function qs(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function ka(n){return typeof n=="number"?[n,n,n]:n}function br(n,e){return e<=1?n:n+(n-1)*(e-1)}function g0(n,e,t,r,s,o,a,i,u){let c,h,l;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=f0([e,t],o,r,n,i);h=d[0],l=d[1]}else if(n==="same"){h=Math.ceil(e/r),l=Math.ceil(t/s);const p=Math.max(0,(h-1)*r+o-e),d=Math.max(0,(l-1)*s+a-t),f=Math.floor(p/2),g=p-f,y=Math.floor(d/2),w=d-y;c={top:f,bottom:g,left:y,right:w,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-o+1)/r),l=Math.ceil((t-a+1)/s);else if(typeof n=="object"){const p=u==="channelsLast"?n[1][0]:n[2][0],d=u==="channelsLast"?n[1][1]:n[2][1],f=u==="channelsLast"?n[2][0]:n[3][0],g=u==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:d,left:f,right:g,type:p===0&&d===0&&f===0&&g===0?"VALID":"EXPLICIT"},h=Hn((e-o+p+d)/r+1,i),l=Hn((t-a+f+g)/s+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:h,outWidth:l}}function y0(n,e,t,r,s,o,a,i,u,c,h){let l,p,d,f;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=m0([e,t,r,1],i,1,s,n,h);p=y[0],d=y[1],f=y[2]}else if(n==="same"){p=Math.ceil(e/s),d=Math.ceil(t/o),f=Math.ceil(r/a);const g=(p-1)*s+i-e,y=(d-1)*o+u-t,w=(f-1)*a+c-r,$=Math.floor(g/2),S=g-$,T=Math.floor(y/2),C=y-T,_=Math.floor(w/2),k=w-_;l={top:T,bottom:C,left:_,right:k,front:$,back:S,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-i+1)/s),d=Math.ceil((t-u+1)/o),f=Math.ceil((r-c+1)/a);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outDepth:p,outHeight:d,outWidth:f}}function Hn(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function os(n){const[e,t,r]=qs(n);return e===1&&t===1&&r===1}function Tt(n,e){return os(n)||os(e)}function _r(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Pt(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")I(ts(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{I(ts(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n,e){const r={x:N(n,"x","reshape","string_or_numeric")},s={shape:e};return O.runKernel(Xh,r,s)}const W=F({reshape_:x0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0(n,e,t,r,s){const o=N(n,"x","avgPool","float32"),a=1;I(Tt(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=o,u=!1;o.rank===3&&(u=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Pt("avgPool",r,s);const c={x:i},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let l=O.runKernel(xl,c,h);return l=_e(l,o.dtype),u?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const v0=F({avgPool_:b0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0(n,e,t,r,s,o="NDHWC"){const a=N(n,"x","avgPool3d","float32");let i=a,u=!1;a.rank===4&&(u=!0,i=W(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),I(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),I(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Pt("avgPool3d",r,s);const c={x:i},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o};let l=O.runKernel(bl,c,h);return l=_e(l,i.dtype),u?W(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}const $0=F({avgPool3d_:w0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0(n,e=0){I(n.length>=1,()=>"Pass at least one tensor to concat");const t=Yp(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return Gn(t[0]);const r=t,s={axis:e};return O.runKernel(kl,r,s)}const yt=F({concat_:S0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0(n){const t={x:N(n,"x","sigmoid","float32")};return O.runKernel(up,t)}const xs=F({sigmoid_:T0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0(n,e,t){const r=N(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:t};return O.runKernel(sp,s,o)}const $e=F({slice_:C0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0(n){const t={x:N(n,"x","tanh","float32")};return O.runKernel(Ep,t)}const E0=F({tanh_:N0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0(n,e,t){const r=N(n,"x","batchToSpaceND"),s=e.reduce((i,u)=>i*u);I(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),I(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),I(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},a={blockShape:e,crops:t};return O.runKernel(wl,o,a)}const I0=F({batchToSpaceND_:k0});function R0(n){let e;return n.rank===0||n.rank===1?e=W(n,[1,1,1,n.size]):n.rank===2?e=W(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0(n,e,t,r,s,o){o==null&&(o=.001);const a=N(n,"x","batchNorm"),i=N(e,"mean","batchNorm"),u=N(t,"variance","batchNorm");let c;s!=null&&(c=N(s,"scale","batchNorm"));let h;r!=null&&(h=N(r,"offset","batchNorm")),I(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(h==null||i.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:R0(a),scale:c,offset:h,mean:i,variance:u},d={varianceEpsilon:o},f=O.runKernel(nh,p,d);return W(f,a.shape)}const Au=F({batchNorm_:_0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0(n,e,t){const r=N(n,"x","bincount"),s=N(e,"weights","bincount");I(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},a={size:t};return O.runKernel($l,o,a)}const Nd=F({bincount_:A0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0(n,e){const t=N(n,"s0","broadcastArgs","int32"),r=N(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return O.runKernel(Sl,s)}const F0=F({broadcastArgs_:O0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0(n,e){let t=N(n,"broadcastTo","x");const r=t.shape;if(e.some(c=>!(c>0)||c%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=W(t,c)}const s=t.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])o[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return Gn(t);const i={x:t},u={reps:o};return O.runKernel(oi,i,u)}const Us=F({broadcastTo_:D0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0(n){const t={x:N(n,"x","ceil","float32")};return O.runKernel(Tl,t)}const L0=F({ceil_:P0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0(n,e,t){const r=N(n,"x","clipByValue");I(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const s={x:r},o={clipValueMin:e,clipValueMax:t};return O.runKernel(Cl,s,o)}const Ed=F({clipByValue_:B0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0(n,e,t,r,s="NHWC",o=[1,1],a){const i=N(n,"x","conv2d","float32"),u=N(e,"filter","conv2d","float32");let c=i,h=!1;i.rank===3&&(h=!0,c=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),I(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Pt("conv2d",r,a);const l=s==="NHWC"?c.shape[3]:c.shape[1];I(l===u.shape[2],()=>`Error in conv2d: depth of input (${l}) must match input depth for filter ${u.shape[2]}.`),I(Tt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const p={x:c,filter:u},d={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},f=O.runKernel(Il,p,d);return h?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const gi=F({conv2d_:M0});function V0(n,e,t,r,s="NWC",o=1,a){const i=N(n,"x","conv1d"),u=N(e,"filter","conv1d");let c=i,h=!1;i.rank===2&&(h=!0,c=W(i,[1,i.shape[0],i.shape[1]])),I(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),I(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Pt("conv1d",r,a),I(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),I(Tt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),I(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const l=W(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=W(c,[c.shape[0],1,c.shape[1],c.shape[2]]),y=gi(p,l,[1,t],r,"NHWC",[1,o],a);return h?W(y,[y.shape[2],y.shape[3]]):W(y,[y.shape[0],y.shape[2],y.shape[3]])}const U0=F({conv1d_:V0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0(n,e,t,r,s,o="NHWC",a){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,u=e,c=!1;e.rank===3&&(c=!0,u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,n[0],n[1],n[2]]),I(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),I(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),I(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const h=o==="NHWC"?i[3]:i[1],l=o==="NHWC"?u.shape[3]:u.shape[1];I(h===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[2]}.`),I(l===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[3]}.`),Pt("conv2dDerInput",s,a);const p={dy:u,filter:t},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,inputShape:i},f=O.runKernel(_l,p,d);return c?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const kd=F({conv2DBackpropInput_:W0});function z0(n,e,t,r,s,o){const a=N(n,"x","conv2dTranspose"),i=N(e,"filter","conv2dTranspose");return kd(t,a,i,r,s,"NHWC",o)}const G0=F({conv2dTranspose_:z0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0(n,e,t,r,s="NDHWC",o=[1,1,1]){const a=N(n,"x","conv3d"),i=N(e,"filter","conv3d");let u=a,c=!1;a.rank===4&&(c=!0,u=W(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),I(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),I(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),I(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),I(Tt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h={x:u,filter:i},l={strides:t,pad:r,dataFormat:s,dilations:o},p=O.runKernel(Al,h,l);return c?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const j0=F({conv3d_:H0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0(n){const t={x:N(n,"x","cos","float32")};return O.runKernel(Ol,t)}const X0=F({cos_:K0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0(n){const t={x:N(n,"x","cosh","float32")};return O.runKernel(Fl,t)}const Y0=F({cosh_:q0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0(n,e=0,t=!1,r=!1){const o={x:N(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:r};return O.runKernel(Dl,o,a)}const Z0=F({cumsum_:Q0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0(n,e,t,r=!1){const s=N(n,"x","denseBincount"),o=N(e,"weights","denseBincount");I(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),I(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const a={x:s,weights:o},i={size:t,binaryOutput:r};return O.runKernel(Ll,a,i)}const e1=F({denseBincount_:J0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1(n,e,t="NHWC"){const r=N(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],o=t==="NHWC"?r.shape[2]:r.shape[3],a=t==="NHWC"?r.shape[3]:r.shape[1];I(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),I(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),I(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),I(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:e,dataFormat:t};return O.runKernel(Bl,i,u)}const n1=F({depthToSpace_:t1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r1(n,e,t,r,s="NHWC",o=[1,1],a){const i=N(n,"x","depthwiseConv2d","float32"),u=N(e,"filter","depthwiseConv2d","float32");let c=i,h=!1;i.rank===3&&(h=!0,c=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),I(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),I(c.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Pt("depthwiseConv2d",r,a);const l={x:c,filter:u},p={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},d=O.runKernel(Ml,l,p);return h?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Id=F({depthwiseConv2d_:r1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1(n,e,t,r,s=[1,1],o="NHWC"){const a=N(n,"x","dilation2d"),i=N(e,"filter","dilation2d");I(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),I(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),I(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=a,c=!1;a.rank===3&&(u=W(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0);const h={x:u,filter:i},l={strides:t,pad:r,dilations:s},p=O.runKernel(Wl,h,l);return c?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const o1=F({dilation2d_:s1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1(n,e){let t=N(n,"a","equal","string_or_numeric"),r=N(e,"b","equal","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Kl,s)}const Rd=F({equal_:a1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1(n,e,t){const r=N(e,"a","where"),s=N(t,"b","where"),o=N(n,"condition","where","bool"),a=Se(Se(o.shape,r.shape),s.shape),i=Us(o,a),u=Us(r,a),c=Us(s,a),h={condition:i,t:u,e:c};return O.runKernel(np,h)}const Tr=F({where_:i1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u1(n){const t={x:N(n,"x","zerosLike")};return O.runKernel(Op,t)}const yi=F({zerosLike_:u1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1(n,e){let t=N(n,"a","div"),r=N(e,"b","div");[t,r]=Be(t,r);const s=ke(t,r),o=yi(s),a=Rd(r,o);return Tr(a,o,s)}const l1=F({divNoNan_:c1});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h1(n,...e){const t=e.map((s,o)=>N(s,`tensors${o}`,"einsum")),r={equation:n};return O.runKernel(Gl,t,r)}const p1=F({einsum_:h1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d1(n){const t={x:N(n,"x","elu","float32")};return O.runKernel(Hl,t)}const _d=F({elu_:d1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f1(n){let e=N(n,"x","erf");I(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=_e(e,"float32"));const t={x:e};return O.runKernel(jl,t)}const m1=F({erf_:f1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1(n){const t={x:N(n,"x","exp")};return O.runKernel(Xl,t)}const pn=F({exp_:g1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1(n,e=0){const t=N(n,"x","expandDims","string_or_numeric");I(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return O.runKernel(ql,r,s)}const Rt=F({expandDims_:y1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(n){const t={x:N(n,"x","expm1")};return O.runKernel(Yl,t)}const b1=F({expm1_:x1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1(n,e){const t=N(n,"x","tile","string_or_numeric");I(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return O.runKernel(oi,r,s)}const es=F({tile_:v1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1(n,e,t,r="float32"){e==null&&(e=n);const s=Qe([n,e],r),o=n<=e?n:e;for(let i=0;i<o;++i)s.set(1,i,i);const a=W(s.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return es(Rt(a,0),[t[0],1,1]);if(t.length===2)return es(Rt(Rt(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return es(Rt(Rt(Rt(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const $1=F({eye_:w1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xi(n,e,t){const r={shape:n,value:e,dtype:t};return O.runKernel(Zl,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1(n){const t={x:N(n,"x","floor","float32")};return O.runKernel(eh,t)}const T1=F({floor_:S1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1(n,e,t=0,r=0){const s=N(n,"x","gather"),o=N(e,"indices","gather","int32"),a={x:s,indices:o},i={axis:t,batchDims:r};return O.runKernel(rh,a,i)}const Ou=F({gather_:C1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1(n,e){let t=N(n,"a","greater","string_or_numeric"),r=N(e,"b","greater","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(oh,s)}const co=F({greater_:N1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1(n,e){let t=N(n,"a","greaterEqual","string_or_numeric"),r=N(e,"b","greaterEqual","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(ah,s)}const Ad=F({greaterEqual_:E1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1(n){const t={input:N(n,"input","imag")};return O.runKernel(uh,t)}const bi=F({imag_:k1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(n){const t={x:N(n,"x","isNaN")};return O.runKernel(ch,t)}const R1=F({isNaN_:I1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(n,e=.2){const r={x:N(n,"x","leakyRelu")},s={alpha:e};return O.runKernel(lh,r,s)}const Od=F({leakyRelu_:_1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n,e){let t=N(n,"a","less","string_or_numeric"),r=N(e,"b","less","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(hh,s)}const O1=F({less_:A1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1(n,e){let t=N(n,"a","lessEqual","string_or_numeric"),r=N(e,"b","lessEqual","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(ph,s)}const vi=F({lessEqual_:F1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return O.runKernel(dh,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1(n,e=5,t=1,r=1,s=.5){const o=N(n,"x","localResponseNormalization");I(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),I(ts(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:a},c={depthRadius:e,bias:t,alpha:r,beta:s},h=O.runKernel(bh,u,c);return i?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const L1=F({localResponseNormalization_:P1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B1(n){const t={x:N(n,"x","log","float32")};return O.runKernel(fh,t)}const as=F({log_:B1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M1(n){const t={x:N(n,"x","log1p")};return O.runKernel(mh,t)}const Fd=F({log1p_:M1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(n){return O.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1(n){const t={x:N(n,"x","neg")};return O.runKernel(Ah,t)}const bs=F({neg_:V1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1(n){const t={x:N(n,"x","softplus")};return O.runKernel(cp,t)}const W1=F({softplus_:U1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(n,e=null,t=!1){const s={x:N(n,"x","max")},o={reductionIndices:e,keepDims:t};return O.runKernel(vh,s,o)}const vr=F({max_:z1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(n,e){let t=N(n,"a","sub"),r=N(e,"b","sub");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(Cp,s)}const fe=F({sub_:G1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1(n,e=null,t=!1){let r=N(n,"x","sum");r.dtype==="bool"&&(r=_e(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return O.runKernel(hp,s,o)}const Fe=F({sum_:H1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1(n,e=-1){const t=N(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Nn((s,o)=>{const i=vr(s,e,!0),u=fe(s,i),c=fe(_e(u,"float32"),as(Fe(pn(u),e,!0)));return o([c]),{value:c,gradFunc:(l,p)=>{const[d]=p,f=!0,g=pn(d);return fe(l,ee(Fe(l,e,f),g))}}})(t)}const K1=F({logSoftmax_:j1});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wi(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Dd(n,e,t){const r=n.length+e.length,s=[];let o=0,a=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?s.push(n[o++]):s.push(e[a++]);return s}function on(n,e){const t=[],r=n.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&t.push(n[o]);const s=e.map(o=>n[o]);return[t,s]}function Lt(n,e){const t=e.map(r=>1);return Dd(n,t,e)}function Zt(n,e,t){I(wi(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Bt(n,e){if(wi(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function $i(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Mt(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X1(n,e=null,t=!1){const r=N(n,"x","logSumExp"),s=Ze(e,r.shape),o=vr(r,s,!0),a=fe(r,o),i=pn(a),u=Fe(i,s),c=as(u),h=Ie(W(o,c.shape),c);if(t){const l=Lt(h.shape,s);return W(h,l)}return h}const q1=F({logSumExp_:X1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(n,e){const t=N(n,"a","logicalAnd","bool"),r=N(e,"b","logicalAnd","bool");Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(gh,s)}const Pd=F({logicalAnd_:Y1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1(n){const t={x:N(n,"x","logicalNot","bool")};return O.runKernel(yh,t)}const Z1=F({logicalNot_:Q1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n,e){const t=N(n,"a","logicalOr","bool"),r=N(e,"b","logicalOr","bool");Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(xh,s)}const eb=F({logicalOr_:J1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tb(n,e,t,r,s){const o=N(n,"x","maxPool"),a=1;let i=o,u=!1;o.rank===3&&(u=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),I(Tt(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Pt("maxPool",r,s);const c={x:i},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s},l=O.runKernel($h,c,h);return u?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const nb=F({maxPool_:tb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(n,e=[1,1,1],t,r,s,o="NDHWC"){const a=N(n,"x","maxPool3d");let i=a,u=!1;a.rank===4&&(u=!0,i=W(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),I(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),I(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Pt("maxPool3d",r,s);const c={x:i},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o},l=O.runKernel(Sh,c,h);return u?W(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}const sb=F({maxPool3d_:rb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ob(n,e,t,r,s=!1){const a={x:N(n,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=O.runKernel(Th,a,i);return{result:u[0],indexes:u[1]}}const ab=F({maxPoolWithArgmax_:ob});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(n,e){let t=N(n,"a","maximum"),r=N(e,"b","maximum");[t,r]=Be(t,r),t.dtype==="bool"&&(t=_e(t,"int32"),r=_e(r,"int32")),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(wh,s)}const ub=F({maximum_:ib});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n,e=null,t=!1){const s={x:N(n,"x","mean")},o={axis:e,keepDims:t};return O.runKernel(Ch,s,o)}const Ld=F({mean_:cb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function En(n,e="float32"){if(e==="complex64"){const r=En(n,"float32"),s=En(n,"float32");return Kn(r,s)}const t=Cn(j(n),e);return O.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Si(n,e="float32"){if(e==="complex64"){const r=Si(n,"float32"),s=En(n,"float32");return Kn(r,s)}const t=el(j(n),e);return O.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(n,e=null,t=!1){const s={x:N(n,"x","min")},o={axis:e,keepDims:t};return O.runKernel(Nh,s,o)}const Ia=F({min_:lb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hb(n,e){let t=N(n,"a","minimum"),r=N(e,"b","minimum");[t,r]=Be(t,r),t.dtype==="bool"&&(t=_e(t,"int32"),r=_e(r,"int32")),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Eh,s)}const Ti=F({minimum_:hb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pb(n,e,t){I(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=N(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let i=0;i<r.rank;i++)I(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),I(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:t},a={x:r};return O.runKernel(kh,a,o)}const Bd=F({mirrorPad_:pb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function db(n,e){let t=N(n,"a","mod"),r=N(e,"b","mod");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(Ih,s)}const fb=F({mod_:db});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mb(n){const e=N(n,"x","square"),t={};return O.runKernel("Square",{x:e},t)}const lo=F({square_:mb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gb(n,e,t,r=!1){const s=N(n,"logits","multinomial"),o=s.size,a=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const u={logits:a===1?W(s,[1,-1]):s},c={numSamples:e,seed:t,normalized:r},h=O.runKernel(Rh,u,c);return a===1?W(h,[h.size]):h}const yb=F({multinomial_:gb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(n,e){let t=N(n,"a","notEqual","string_or_numeric"),r=N(e,"b","notEqual","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Oh,s)}const Md=F({notEqual_:xb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(n){const t={x:N(n,"x","onesLike")};return O.runKernel(Lh,t)}const vb=F({onesLike_:bb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wb(n,e,t=0){const r=N(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},o={x:r};return O.runKernel(Vh,o,s)}const Ys=F({pad_:wb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $b(n,e,t){const r=N(n,"x","spaceToBatchND");I(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),I(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),I(r.shape.reduce((a,i,u)=>u>0&&u<=e.length?a&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:t};return O.runKernel(pp,s,o)}const Sb=F({spaceToBatchND_:$b});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(n,e){let t=N(n,"base","pow"),r=N(e,"exp","pow");[t,r]=Be(t,r);const s={a:t,b:r};return O.runKernel(Uh,s)}const Vd=F({pow_:Tb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cb(n,e){const t=N(n,"x","prelu"),r=N(e,"alpha","prelu"),s={x:t,alpha:r};return O.runKernel(Wh,s)}const Ud=F({prelu_:Cb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nb(n,e=null,t=!1){let r=N(n,"x","prod");r.dtype==="bool"&&(r=_e(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return O.runKernel(zh,s,o)}const Wd=F({prod_:Nb});var zd={exports:{}};(function(n){(function(e,t,r){function s(u){var c=this,h=i();c.next=function(){var l=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=l-(c.c=l|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(u),c.s0<0&&(c.s0+=1),c.s1-=h(u),c.s1<0&&(c.s1+=1),c.s2-=h(u),c.s2<0&&(c.s2+=1),h=null}function o(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function a(u,c){var h=new s(u),l=c&&c.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,l&&(typeof l=="object"&&o(l,h),p.state=function(){return o(h,{})}),p}function i(){var u=4022871197,c=function(h){h=h.toString();for(var l=0;l<h.length;l++){u+=h.charCodeAt(l);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.alea=a})(hn,n,!1)})(zd);var Gd={exports:{}};(function(n){(function(e,t,r){function s(i){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var l=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^l^l>>>8},i===(i|0)?u.x=i:c+=i;for(var h=0;h<c.length+64;h++)u.x^=c.charCodeAt(h)|0,u.next()}function o(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function a(i,u){var c=new s(i),h=u&&u.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,h&&(typeof h=="object"&&o(h,c),l.state=function(){return o(c,{})}),l}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xor128=a})(hn,n,!1)})(Gd);var Hd={exports:{}};(function(n){(function(e,t,r){function s(i){var u=this,c="";u.next=function(){var l=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(l^l<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:c+=i;for(var h=0;h<c.length+64;h++)u.x^=c.charCodeAt(h)|0,h==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function a(i,u){var c=new s(i),h=u&&u.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,h&&(typeof h=="object"&&o(h,c),l.state=function(){return o(c,{})}),l}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xorwow=a})(hn,n,!1)})(Hd);var jd={exports:{}};(function(n){(function(e,t,r){function s(i){var u=this;u.next=function(){var h=u.x,l=u.i,p,d;return p=h[l],p^=p>>>7,d=p^p<<24,p=h[l+1&7],d^=p^p>>>10,p=h[l+3&7],d^=p^p>>>3,p=h[l+4&7],d^=p^p<<7,p=h[l+7&7],p=p^p<<13,d^=p^p<<9,h[l]=d,u.i=l+1&7,d};function c(h,l){var p,d=[];if(l===(l|0))d[0]=l;else for(l=""+l,p=0;p<l.length;++p)d[p&7]=d[p&7]<<15^l.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8&&(d[7]=-1),h.x=d,h.i=0,p=256;p>0;--p)h.next()}c(u,i)}function o(i,u){return u.x=i.x.slice(),u.i=i.i,u}function a(i,u){i==null&&(i=+new Date);var c=new s(i),h=u&&u.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,h&&(h.x&&o(h,c),l.state=function(){return o(c,{})}),l}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xorshift7=a})(hn,n,!1)})(jd);var Kd={exports:{}};(function(n){(function(e,t,r){function s(i){var u=this;u.next=function(){var h=u.w,l=u.X,p=u.i,d,f;return u.w=h=h+1640531527|0,f=l[p+34&127],d=l[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=l[p]=f^d,u.i=p,f+(h^h>>>16)|0};function c(h,l){var p,d,f,g,y,w=[],$=128;for(l===(l|0)?(d=l,l=null):(l=l+"\0",d=0,$=Math.max($,l.length)),f=0,g=-32;g<$;++g)l&&(d^=l.charCodeAt((g+32)%l.length)),g===0&&(y=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,g>=0&&(y=y+1640531527|0,p=w[g&127]^=d+y,f=p==0?f+1:0);for(f>=128&&(w[(l&&l.length||0)&127]=-1),f=127,g=4*128;g>0;--g)d=w[f+34&127],p=w[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,w[f]=d^p;h.w=y,h.X=w,h.i=f}c(u,i)}function o(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function a(i,u){i==null&&(i=+new Date);var c=new s(i),h=u&&u.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,h&&(h.X&&o(h,c),l.state=function(){return o(c,{})}),l}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xor4096=a})(hn,n,!1)})(Kd);var Xd={exports:{}};(function(n){(function(e,t,r){function s(i){var u=this,c="";u.next=function(){var l=u.b,p=u.c,d=u.d,f=u.a;return l=l<<25^l>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-l|0,u.b=l=l<<20^l>>>12^p,u.c=p=p-d|0,u.d=d<<16^p>>>16^f,u.a=f-l|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):c+=i;for(var h=0;h<c.length+20;h++)u.b^=c.charCodeAt(h)|0,u.next()}function o(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function a(i,u){var c=new s(i),h=u&&u.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,h&&(typeof h=="object"&&o(h,c),l.state=function(){return o(c,{})}),l}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.tychei=a})(hn,n,!1)})(Xd);var qd={exports:{}};(function(n){(function(e,t){var r=this,s=256,o=6,a=52,i="random",u=t.pow(s,o),c=t.pow(2,a),h=c*2,l=s-1,p;function d(T,C,_){var k=[];C=C==!0?{entropy:!0}:C||{};var R=w(y(C.entropy?[T,S(e)]:T==null?$():T,3),k),A=new f(k),P=function(){for(var U=A.g(o),H=u,G=0;U<c;)U=(U+G)*s,H*=s,G=A.g(1);for(;U>=h;)U/=2,H/=2,G>>>=1;return(U+G)/H};return P.int32=function(){return A.g(4)|0},P.quick=function(){return A.g(4)/4294967296},P.double=P,w(S(A.S),e),(C.pass||_||function(U,H,G,q){return q&&(q.S&&g(q,A),U.state=function(){return g(A,{})}),G?(t[i]=U,H):U})(P,R,"global"in C?C.global:this==t,C.state)}t["seed"+i]=d;function f(T){var C,_=T.length,k=this,R=0,A=k.i=k.j=0,P=k.S=[];for(_||(T=[_++]);R<s;)P[R]=R++;for(R=0;R<s;R++)P[R]=P[A=l&A+T[R%_]+(C=P[R])],P[A]=C;(k.g=function(U){for(var H,G=0,q=k.i,te=k.j,ne=k.S;U--;)H=ne[q=l&q+1],G=G*s+ne[l&(ne[q]=ne[te=l&te+H])+(ne[te]=H)];return k.i=q,k.j=te,G})(s)}function g(T,C){return C.i=T.i,C.j=T.j,C.S=T.S.slice(),C}function y(T,C){var _=[],k=typeof T,R;if(C&&k=="object")for(R in T)try{_.push(y(T[R],C-1))}catch{}return _.length?_:k=="string"?T:T+"\0"}function w(T,C){for(var _=T+"",k,R=0;R<_.length;)C[l&R]=l&(k^=C[l&R]*19)+_.charCodeAt(R++);return S(C)}function $(){try{var T;return p&&(T=p.randomBytes)?T=T(s):(T=new Uint8Array(s),(r.crypto||r.msCrypto).getRandomValues(T)),S(T)}catch{var C=r.navigator,_=C&&C.plugins;return[+new Date,r,_,r.screen,S(e)]}}function S(T){return String.fromCharCode.apply(0,T)}if(w(t.random(),e),n.exports){n.exports=d;try{p=require("crypto")}catch{}}})([],Math)})(qd);var Eb=zd.exports,kb=Gd.exports,Ib=Hd.exports,Rb=jd.exports,_b=Kd.exports,Ab=Xd.exports,Jn=qd.exports;Jn.alea=Eb;Jn.xor128=kb;Jn.xorwow=Ib;Jn.xorshift7=Rb;Jn.xor4096=_b;Jn.tychei=Ab;var Yd=Jn;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ob{constructor(e,t,r,s,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=Yd.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,o,a;do s=2*this.random()-1,o=2*this.random()-1,a=s*s+o*o;while(a>=1||a===0);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*s*i,t=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Fb{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Yd.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Db(n,e=0,t=1,r="float32",s){const o=Qe(n,r),a=new Fb(e,t,null,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Pb=F({randomUniform_:Db});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return O.runKernel(Gh,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lb(n){const t={input:N(n,"input","real")};return O.runKernel(Hh,t)}const Qs=F({real_:Lb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bb(n){const t={x:N(n,"x","reciprocal")};return O.runKernel(jh,t)}const Mb=F({reciprocal_:Bb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vb(n){const t={x:N(n,"x","relu")};return O.runKernel(Kh,t)}const ho=F({relu_:Vb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ub(n){const t={x:N(n,"x","relu6")};return O.runKernel(Qh,t)}const Qd=F({relu6_:Ub});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(n,e){const r={x:N(n,"x","reverse")},s={dims:e};return O.runKernel(Zh,r,s)}const Zs=F({reverse_:Wb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zb(n){const t={x:N(n,"x","round")};return O.runKernel(Jh,t)}const Zd=F({round_:zb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gb(n){const t={x:N(n,"x","rsqrt","float32")};return O.runKernel(ep,t)}const Hb=F({rsqrt_:Gb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function me(n,e){if((nn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&nn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ms(n,[],[],e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jb(n){const t={x:N(n,"x","selu")};return O.runKernel(rp,t)}const Kb=F({selu_:jb});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Xb(n,e){const t=N(n,"x","setdiff1d"),r=N(e,"y","setdiff1d");I(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),I(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),I(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),o=await r.data(),a=new Set(o);let i=0;for(let h=0;h<s.length;h++)a.has(s[h])||i++;const u=new ss([i],t.dtype),c=new ss([i],"int32");for(let h=0,l=0;h<s.length;h++)a.has(s[h])||(u.values[l]=s[h],c.values[l]=h,l++);return[u.toTensor(),c.toTensor()]}const qb=Xb;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yb(n){const t={x:N(n,"x","sign")};return O.runKernel(ip,t)}const Qb=F({sign_:Yb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zb(n){const t={x:N(n,"x","sin","float32")};return O.runKernel(op,t)}const Jb=F({sin_:Zb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(n){const t={x:N(n,"x","sinh")};return O.runKernel(ap,t)}const tv=F({sinh_:ev});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n,e=-1){const t=N(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return O.runKernel(fp,r,s)}const rv=F({softmax_:nv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sv(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return O.runKernel(Ql,e)}const Jd=F({fft_:sv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ov(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return O.runKernel(ih,e)}const Ra=F({ifft_:ov});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=W(n,[t,e]);r=Ra(s)}else{const s=[t,2*(e-1)],o=W(Qs(n),[t,e]),a=W(bi(n),[t,e]),i=Zs($e(o,[0,1],[t,e-2]),1),u=ee(Zs($e(a,[0,1],[t,e-2]),1),me(-1)),c=yt([o,i],1),h=yt([a,u],1),l=W(Kn(c,h),[s[0],s[1]]);r=Ra(l)}if(r=Qs(r),n.rank===3&&n.shape[0]!==0){const s=r,o=n.shape[0];r=W(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const iv=F({irfft_:av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uv(n,e,t=0){const s={x:N(n,"x","split")},o={numOrSizeSplits:e,axis:t};return O.runKernel(dp,s,o)}const us=F({split_:uv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cv(n,e){I(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const f=n.shape.map(y=>0),g=n.shape.map(y=>y);g[n.shape.length-1]=e,s=$e(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,s=yt([n,En(f)],n.shape.length-1),t=e}else s=n;const o=yi(s),a=W(Kn(s,o),[r,t]),i=Jd(a),u=Math.floor(t/2)+1,c=Qs(i),h=bi(i),l=us(c,[u,t-u],c.shape.length-1),p=us(h,[u,t-u],h.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,W(Kn(l[0],p[0]),d)}const ef=F({rfft_:cv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lv(n){const t={x:N(n,"x","sqrt","float32")};return O.runKernel(lp,t)}const _a=F({sqrt_:lv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hv(n,e){let t=N(n,"a","squaredDifference"),r=N(e,"b","squaredDifference");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r},o={};return O.runKernel(vp,s,o)}const tf=F({squaredDifference_:hv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pv(n,e){const t=N(n,"x","squeeze");return W(t,kn(t.shape,e).newShape)}const Ne=F({squeeze_:pv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dv(n,e=0){const t=Yp(n,"tensors","stack","string_or_numeric");I(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&I(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return O.runKernel(Mh,r,s)}const dn=F({stack_:dv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n,e=0){const r={x:N(n,"x","step")},s={alpha:e};return O.runKernel(Fp,r,s)}const mv=F({step_:fv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(n,e,t,r,s=0,o=0,a=0,i=0,u=0){const h={x:N(n,"x","stridedSlice","string_or_numeric")},l={begin:e,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};return O.runKernel(wp,h,l)}const yv=F({stridedSlice_:gv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(n){const t={x:N(n,"x","tan","float32")};return O.runKernel(Np,t)}const bv=F({tan_:xv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function et(n,e){ei(n);const t=fs(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ms(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(n,e,t){if(ei(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=fs(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ms(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n,e=1,t=!0){const r=N(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},a={k:e,sorted:t},[i,u]=O.runKernel(kp,o,a);return{values:i,indices:u}}const wv=F({topk_:vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Ob(e,t,r,!0,s),a=Qe(n,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const Sv=F({truncatedNormal_:$v});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tv(n,e=0){const t=N(n,"x","unique","string_or_numeric");I(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[o,a]=O.runKernel(_p,r,s);return{values:o,indices:a}}const Fu=F({unique_:Tv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n,e=0){const t=N(n,"x","unstack","string_or_numeric");I(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return O.runKernel(Ap,r,s)}const er=F({unstack_:Cv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nf(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const r=Qe(n,"int32"),s=Qe([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const a=r.indexToLoc(t[o]),i=o*n.length;s.values.set(a,i)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Nv(n){const e=N(n,"condition","whereAsync","bool"),t=await e.data(),r=nf(e.shape,t);return n!==e&&e.dispose(),r}const Ev=Nv;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n,e="euclidean",t=null,r=!1){n=N(n,"x","norm");const s=rf(n,e,t);let o=s.shape;if(r){const a=Ze(t,n.shape);o=Lt(s.shape,a)}return W(s,o)}function rf(n,e,t=null){if(n.rank===0)return kt(n);if(n.rank!==1&&t===null)return rf(W(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Fe(kt(n),t);if(e===1/0)return vr(kt(n),t);if(e===-1/0)return Ia(kt(n),t);if(e==="euclidean"||e===2)return _a(Fe(Vd(kt(n),me(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return vr(Fe(kt(n),t[0]),t[1]-1);if(e===1/0)return vr(Fe(kt(n),t[1]),t[0]);if(e===-1/0)return Ia(Fe(kt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return _a(Fe(lo(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const sf=F({norm_:kv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(n,e,t){const r=N(n,"indices","scatterND","int32"),s=N(e,"updates","scatterND");ld(s,r,t);const o={indices:r,updates:s},a={shape:t};return O.runKernel(tp,o,a)}const Rv=F({scatterND_:Iv});function _v(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n,e,t,r=0){const s=N(n,"sparseIndices","sparseToDense","int32"),o=N(e,"sparseValues","sparseToDense"),a=N(r,"defaultValue","sparseToDense",o.dtype);_v(s,o,t,a);const i={sparseIndices:s,sparseValues:o,defaultValue:a},u={outputShape:t};return O.runKernel(bp,i,u)}const of=F({sparseToDense_:Av});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n,e){const t=N(e,"indices","gatherND","int32"),s={params:N(n,"x","gatherND","string_or_numeric"),indices:t};return O.runKernel(sh,s)}const Fv=F({gatherND_:Ov});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dv(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function af(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const a=2*Math.PI*o/(n+r-1);s[o]=e-t*Math.cos(a)}return et(s,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pv(n,e,t,r,s,o="NHWC",a){let i=n;n.rank===3&&(i=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]])),I(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),I(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),I(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=o==="NHWC"?i.shape[3]:i.shape[1],h=o==="NHWC"?u.shape[3]:u.shape[1];I(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),I(h===t[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${t[3]}).`),Pt("conv2dDerFilter",s,a);const l={x:i,dy:u},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,filterShape:t};return O.runKernel(Rl,l,p)}const Lv=F({conv2DBackpropFilter_:Pv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function po(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ee(n,mv(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function fo(n,e){let t=e;const r=ad(n.shape,e.shape);return r.length>0&&(t=Fe(t,r)),W(t,n.shape)}function mo(n,e,t,r){if(e==="linear")return n;if(e==="relu")return ho(n);if(e==="elu")return _d(n);if(e==="relu6")return Qd(n);if(e==="prelu")return Ud(n,t);if(e==="leakyrelu")return Od(n,r);if(e==="sigmoid")return xs(n);throw new Error(`Unknown fused activation ${e}.`)}const go=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(u=u||"linear",go(O.state.gradientDepth,u)===!1){let C=gi(n,e,t,r,s,o,a);return i!=null&&(C=Ie(C,i)),mo(C,u,c,h)}const l=N(n,"x","conv2d","float32"),p=N(e,"filter","conv2d","float32");let d=l,f=!1;l.rank===3&&(f=!0,d=W(l,[1,l.shape[0],l.shape[1],l.shape[2]])),I(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),I(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Pt("fused conv2d",r,a),I(d.shape[3]===p.shape[2],()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${p.shape[2]}.`),I(Tt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const g=St(d.shape,p.shape,t,o,r,a);let y;i!=null&&(y=N(i,"bias","fused conv2d"),[y]=Be(y,l),Se(g.outShape,y.shape));let w;c!=null&&(w=N(c,"prelu weights","fused conv2d"));const $=(C,_)=>{const[k,R,A,P]=_,U=po(C,A,u);I(os(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const H=kd(R.shape,U,k,t,r),G=Lv(R,U,k.shape,t,r),q=[H,G];if(P!=null){const te=fo(P,U);q.push(te)}return q},S={x:d,filter:p,bias:y,preluActivationWeights:w},T={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:h};return i==null?Nn((_,k,R)=>{let A=O.runKernel(pa,S,T);return R([k,_,A]),f&&(A=W(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:$}})(d,p):Nn((_,k,R,A)=>{let P=O.runKernel(pa,S,T);return A([k,_,P,R]),f&&(P=W(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:$}})(d,p,y)}const Mv=F({fusedConv2d_:Bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(n,e,t,r,s,o=[1,1],a){let i=n;n.rank===3&&(i=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:u},h={strides:r,pad:s,dimRoundingMode:a,dilations:o,filterShape:t};return O.runKernel(Vl,c,h)}const Uv=F({depthwiseConv2dNativeBackpropFilter_:Vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e,t,r,s,o=[1,1],a){let i=e,u=!1;e.rank===3&&(u=!0,i=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:t},h={strides:r,pad:s,dimRoundingMode:a,dilations:o,inputShape:n},l=O.runKernel(Ul,c,h);return u?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const zv=F({depthwiseConv2dNativeBackpropInput_:Wv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(go(O.state.gradientDepth,u)===!1){let C=Id(n,e,t,r,s,o,a);return i!=null&&(C=Ie(C,i)),mo(C,u,c,h)}const l=N(n,"x","depthwiseConv2d","float32"),p=N(e,"filter","depthwiseConv2d","float32");let d=l,f=!1;l.rank===3&&(f=!0,d=W(l,[1,l.shape[0],l.shape[1],l.shape[2]])),I(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),I(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),I(d.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),I(Tt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Pt("fused depthwiseConv2d",r,a);const g=St(d.shape,p.shape,t,o,r,a,!0);let y;i!=null&&(y=N(i,"bias","fused conv2d"),[y]=Be(y,l),Se(g.outShape,y.shape));let w;c!=null&&(w=N(c,"prelu weights","fused depthwiseConv2d"));const $=(C,_)=>{I(os(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[k,R,A,P]=_,U=po(C,A,u),H=zv(R.shape,U,k,t,r,o,a),G=Uv(R,U,k.shape,t,r,o,a);if(P!=null){const q=fo(y,U);return[H,G,q]}return[H,G]},S={x:d,filter:p,bias:y,preluActivationWeights:w},T={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:h};return i==null?Nn((_,k,R)=>{let A=O.runKernel(da,S,T);return R([k,_,A]),f&&(A=W(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:$}})(d,p):Nn((_,k,R,A)=>{let P=O.runKernel(da,S,T);return A([k,_,P,R]),f&&(P=W(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:$}})(d,p,y)}const Hv=F({fusedDepthwiseConv2d_:Gv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(go(O.state.gradientDepth,o)===!1){let U=Ke(n,e,t,r);return s!=null&&(U=Ie(U,s)),mo(U,o,a,i)}let u=N(n,"a","fused matMul"),c=N(e,"b","fused matMul");[u,c]=Be(u,c);const h=t?u.shape[u.rank-2]:u.shape[u.rank-1],l=r?c.shape[c.rank-1]:c.shape[c.rank-2],p=t?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],f=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=j(f),w=j(g);I(h===l,()=>`Error in fused matMul: inner shapes (${h}) and (${l}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=Se(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,d]),T=t?W(u,[y,h,p]):W(u,[y,p,h]),C=r?W(c,[w,d,l]):W(c,[w,l,d]);let _;s!=null&&(_=N(s,"bias","fused matMul"),[_]=Be(_,u),Se(S,_.shape));let k;a!=null&&(k=N(a,"prelu weights","fused matMul"));const R=(U,H)=>{const[G,q,te,ne]=H,ue=po(W(U,te.shape),te,o);let ze,Le;if(!t&&!r?(ze=Ke(ue,q,!1,!0),Le=Ke(G,ue,!0,!1)):!t&&r?(ze=Ke(ue,q,!1,!1),Le=Ke(ue,G,!0,!1)):t&&!r?(ze=Ke(q,ue,!1,!0),Le=Ke(G,ue,!1,!1)):(ze=Ke(q,ue,!0,!0),Le=Ke(ue,G,!0,!0)),s!=null){const nt=fo(ne,ue);return[ze,Le,nt]}else return[ze,Le]},A={a:T,b:C,bias:_,preluActivationWeights:k},P={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:i};return s==null?Nn((H,G,q)=>{const te=O.runKernel(ha,A,P);return q([H,G,te]),{value:W(te,S),gradFunc:R}})(T,C):Nn((H,G,q,te)=>{const ne=O.runKernel(ha,A,P);return te([H,G,ne,q]),{value:W(ne,S),gradFunc:R}})(T,C,_)}const Kv=F({fusedMatMul_:jv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xv(n){return af(n,.54,.46)}const s3=F({hammingWindow_:Xv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n){return af(n,.5,.5)}const Yv=F({hannWindow_:qv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n,e,t,r=!1,s=0){let o=0;const a=[];for(;o+e<=n.size;)a.push($e(n,o,e)),o+=t;if(r)for(;o<n.size;){const i=o+e-n.size,u=yt([$e(n,o,e-i),xi([i],s)]);a.push(u),o+=t}return a.length===0?Kt([],[0,e]):W(yt(a),[a.length,e])}const Zv=F({frame_:Qv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jv(n,e,t,r,s=Yv){r==null&&(r=Dv(e));const o=Zv(n,e,t),a=ee(o,s(e));return ef(a,r)}const o3=F({stft_:Jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(n,e,t,r,s="bilinear",o=0){const a=N(n,"image","cropAndResize"),i=N(e,"boxes","cropAndResize","float32"),u=N(t,"boxInd","cropAndResize","int32"),c=i.shape[0];I(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),I(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),I(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),I(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),I(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),I(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const h={image:a,boxes:i,boxInd:u},l={method:s,extrapolationValue:o,cropSize:r};return O.runKernel(Pl,h,l)}const tw=F({cropAndResize_:ew});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n){const e=N(n,"image","flipLeftRight","float32");I(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return O.runKernel(Jl,t,{})}const rw=F({flipLeftRight_:nw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(n){const e=N(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];I(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),I(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,es(e,s)}const ow=F({grayscaleToRGB_:sw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n,e,t=0,r=.5){const s=N(n,"image","rotateWithOffset","float32");I(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},a={radians:e,fillValue:t,center:r};return O.runKernel(Dp,o,a)}const iw=F({rotateWithOffset_:aw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ar(n,e,t,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=n.shape[0];return t=Math.min(t,a),I(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),I(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),I(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),I(e.rank===1,()=>"scores must be a 1D tensor"),I(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),I(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=N(n,"boxes","nonMaxSuppression","float32"),a=N(e,"scores","nonMaxSuppression","float32"),i=Ar(o,a,t,r,s);t=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return O.runKernel(Fh,{boxes:o,scores:a},u)}const cw=F({nonMaxSuppression_:uw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lw(n,e,t){const r=hw(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function hw(n,e,t){return dw(n,e,t||pw)}function pw(n,e){return n>e?1:n<e?-1:0}function dw(n,e,t){let r=0,s=n.length,o=0,a=!1;for(;r<s;){o=r+(s-r>>>1);const i=t(e,n[o]);i>0?r=o+1:(s=o,a=!i)}return a?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uf(n,e,t,r,s){return Ci(n,e,t,r,s,0)}function cf(n,e,t,r,s,o){return Ci(n,e,t,r,s,0,!1,o,!0)}function lf(n,e,t,r,s,o){return Ci(n,e,t,r,s,o,!0)}function Ci(n,e,t,r,s,o,a=!1,i=!1,u=!1){const c=[];for(let y=0;y<e.length;y++)e[y]>s&&c.push({score:e[y],boxIndex:y,suppressBeginIndex:0});c.sort(Du);const h=o>0?-.5/o:0,l=[],p=[];for(;l.length<t&&c.length>0;){const y=c.pop(),{score:w,boxIndex:$,suppressBeginIndex:S}=y;if(w<s)break;let T=!1;for(let C=l.length-1;C>=S;--C){const _=fw(n,$,l[C]);if(_>=r){T=!0;break}if(y.score=y.score*mw(r,h,_),y.score<=s)break}y.suppressBeginIndex=l.length,T||(y.score===w?(l.push($),p.push(y.score)):y.score>s&&lw(c,y,Du))}const d=l.length,f=t-d;i&&f>0&&(l.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const g={selectedIndices:l};return a&&(g.selectedScores=p),u&&(g.validOutputs=d),g}function fw(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),h=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(i-o)*(u-a),f=(l-c)*(p-h);if(d<=0||f<=0)return 0;const g=Math.max(o,c),y=Math.max(a,h),w=Math.min(i,l),$=Math.min(u,p),S=Math.max(w-g,0)*Math.max($-y,0);return S/(d+f-S)}function mw(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function Du(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function gw(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=N(n,"boxes","nonMaxSuppressionAsync"),a=N(e,"scores","nonMaxSuppressionAsync"),i=Ar(o,a,t,r,s);t=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:l}=uf(c,h,t,r,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),et(l,"int32")}const yw=gw;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const a=N(n,"boxes","nonMaxSuppression"),i=N(e,"scores","nonMaxSuppression"),u=Ar(a,i,t,r,s,o);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const c={boxes:a,scores:i},h={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},l=O.runKernel(Ph,c,h);return{selectedIndices:l[0],selectedScores:l[1]}}const bw=F({nonMaxSuppressionWithScore_:xw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vw(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const a=N(n,"boxes","nonMaxSuppressionAsync"),i=N(e,"scores","nonMaxSuppressionAsync"),u=Ar(a,i,t,r,s,o);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const c=await Promise.all([a.data(),i.data()]),h=c[0],l=c[1],{selectedIndices:p,selectedScores:d}=lf(h,l,t,r,s,o);return a!==n&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:et(p,"int32"),selectedScores:et(d)}}const ww=vw;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $w(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const a=N(n,"boxes","nonMaxSuppression"),i=N(e,"scores","nonMaxSuppression"),u=Ar(a,i,t,r,s,null),c=u.maxOutputSize,h=u.iouThreshold,l=u.scoreThreshold,p={boxes:a,scores:i},d={maxOutputSize:c,iouThreshold:h,scoreThreshold:l,padToMaxOutputSize:o},f=O.runKernel(Dh,p,d);return{selectedIndices:f[0],validOutputs:f[1]}}const Sw=F({nonMaxSuppressionPadded_:$w});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Tw(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const a=N(n,"boxes","nonMaxSuppressionAsync"),i=N(e,"scores","nonMaxSuppressionAsync"),u=Ar(a,i,t,r,s,null),c=u.maxOutputSize,h=u.iouThreshold,l=u.scoreThreshold,[p,d]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:g}=cf(p,d,c,h,l,o);return a!==n&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:et(f,"int32"),validOutputs:me(g,"int32")}}const Cw=Tw;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e,t=!1,r=!1){const s=N(n,"images","resizeBilinear");I(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),I(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:o},u={alignCorners:t,halfPixelCenters:r,size:e},c=O.runKernel(Yh,i,u);return a?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Ew=F({resizeBilinear_:Nw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kw(n,e,t=!1,r=!1){const s=N(n,"images","resizeNearestNeighbor");I(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),I(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),I(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:o},u={alignCorners:t,halfPixelCenters:r,size:e},c=O.runKernel(qh,i,u);return a?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Iw=F({resizeNearestNeighbor_:kw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(n,e="binary",t=!1,r=.5){const s=N(n,"image","threshold"),o=.2989,a=.587,i=.114,u=s.shape[0]*s.shape[1];let c=ee(et([r]),255),h,l,p,d;if(I(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),I(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),I(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),I(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[h,l,p]=us(s,[1,1,1],-1);const y=ee(h,o),w=ee(l,a),$=ee(p,i);d=Ie(Ie(y,w),$)}else d=n;if(e==="otsu"){const y=Nd(_e(Zd(d),"int32"),Sn([]),256);c=_w(y,u)}const f=t?vi(d,c):co(d,c);return _e(ee(f,255),"int32")}function _w(n,e){let t=et([-1]),r=et([0]),s=et([0]),o,a,i,u,c,h;for(let l=0;l<n.size-1;l++){o=$e(n,0,l+1),a=$e(n,l+1),c=ke(Fe(o),e),h=ke(Fe(a),e);const p=Fe(ee(o,is(0,o.size)));i=ke(p,Fe(o));const d=xi(a.shape,o.size),f=Ie(is(0,a.size),d),g=ee(a,f);u=ke(Fe(g),Fe(a));const y=fe(i,u),w=fe(i,u),$=ee(c,h);s=ee(ee($,y),w);const S=co(s,r);r=Tr(S,s,r),t=Tr(S,et([l]),t)}return t}const Aw=F({threshold_:Rw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ow(n,e,t="nearest",r="constant",s=0,o){const a=N(n,"image","transform","float32"),i=N(e,"transforms","transform","float32");I(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),I(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:a,transforms:i},c={interpolation:t,fillMode:r,fillValue:s,outputShape:o};return O.runKernel(Ip,u,c)}const Fw=F({transform_:Ow});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(n,e,t){I(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),I(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=N(n,"a","bandPart");I(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,a]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=o),t<0&&(t=a);const i=W(is(0,o,1,"int32"),[-1,1]),u=is(0,a,1,"int32"),c=fe(i,u),h=Pd(vi(c,me(+e,"int32")),Ad(c,me(-t,"int32"))),l=En([o,a],r.dtype);return W(dn(er(W(r,[-1,o,a])).map(p=>Tr(h,p,l))),s)}const a3=F({bandPart_:Dw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n){let e;if(Array.isArray(n)){e=!1,I(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)I(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else e=!0,n=us(n,n.shape[0],0).map(s=>Ne(s,[0]));I(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(O.tidy(()=>{let o=r[s];if(s>0)for(let a=0;a<s;++a){const i=ee(Fe(ee(t[a],o)),t[a]);o=fe(o,i)}return ke(o,sf(o,"euclidean"))}));return e?dn(t,0):t}const i3=F({gramSchmidt_:Pw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(n,e=!1){if(I(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Pu(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,c)=>u*c),r=er(W(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];r.forEach(u=>{const[c,h]=Pu(u,e);s.push(c),o.push(h)});const a=W(dn(s,0),n.shape),i=W(dn(o,0),n.shape);return[a,i]}}function Pu(n,e=!1){return O.tidy(()=>{I(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=$1(t),o=Gn(n);const a=Kt([[1]],[1,1]);let i=Gn(a);const u=t>=r?r:t;for(let c=0;c<u;++c){const h=o,l=i,p=s;[i,o,s]=O.tidy(()=>{const d=$e(o,[c,c],[t-c,1]),f=sf(d),g=$e(o,[c,c],[1,1]),y=Tr(co(g,0),Kt([[-1]]),Kt([[1]])),w=fe(g,ee(y,f)),$=ke(d,w);$.shape[0]===1?i=Gn(a):i=yt([a,$e($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const S=bs(ke(Ke(y,w),f)),T=$e(o,[c,0],[t-c,r]),C=ee(S,i),_=Na(i);if(c===0)o=fe(T,Ke(C,Ke(_,T)));else{const A=fe(T,Ke(C,Ke(_,T)));o=yt([$e(o,[0,0],[c,r]),A],0)}const k=Na(C),R=$e(s,[0,c],[t,s.shape[1]-c]);if(c===0)s=fe(R,Ke(Ke(R,i),k));else{const A=fe(R,Ke(Ke(R,i),k));s=yt([$e(s,[0,0],[t,c]),A],1)}return[i,o,s]}),ot([h,l,p])}return!e&&t>r&&(s=$e(s,[0,0],[t,r]),o=$e(o,[0,0],[r,r])),[s,o]})}const u3=F({qr_:Lw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var dt;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(dt||(dt={}));function Bw(n,e,t=dt.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=N(e,"weights","computeWeightedLoss"));const o=s==null?r:ee(r,s);if(t===dt.NONE)return o;if(t===dt.SUM)return Fe(o);if(t===dt.MEAN){if(s==null)return Ld(o);{const a=r.size/s.size,i=ke(Fe(o),Fe(s));return a>1?ke(i,me(a)):i}}if(t===dt.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ke(Fe(o),me(r.size));{const a=ee(s,Si(r.shape)),i=_e(Fe(Md(a,me(0))),"float32");return ke(Fe(o),i)}}throw Error(`Unknown reduction: ${t}`)}const In=F({computeWeightedLoss_:Bw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mw(n,e,t,r=dt.SUM_BY_NONZERO_WEIGHTS){const s=N(n,"labels","absoluteDifference"),o=N(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=N(t,"weights","absoluteDifference")),Yt(s.shape,o.shape,"Error in absoluteDifference: ");const i=kt(fe(s,o));return In(i,a,r)}const c3=F({absoluteDifference_:Mw});function Vw(n,e,t,r,s=dt.SUM_BY_NONZERO_WEIGHTS){const o=N(n,"labels","cosineDistance"),a=N(e,"predictions","cosineDistance");let i=null;r!=null&&(i=N(r,"weights","cosineDistance")),Yt(o.shape,a.shape,"Error in cosineDistance: ");const u=me(1),c=fe(u,Fe(ee(o,a),t,!0));return In(c,i,s)}const l3=F({cosineDistance_:Vw});function Uw(n,e,t,r=dt.SUM_BY_NONZERO_WEIGHTS){let s=N(n,"labels","hingeLoss");const o=N(e,"predictions","hingeLoss");let a=null;t!=null&&(a=N(t,"weights","hingeLoss")),Yt(s.shape,o.shape,"Error in hingeLoss: ");const i=me(1);s=fe(ee(me(2),s),i);const u=ho(fe(i,ee(s,o)));return In(u,a,r)}const h3=F({hingeLoss_:Uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(n,e,t,r=1,s=dt.SUM_BY_NONZERO_WEIGHTS){const o=N(n,"labels","huberLoss"),a=N(e,"predictions","huberLoss");let i=null;t!=null&&(i=N(t,"weights","huberLoss")),Yt(o.shape,a.shape,"Error in huberLoss: ");const u=me(r),c=kt(fe(a,o)),h=Ti(c,u),l=fe(c,h),p=Ie(ee(me(.5),lo(h)),ee(u,l));return In(p,i,s)}const p3=F({huberLoss_:Ww});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n,e,t,r=1e-7,s=dt.SUM_BY_NONZERO_WEIGHTS){const o=N(n,"labels","logLoss"),a=N(e,"predictions","logLoss");let i=null;t!=null&&(i=N(t,"weights","logLoss")),Yt(o.shape,a.shape,"Error in logLoss: ");const u=me(1),c=me(r),h=bs(ee(o,as(Ie(a,c)))),l=ee(fe(u,o),as(Ie(fe(u,a),c))),p=fe(h,l);return In(p,i,s)}const d3=F({logLoss_:zw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gw(n,e,t,r=dt.SUM_BY_NONZERO_WEIGHTS){const s=N(n,"labels","meanSquaredError"),o=N(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=N(t,"weights","meanSquaredError")),Yt(s.shape,o.shape,"Error in meanSquaredError: ");const i=tf(s,o);return In(i,a,r)}const f3=F({meanSquaredError_:Gw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e){const t=N(n,"labels","sigmoidCrossEntropyWithLogits"),r=N(e,"logits","sigmoidCrossEntropyWithLogits");Yt(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=ho(r),o=ee(r,t),a=Fd(pn(bs(kt(r))));return Ie(fe(s,o),a)}function jw(n,e,t,r=0,s=dt.SUM_BY_NONZERO_WEIGHTS){let o=N(n,"multiClassLabels","sigmoidCrossEntropy");const a=N(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=N(t,"weights","sigmoidCrossEntropy")),Yt(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=me(r),h=me(1),l=me(.5);o=Ie(ee(o,fe(h,c)),ee(l,c))}const u=Hw(o,a);return In(u,i,s)}const m3=F({sigmoidCrossEntropy_:jw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Nn((s,o,a)=>{const u=q1(o,[t],!0),c=fe(_e(o,"float32"),u);a([s,c]);const h=bs(ee(c,s));return{value:Fe(h,[t]),gradFunc:(d,f)=>{const[g,y]=f,w=Lt(d.shape,[t]);return[ee(W(d,w),fe(_e(g,"float32"),pn(y))),ee(W(d,w),fe(pn(y),_e(g,"float32")))]}}})(n,e)}function Xw(n,e,t,r=0,s=dt.SUM_BY_NONZERO_WEIGHTS){let o=N(n,"onehotLabels","softmaxCrossEntropy");const a=N(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=N(t,"weights","softmaxCrossEntropy")),Yt(o.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const c=me(r),h=me(1),l=me(o.shape[1]);o=Ie(ee(o,fe(h,c)),ke(c,l))}const u=Kw(o,a);return In(u,i,s)}const g3=F({softmaxCrossEntropy_:Xw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(n,e,t,r){const s=N(n,"indices","sparseFillEmptyRows","int32"),o=N(e,"values","sparseFillEmptyRows"),a=N(t,"denseShape","sparseFillEmptyRows","int32"),i=N(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:s,values:o,denseShape:a,defaultValue:i},c=O.runKernel(mp,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const Yw=F({sparseFillEmptyRows_:qw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n,e,t){const r=N(n,"inputIndices","sparseReshape","int32"),s=N(e,"inputShape","sparseReshape","int32"),o=N(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:r,inputShape:s,newShape:o},i=O.runKernel(gp,a);return{outputIndices:i[0],outputShape:i[1]}}const Zw=F({sparseReshape_:Qw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(n,e,t){const r=N(n,"data","sparseSegmentMean"),s=N(e,"indices","sparseSegmentMean","int32"),o=N(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:r,indices:s,segmentIds:o};return O.runKernel(yp,a)}const e2=F({sparseSegmentMean_:Jw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2(n,e,t){const r=N(n,"data","sparseSegmentSum"),s=N(e,"indices","sparseSegmentSum","int32"),o=N(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:r,indices:s,segmentIds:o};return O.runKernel(xp,a)}const n2=F({sparseSegmentSum_:t2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n,e,t,r,s,o,a,i){const u=N(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=N(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:a,preserveShortSequences:i},l={data:u,dataSplits:c},p=O.runKernel($p,l,h);return{nGrams:p[0],nGramsSplits:p[1]}}const s2=F({stringNGrams_:r2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2(n,e,t=!0){const r=N(n,"input","stringSplit","string"),s=N(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},a={input:r,delimiter:s},i=O.runKernel(Sp,a,o);return{indices:i[0],values:i[1],shape:i[2]}}const a2=F({stringSplit_:o2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n,e){const t=N(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return O.runKernel(Tp,s,r)}const u2=F({stringToHashBucketFast_:i2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $t={flipLeftRight:rw,grayscaleToRGB:ow,resizeNearestNeighbor:Iw,resizeBilinear:Ew,rotateWithOffset:iw,cropAndResize:tw,nonMaxSuppression:cw,nonMaxSuppressionAsync:yw,nonMaxSuppressionWithScore:bw,nonMaxSuppressionWithScoreAsync:ww,nonMaxSuppressionPadded:Sw,nonMaxSuppressionPaddedAsync:Cw,threshold:Aw,transform:Fw},Os={sparseFillEmptyRows:Yw,sparseReshape:Zw,sparseSegmentMean:e2,sparseSegmentSum:n2},Vo={stringNGrams:s2,stringSplit:a2,stringToHashBucketFast:u2};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hf(n,e){const t=n[0].length;n.forEach((s,o)=>{I(s.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),I(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,o)=>{for(let a=0;a<t;a++)I(a===e||s[a]===r[a],()=>`Error in concat${t}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Qn(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ni=30;function yo(n){return n<=Ni?n:ia(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=e.length;for(let a=0;a<o;++a)s=s.concat([n[a+1]/e[a],e[a]]);s=s.concat(n.slice(o+1))}return s}function ki(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?o.push(a):s.push(a);r.push(...s),r.push(0),r.push(...o)}return r}function Ii(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?r?s.push(e[o-1]*n[o]):s.push(n[o]/e[o-1]):s.push(n[o]);return s}function df(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function ff(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mf=1.7580993408473768,gf=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yf=.3275911,xf=.254829592,bf=-.284496736,vf=1.421413741,wf=-1.453152027,$f=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aa(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function c2(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function l2(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function h2(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function p2(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function d2(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function f2(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:t,imag:r}}function m2(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uo="->",g2=/->/g,Lu=",",Bu="...";function Sf(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(g2,"").length)/Uo.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Uo}").`);const[r,s]=n.split(Uo);I(r.indexOf(Bu)===-1,()=>`The ellipsis notation ("${Bu}") is not supported yet.`);const o=r.split(Lu),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<s.length;++p){const d=s[p];if(!o.some(f=>f.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);i.indexOf(d)===-1&&i.push(d)}for(let p=0;p<r.length;++p){const d=r[p];i.indexOf(d)===-1&&d!==Lu&&i.push(d)}const u=new Array(o.length);for(let p=0;p<a;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let d=0;d<o[p].length;++d)u[p].push(i.indexOf(o[p][d]))}const c=i.length,h=s.length,l=[];for(let p=h;p<c;++p)l.push(p);return{allDims:i,summedDims:l,idDims:u}}function Tf(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function Cf(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const o=t[s].shape;for(let a=0;a<e[s].length;++a)r[e[s][a]]===void 0?r[e[s][a]]=o[a]:I(r[e[s][a]]===o[a],()=>`Expected dimension ${r[e[s][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function Nf(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let a=0;a<s;++a)r.push([]);const o=[];for(let a=0;a<t.length;++a){const i=t[a],u=y2(e,i);for(const c of u)o.indexOf(c)===-1&&(r[a].push(c),o.push(c))}return{path:t,steps:r}}function Ef(n){return n.every((e,t)=>e===t)}function y2(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function kf(n,e,t=0){let r=[];if(typeof e=="number")I(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);I(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((i,u)=>u>0?i+u:i);e[o]=n.shape[t]-a}I(n.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function If(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Rf(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function _f(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Af(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Of(n,e){return`size ${n} must be non-negative, not ${e}`}function Ff(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Df(n,e){const t=j(n),r=j(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function Pf(n,e){const t=j(n),r=j(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(){return"segment ids must be >= 0"}function Lf(){return"segment ids are not increasing"}function Bf(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Mf(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(n,e){let t=!1,r;for(n<=Ni?(r=n,t=!0):r=ia(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=ia(n,r+1);return r}function Uf(n,e,t){const r=[],s=n.length;for(let o=0;o<s;o++)o!==e?r.push(n[o]):r.push(t);return r}function Wf(n,e,t,r){const s=e.shape.length,o=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let l=0;l<r;++l)if(n.shape[l]!==e.shape[l])throw new Error(`x.shape[${l}]: ${n.shape[l]} should be equal to indices.shape[${l}]: ${e.shape[l]}.`);const a=n.shape[t],i=[];let u=1,c=1,h=1;for(let l=0;l<r;++l)i.push(n.shape[l]),u*=n.shape[l];for(let l=r;l<t;l++)i.push(n.shape[l]),c*=n.shape[l];for(let l=r;l<s;l++)i.push(e.shape[l]);for(let l=t+1;l<o;l++)i.push(n.shape[l]),h*=n.shape[l];return{batchSize:u,sliceSize:h,outerSize:c,dimSize:a,outputShape:i}}var x2=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:Vf,computeOutShape:Uf,collectGatherOpShapeInfo:Wf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cs(n){try{return n.map(e=>rs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function zf(n){return n.map(e=>zn(e))}var b2=Object.freeze(Object.defineProperty({__proto__:null,slice_util:Lx,segment_util:x2,fromUint8ToStringArray:cs,fromStringArrayToUint8:zf,upcastType:rn,axesAreInnerMostDims:wi,combineLocations:Dd,computeOutAndReduceShapes:on,expandShapeToKeepDim:Lt,assertAxesAreInnerMostDims:Zt,getAxesPermutation:Bt,getUndoAxesPermutation:$i,getInnerMostAxes:Mt,getBroadcastDims:Ks,getReductionAxes:ad,assertAndGetBroadcastShape:Se,assertParamsConsistent:hf,computeOutShape:Qn,computeDilation2DInfo:Cd,computePool2DInfo:Rr,computePool3DInfo:gs,computeConv2DInfo:St,computeConv3DInfo:ys,computeDefaultPad:mi,tupleValuesAreOne:os,eitherStridesOrDilationsAreOne:Tt,convertConv2DDataFormat:_r,checkPadOnDimRoundingMode:Pt,getFusedDyActivation:po,getFusedBiasGradient:fo,applyActivation:mo,shouldFuse:go,PARALLELIZE_THRESHOLD:Ni,computeOptimalWindowSize:yo,getImageCenter:pf,getReshaped:Ei,getPermuted:ki,getReshapedPermuted:Ii,getSliceBeginCoords:df,getSliceSize:ff,prepareAndValidate:ud,validateUpdateShape:cd,validateInput:ld,calculateShapes:pi,SELU_SCALEALPHA:mf,SELU_SCALE:gf,ERF_P:yf,ERF_A1:xf,ERF_A2:bf,ERF_A3:vf,ERF_A4:wf,ERF_A5:$f,warn:jt,log:fy,mergeRealAndImagArrays:Aa,splitRealAndImagArrays:c2,complexWithEvenIndex:l2,complexWithOddIndex:h2,getComplexWithIndex:p2,assignToTypedArray:d2,exponents:f2,exponent:m2,decodeEinsumEquation:Sf,getEinsumPermutation:Tf,checkEinsumDimSizes:Cf,getEinsumComputePath:Nf,isIdentityPermutation:Ef,prepareSplitSize:kf,getSparseFillEmptyRowsIndicesDenseShapeMismatch:If,getSparseFillEmptyRowsNegativeIndexErrorMessage:Rf,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:_f,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Af,getSparseReshapeNegativeOutputDimErrorMessage:Of,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ff,getSparseReshapeInputOutputMultipleErrorMessage:Df,getSparseReshapeInputOutputMismatchErrorMessage:Pf,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Oa,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Lf,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Bf,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Mf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bn={},Wo={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function v2(n,e){Bn[n]=e}function qt(n,e){if(!(n in Bn)||e!=null){const r=$2(n,e);if(r!==null)Bn[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Bn[n];return t==null||t.isContextLost()?(delete Bn[n],qt(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Bn[n])}function w2(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function $2(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?w2(n):e;return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Bn[n]},!1),n===1?t.getContext("webgl",Wo)||t.getContext("experimental-webgl",Wo):t.getContext("webgl2",Wo)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ls;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ls||(ls={}));var wt;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(wt||(wt={}));var Ye;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ye||(Ye={}));function vs(n,e){return[e,n]}function S2(n,e){return n*e}function Fs(n){const e=j(n),t=Math.ceil(e/4);return oa(t)}function Or(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function T2(n,e){const[t,r]=Or(n,e);return t*r*4}function Ri(n,e){const t=n;let r,s,o,a,i,u,c,h,l,p;return B().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,o=t.RGBA16F,a=t.RGBA32F,i=t.RED,c=4,h=1,l=t.HALF_FLOAT,p=t.FLOAT,u=t.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,a=t.RGBA,i=n.RGBA,c=4,h=4,l=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,u=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:l,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q(n,e){const t=e();return B().getBool("DEBUG")&&C2(n),t}function C2(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+I2(n,e))}const N2=596e-10,E2=65504;function k2(n){return!!(B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||N2<Math.abs(n)&&Math.abs(n)<E2)}function I2(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Ds(n,e){return fn(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function R2(n,e){const t=fn(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Q(n,()=>n.shaderSource(t,e)),Q(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function _2(n,e){const t=fn(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Q(n,()=>n.shaderSource(t,e)),Q(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw O2(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const A2=/ERROR: [0-9]+:([0-9]+):/g;function O2(n,e){const t=A2.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),o=s.length.toString().length+2,a=s.map((l,p)=>xr((p+1).toString(),o)+l);let i=0;for(let l=0;l<a.length;l++)i=Math.max(a[l].length,i);const u=a.slice(0,r-1),c=a.slice(r-1,r),h=a.slice(r);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${xr(c[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function F2(n){return fn(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function D2(n,e){if(Q(n,()=>n.linkProgram(e)),n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function zo(n,e){if(Q(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function P2(n,e){const t=fn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Q(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function L2(n,e){const t=fn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Q(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Q(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function B2(n){return fn(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function M2(n,e){const t=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function V2(n){return fn(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Mu(n,e,t,r,s,o,a){const i=n.getAttribLocation(e,t);return i===-1?!1:(Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Q(n,()=>n.vertexAttribPointer(i,s,n.FLOAT,!1,o,a)),Q(n,()=>n.enableVertexAttribArray(i)),!0)}function U2(n,e,t){j2(n,t),Q(n,()=>n.activeTexture(n.TEXTURE0+t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function W2(n,e,t){return fn(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function z2(n,e,t){return n.getUniformLocation(e,t)}function G2(n,e,t,r){Q(n,()=>U2(n,e,r)),Q(n,()=>n.uniform1i(t,r))}function Go(n,e,t){Q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Vu(n,e){Q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ps(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+H2(n,e))}function H2(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function fn(n,e,t){const r=Q(n,()=>e());if(r==null)throw new Error(t);return r}function j2(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Cr(n,e=2){return j(n.slice(0,n.length-e))}function Nr(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Ho(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Cr(n),...Nr(n)]),e}function K2(n,e=!1){let t=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,n=n.map((s,o)=>o>=n.length-2?Zc(n[o]):n[o]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=kn(n).newShape);let r=j(n);if(n.length<=1&&r<=t)return[1,r];if(n.length===2&&n[0]<=t&&n[1]<=t)return n;if(n.length===3&&n[0]*n[1]<=t&&n[2]<=t)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=t&&n[1]*n[2]<=t)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t)return[n[0],n[1]*n[2]*n[3]];if(e){const s=Cr(n);let o=2,a=2;return n.length&&([o,a]=Nr(n)),r=s*(o/2)*(a/2),oa(r).map(i=>i*2)}return oa(r)}function Ls(n){return n%2===0}function Js(n,e){if(n=n.slice(-2),e=e.slice(-2),We(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],r=e.slice(-1)[0];if(t===r||Ls(t)&&Ls(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Ls(n[0])&&Ls(e[0])}let jo,Ko;function X2(n){if(jo==null){const e=qt(n);jo=e.getParameter(e.MAX_TEXTURE_SIZE)}return jo}function q2(n){if(Ko==null){const e=qt(n);Ko=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ko)}function Y2(n){if(n===0)return 0;let e;const t=qt(n);return Dt(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Dt(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Dt(n,e){return n.getExtension(e)!=null}function Uu(n){try{if(qt(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Q2(n){if(n===0)return!1;const e=qt(n);if(n===1){if(!Dt(e,"OES_texture_float"))return!1}else if(!Dt(e,"EXT_color_buffer_float"))return!1;return Fa(e)}function Z2(n){if(n===0)return!1;const e=qt(n);if(n===1){if(!Dt(e,"OES_texture_float")||!Dt(e,"WEBGL_color_buffer_float"))return!1}else{if(Dt(e,"EXT_color_buffer_float"))return Fa(e);const r="EXT_color_buffer_half_float";if(Dt(e,r)){const s=e.getExtension(r);return J2(e,s)}return!1}return Fa(e)}function Fa(n){const e=Ri(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),a}function J2(n,e){const t=Ri(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,o=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,o,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(a),i}function e$(n){return n!==2?!1:qt(n).fenceSync!=null}function ws(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&I(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J=B();J.registerFlag("HAS_WEBGL",()=>J.getNumber("WEBGL_VERSION")>0);J.registerFlag("WEBGL_VERSION",()=>Uu(2)?2:Uu(1)?1:0);J.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);J.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>J.get("WEBGL_VERSION")===2);J.registerFlag("WEBGL_CPU_FORWARD",()=>!0);J.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);J.registerFlag("WEBGL_PACK",()=>J.getBool("HAS_WEBGL"));J.registerFlag("WEBGL_PACK_NORMALIZATION",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_CLIP",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_REDUCE",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_LAZILY_UNPACK",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_CONV_IM2COL",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>X2(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>q2(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=J.getNumber("WEBGL_VERSION");return n===0?0:Y2(n)});J.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>J.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Kp());J.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Q2(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>J.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:J.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));J.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Z2(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_FENCE_API_ENABLED",()=>e$(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>J.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);J.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});J.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Kp()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});J.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);J.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);J.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);J.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lt(){let n,e,t,r,s,o,a,i,u,c;return B().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",o="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:u,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(n,e,t="index"){const r=tt(e);return r.map((s,o)=>{const a=`int ${n[o]} = ${t} / ${s}`,i=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`;return`${a}; ${i};`}).join("")}function xo(n,e,t="index"){const r=tt(e);return r.map((s,o)=>{const a=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,i=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function t$(n,e){const t=n.length,r=n.map(o=>`${e}[${o}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let o=t-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function n$(n,e,t="index"){const r=n.map((o,a)=>a),s=t$(r,e);return s.map((o,a)=>{const i=`int ${n[a]} = ${t} / ${s[a]}`,u=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${s[a]}`:`index -= ${n[a]} * ${s[a]}`;return`${i}; ${u};`}).join("")}function _i(n){const e=tt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Ai(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Gf=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:Hf}=b2;function r$(n,e,t){const r=[];if(n.forEach(d=>{const f=j(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:g}=Oi(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),o=n.map(d=>s$(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=lt(),u=i$(i);let c,h,l=l$(i);return e.isPacked?(c=o$(e.logicalShape,a,t.enableShapeUniforms),h=c$(i)):(c=a$(e.logicalShape,a,t.enableShapeUniforms),h=u$(i)),t.packedInputs&&(l+=f$),[l,u,h,s,c,o,t.userCode].join(`
`)}function Fr(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return N$(n,e);case 1:return k$(n,e);case 2:return R$(n,e);case 3:return A$(n,e);case 4:return F$(n,e);case 5:return D$(n);case 6:return P$(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function jf(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return C$(n);case 1:return E$(n,e);case 2:return I$(n,e);case 3:return _$(n,e);default:return O$(n,e)}}function s$(n,e,t=!1,r){let s="";t?s+=jf(n,r):s+=Fr(n,r);const o=n.shapeInfo.logicalShape,a=e.logicalShape;return o.length<=a.length&&(t?s+=L$(n,e):s+=B$(n,e)),s}function o$(n,e,t){switch(n.length){case 0:return Kf();case 1:return m$(n,e,t);case 2:return S$(n,e,t);case 3:return y$(n,e,t);default:return b$(n,e,t)}}function a$(n,e,t){switch(n.length){case 0:return Kf();case 1:return g$(n,e,t);case 2:return T$(n,e,t);case 3:return x$(n,e,t);case 4:return v$(n,e,t);case 5:return w$(n,e);case 6:return $$(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function i$(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function u$(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function c$(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function l$(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${h$}
    ${p$}
    ${d$}
  `}const h$=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,p$=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,d$=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,f$=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Kf(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function m$(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function g$(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function y$(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function x$(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${xo(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=tr(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function b$(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let a=o,i="",u="b, r, c";for(let c=2;c<n.length-1;c++)a*=n[n.length-c-1],i=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+i,u=`b${c}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${u});
    }
  `}function v$(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${xo(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=tr(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function w$(n,e){const t=tr(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function $$(n,e){const t=tr(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function S$(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(We(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function T$(n,e,t){return We(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function nr(n){return`offset${n}`}function C$(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=lt();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function N$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,o]=n.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=nr(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[i,u]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function E$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,o=lt();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function k$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Dr(n)}
      }
    `;const s=n.shapeInfo.texShape,o=s[0],a=s[1];if(a===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=nr(t);return a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function I$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,a=o[0],i=o[1],u=lt();if(o!=null&&We(t,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],h=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function R$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(o!=null&&We(t,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=o[0],d=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:a,keptDims:i}=kn(t),u=a;if(u.length<t.length){const p=Pr(n,u),d=["row","col"];return`
      ${Fr(p,e)}
      float ${s}(int row, int col) {
        return ${s}(${Lr(d,i)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Dr(n)}
      }
    `;const c=o[0],h=o[1],l=nr(r);return h===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${l};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${l};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${r}, uv);
  }
`}function _$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const p=t.slice(1),d=[1,2],f=Pr(n,p),g=["b","row","col"];return`
        ${jf(f,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Lr(g,d)});
        }
      `}const i=lt();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;const u=a[0],c=a[1],h=Math.ceil(t[2]/2),l=h*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${l}, ${h}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function A$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[1]*t[2],a=t[2],{newShape:i,keptDims:u}=kn(t),c=i;if(c.length<t.length){const g=Pr(n,c),y=["row","col","depth"];return`
        ${Fr(g,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Lr(y,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${Dr(n)}
      }
    `;const h=n.shapeInfo.texShape,l=h[0],p=h[1],d=n.shapeInfo.flatOffset;if(p===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${l}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===a&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=nr(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * ${o} + col * ${a} + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${l}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function O$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=lt();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,a=o.length,i=n.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=u[0],h=u[1],l=Math.ceil(o[a-1]/2);let p=l*Math.ceil(o[a-2]/2),d="int b, int row, int col",f=`b * ${p} + (row / 2) * ${l} + (col / 2)`;for(let g=2;g<a-1;g++)d=`int b${g}, `+d,p*=o[a-g-1],f=`b${g} * ${p} + `+f;return`
    vec4 ${r}(${d}) {
      int index = ${f};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${s.texture2D}(${t}, uv);
    }
  `}function F$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[3],a=t[2]*o,i=t[1]*a,{newShape:u,keptDims:c}=kn(t);if(u.length<t.length){const $=Pr(n,u),S=["row","col","depth","depth2"];return`
      ${Fr($,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Lr(S,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${Dr(n)}
      }
    `;const h=n.shapeInfo.flatOffset,l=n.shapeInfo.texShape,p=l[0],d=l[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(d===i&&h==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===o&&h==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const w=nr(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${w});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${d}, index + ${w});
      return sampleTexture(${r}, uv);
    }
  `}function D$(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],o=e[3]*s,a=e[2]*o,i=e[1]*a,{newShape:u,keptDims:c}=kn(e);if(u.length<e.length){const g=Pr(n,u),y=["row","col","depth","depth2","depth3"];return`
      ${Fr(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Lr(y,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${s})) +
          depth3;
        ${Dr(n)}
      }
    `;const h=n.shapeInfo.flatOffset,l=n.shapeInfo.texShape,p=l[0],d=l[1];if(d===i&&h==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===s&&h==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=nr(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function P$(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:o}=kn(e);if(s.length<e.length){const y=Pr(n,s),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${Fr(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Lr(w,o)});
      }
    `}const a=e[5],i=e[4]*a,u=e[3]*i,c=e[2]*u,h=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Dr(n)}
      }
    `;const l=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],f=p[1];if(f===h&&l==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===a&&l==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=nr(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${u} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Dr(n){const e=n.name,t=j(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function L$(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=Hf(n.shapeInfo.logicalShape,e.logicalShape),u=Ae(a),c=a-o;let h;const l=["x","y","z","w","u","v"];o===0?h="":a<2&&i.length>=1?h="coords = 0;":h=i.map($=>`coords.${l[$+c]} = 0;`).join(`
`);let p="";a<2&&o>0?p="coords":p=n.shapeInfo.logicalShape.map(($,S)=>`coords.${l[S+c]}`).join(", ");let d="return outputValue;";const g=j(n.shapeInfo.logicalShape)===1,w=j(e.logicalShape)===1;if(o===1&&!g&&!w)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!w)a===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(i.length){const $=o-2,S=o-1;i.indexOf($)>-1&&i.indexOf(S)>-1?d="return vec4(outputValue.x);":i.indexOf($)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(S)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${r}(${p});
      ${d}
    }
  `}function B$(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,a=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&i===u&&n.shapeInfo.flatOffset==null&&We(a,o))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Ae(u),h=Hf(n.shapeInfo.logicalShape,e.logicalShape),l=u-i;let p;const d=["x","y","z","w","u","v"];i===0?p="":u<2&&h.length>=1?p="coords = 0;":p=h.map(g=>`coords.${d[g+l]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((g,y)=>`coords.${d[y+l]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${r}(${f});
    }
  `}function Ae(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Oi(n,e,t){const{newShape:r,keptDims:s}=kn(e),o=e.length,a=n&&o===3&&e[0]===1,i=a?e.slice(1):r,u=!n&&o>1&&!We(e,t)&&r.length<o||a;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:s}}function Pr(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Lr(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(n,e,t,r){const s=t.map((T,C)=>{const _={logicalShape:T.shape,texShape:T.isUniform?null:T.texData.texShape,isUniform:T.isUniform,isPacked:T.isUniform?!1:T.texData.isPacked,flatOffset:null};return T.texData!=null&&T.texData.slice!=null&&T.texData.slice.flatOffset>0&&(_.flatOffset=T.texData.slice.flatOffset),{name:e.variableNames[C],shapeInfo:_}}),o=s.map(T=>T.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=r$(s,a,e),u=_2(n.gl,i),c=n.createProgram(u);let h=null;const l=n.getUniformLocation(c,"NAN",!1);B().getNumber("WEBGL_VERSION")===1&&(h=n.getUniformLocation(c,"INFINITY",!1));const p=!1,d={},f={},g={};for(let T=0;T<e.variableNames.length;T++){const C=e.variableNames[T];d[C]=n.getUniformLocation(c,C,p),d[`offset${C}`]=n.getUniformLocation(c,`offset${C}`,p),e.enableShapeUniforms&&(f[`${C}Shape`]=n.getUniformLocation(c,`${C}Shape`,p),g[`${C}TexShape`]=n.getUniformLocation(c,`${C}TexShape`,p))}let y,w,$;e.enableShapeUniforms&&(y=n.getUniformLocation(c,"outShape",p),$=n.getUniformLocation(c,"outShapeStrides",p),w=n.getUniformLocation(c,"outTexShape",p));const S=[];return e.customUniforms&&e.customUniforms.forEach((T,C)=>{S[C]=n.getUniformLocation(c,T.name,p)}),{program:e,fragmentShader:u,source:i,webGLProgram:c,uniformLocations:d,customUniformLocations:S,inShapeInfos:o,outShapeInfo:a,infLoc:h,nanLoc:l,inShapesLocations:f,inTexShapesLocations:g,outShapeLocation:y,outShapeStridesLocation:$,outTexShapeLocation:w}}function Wu(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,o=e[r],a=o.shape;if(!We(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(t.isUniform&&o.isUniform)return;const i=t.texShape,u=o.isUniform?null:o.texData.texShape;if(!We(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function V$(n,e,t,r,s){e.program.enableShapeUniforms||(Wu(e.inShapeInfos,t),Wu([e.outShapeInfo],[r]));const o=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,a[0],a[1]):n.setOutputMatrixTexture(o.texture,a[0],a[1]),n.setProgram(e.webGLProgram),B().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,c)=>{const h=e.program.variableNames[c],l=e.uniformLocations[h],p=e.uniformLocations[`offset${h}`],d=e.inShapesLocations[`${h}Shape`],f=e.inTexShapesLocations[`${h}TexShape`];if(d){const{uniformShape:g}=Oi(e.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(d,new Int32Array(g));break;case 2:n.gl.uniform2iv(d,new Int32Array(g));break;case 3:n.gl.uniform3iv(d,new Int32Array(g));break;case 4:n.gl.uniform4iv(d,new Int32Array(g));break}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),l!=null){if(u.isUniform){if(j(u.shape)<2)n.gl.uniform1f(l,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(l,g)}return}u.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,l,c)}});const i=e.outShapeLocation;if(i)switch(r.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const u=tt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach((u,c)=>{const h=e.customUniformLocations[c],l=s[c];if(u.type==="float")n.gl.uniform1fv(h,l);else if(u.type==="vec2")n.gl.uniform2fv(h,l);else if(u.type==="vec3")n.gl.uniform3fv(h,l);else if(u.type==="vec4")n.gl.uniform4fv(h,l);else if(u.type==="int")n.gl.uniform1iv(h,l);else if(u.type==="ivec2")n.gl.uniform2iv(h,l);else if(u.type==="ivec3")n.gl.uniform3iv(h,l);else if(u.type==="ivec4")n.gl.uniform4iv(h,l);else throw Error(`uniform type ${u.type} is not supported yet.`)}),n.executeProgram()}function U$(n,e,t){let r="";e.concat(t).forEach(a=>{const i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const u=a.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:l}=Oi(n.packedInputs,a.shape,u);let p="",d="",f="";if(h.length===1&&n.packedInputs){const C=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];p=`${C[0]>1}_${C[1]>1}`}else if(h.length===2&&!n.packedInputs)d=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const C=tt(h);f=`${C[0]===u[1]}_${C[C.length-1]===u[1]}`}const g=a.shape.length,y=h.length===2&&We(a.shape,u),w=j(a.shape)===1,$=Ks(a.shape,t.shape),S=!n.packedInputs&&g===t.shape.length&&We(u,t.texData.texShape),T=n.packedInputs||h.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${g}_${S}_${c?l:""}_${h.length}_${w}_${$}_${y}_${p}_${d}_${f}_${T}_${i}`}else{const u=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${u}_${i}`}});const s=n.userCode;let o=n.constructor.name;return o+="_"+r+"_"+s+`${B().getNumber("WEBGL_VERSION")}`,o}function ft(n){return B().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W${constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ls.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=lt();this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?xo(["r","c","d"],e):tr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ls.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=lt();this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?xo(["r","c","d"],e):tr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G${constructor(e){this.variableNames=["A"],this.outTexUsage=wt.DOWNLOAD;const t=lt();this.outputShape=e,this.userCode=`
      ${Gf}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=wt.DOWNLOAD;const t=lt();this.outputShape=e,this.userCode=`
      ${Gf}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j${constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=lt();this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Ai():_i(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K${constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=lt();this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length);let s="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const u=a*2+i;s+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Ai():_i(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n){const e=lt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return R2(n,t)}function q$(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return P2(n,e)}function Y$(n){const e=new Uint16Array([0,1,2,2,1,3]);return L2(n,e)}function $s(n,e,t,r,s,o){M2(e,t);const a=B2(n),i=n.TEXTURE_2D;return Q(n,()=>n.bindTexture(i,a)),Q(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Q(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Q(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),Q(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),B().getNumber("WEBGL_VERSION")===1?Q(n,()=>n.texImage2D(i,0,r,e,t,0,s,o,null)):Q(n,()=>n.texStorage2D(i,1,r,e,t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function Xf(n){return n.internalFormatFloat}function Q$(n,e,t,r){const[s,o]=vs(e,t);return $s(n,s,o,Xf(r),r.textureFormatFloat,n.FLOAT)}function qf(n){return n.internalFormatHalfFloat}function Z$(n,e,t,r){const[s,o]=vs(e,t);return $s(n,s,o,qf(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Yf(n){return n.downloadTextureFormat}function J$(n,e,t,r){const[s,o]=vs(e,t);return $s(n,s,o,Yf(r),n.RGBA,n.UNSIGNED_BYTE)}function Qf(n){return n.internalFormatPackedFloat}function eS(n,e,t,r){const[s,o]=Or(e,t);return $s(n,s,o,Qf(r),n.RGBA,n.FLOAT)}function Zf(n){return n.internalFormatPackedHalfFloat}function tS(n,e,t,r){const[s,o]=Or(e,t);return $s(n,s,o,Zf(r),n.RGBA,r.textureTypeHalfFloat)}function nS(n,e,t){return Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Mu(n,e,"clipSpacePos",t,3,20,0)&&Mu(n,e,"uv",t,2,20,12)}function rS(n,e,t,r,s,o){Q(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,i,u;s instanceof Uint8Array?(a=new Uint8Array(t*r*4),i=n.UNSIGNED_BYTE,u=n.RGBA):(a=new Float32Array(t*r*4),i=n.FLOAT,u=o.internalFormatPackedFloat),a.set(s),B().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,i,a)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,r,0,n.RGBA,i,a)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function sS(n,e,t){Q(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?B().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):B().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function oS(n,e,t,r){const s=n.createBuffer();Q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const i=4*4*e*t;return Q(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),Q(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function aS(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function iS(n,e,t,r){const[s,o]=vs(e,t),a=4,i=new Uint8Array(S2(e*t,a));return Q(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function uS(n,e,t,r,s,o,a,i){const u=n,c=new Float32Array(T2(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function cS(n,e,t){const r=new Float32Array(e*t*4);return Q(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xo{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=B().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,v2(t,e)):this.gl=qt(t);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(B().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Ds(this.gl,o),Dt(this.gl,a))this.textureHalfFloatExtension=Ds(this.gl,a);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Dt(this.gl,s))this.colorBufferHalfFloatExtension=Ds(this.gl,s);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Dt(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Dt(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=q$(this.gl),this.indexBuffer=Y$(this.gl),this.framebuffer=V2(this.gl),this.textureConfig=Ri(this.gl,this.textureHalfFloatExtension)}get debug(){return B().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Q(e,()=>e.finish()),Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Q(e,()=>e.deleteFramebuffer(this.framebuffer)),Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Q(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Q(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Q$(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Z$(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),J$(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),sS(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),rS(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),tS(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),eS(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Vu(this.gl,this.framebuffer),this.outputTexture=null),Q(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>iS(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,o,a){return uS(this.gl,e,t,r,s,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return aS(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=oS(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(B().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const a=s.clientWaitSync(o,0,0);return a===s.ALREADY_SIGNALED||a===s.CONDITION_SATISFIED},t=o}else B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>cS(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=X$(t));const r=F2(t);return Q(t,()=>t.attachShader(r,this.vertexShader)),Q(t,()=>t.attachShader(r,e)),D2(t,r),this.debug&&zo(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=nS(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Q(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&zo(this.gl,this.program),Q(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?W2(this.gl,e,t):z2(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Q(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),G2(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,o]=Or(t,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&zo(this.gl,this.program),Ps(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),Q(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Q(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ds(this.gl,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await uu(()=>this.disposed||this.isQueryAvailable(e,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=lS(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&uu(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Go(this.gl,e,this.framebuffer),this.debug&&Ps(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Go(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ps(this.gl)):Vu(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;Go(s,e,this.framebuffer),this.debug&&Ps(s),this.outputTexture=e,Q(s,()=>s.viewport(0,0,t,r)),Q(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Q(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function lS(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hS(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vt(n){return(e,t,r,s,o)=>{const a=Se(e,t),i=a.length,u=tt(a),c=j(a),h=Tn(o,c),l=e.length,p=t.length,d=tt(e),f=tt(t),g=Ks(e,a),y=Ks(t,a);if(g.length+y.length===0)for(let w=0;w<h.length;++w)h[w]=n(r[w%r.length],s[w%s.length]);else for(let w=0;w<h.length;++w){const $=nl(w,i,u),S=$.slice(-l);g.forEach(k=>S[k]=0);const T=ca(S,l,d),C=$.slice(-p);y.forEach(k=>C[k]=0);const _=ca(C,p,f);h[w]=n(r[T],s[_])}return[h,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pS=Vt((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n,e,t,r,s){const o=j(r),a=Cn(s,t);for(let i=0;i<n.length;i++){const u=n[i];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o>0?a[u]+=e[i]:a[u]+=1)}return a}function fS(n,e,t,r=!1){const s=n.shape[0],o=n.shape[1],a=Qe([s,t],e.dtype);for(let i=0;i<s;i++)for(let u=0;u<o;u++){const c=n.get(i,u);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(r?a.set(1,i,c):e.size>0?a.set(a.get(i,c)+e.get(i,u),i,c):a.set(a.get(i,c)+1,i,c))}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(n){return(e,t,r)=>{const s=Tn(t,e.length);for(let o=0;o<e.length;++o)s[o]=n(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS=Rn(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gS(n,e,t,r){const s=_t(t,j(e));if(r&&t!=="string"){let o=0;n.forEach(a=>{const i=j(a.shape);s.set(a.vals,o),o+=i})}else{let o=0;n.forEach(a=>{const i=t==="string"?cs(a.vals):a.vals;let u=0;for(let c=0;c<a.shape[0];++c){const h=c*e[1]+o;for(let l=0;l<a.shape[1];++l)s[h+l]=i[u++]}o+=a.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yS=Vt((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xS=Rn(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bS=Rn(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vS=Rn(n=>Math.floor(n));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n,e,t,r,s,o,a,i,u){const c=Qe([r,o],t);for(let h=0;h<r;h++){const l=[];let p=0;for(let d=0;d<s;d++){const f=n[h*s+d];p+=f*a[d],l.push(f)}if(p<0||p>=u/o)throw new Error(`Invalid indices: ${l} does not index into ${i}`);for(let d=0;d<o;d++)c.values[h*o+d]=e.get(...e.indexToLoc(p*o+d))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(n,e,t){const r=Qe(t,n.dtype);for(let s=0;s<r.size;++s){const a=r.indexToLoc(s).slice(),i=a[0],u=a[2],c=e.locToIndex([i,u]);a[2]=e.values[c];const h=n.locToIndex(a);0<=h&&h<n.values.length&&(r.values[s]=n.values[h])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SS=Vt((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TS=Vt((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CS=Vt((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NS=Vt((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ES(n,e,t){const r=(e-n)/(t-1),s=Cn(t,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kS=Rn(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IS(n,e,t,r){const s=Tn(r,j(t));for(let o=0;o<s.length;++o){const a=o*e;let i=n[a];for(let u=0;u<e;++u){const c=n[a+u];(Number.isNaN(c)||c>i)&&(i=c)}s[o]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RS=Vt((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _S=Vt((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jf=Vt((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n,e,t){const r=Ir(-1,t);return Jf([],e,r,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OS=Vt((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(n,e,t,r,s){const o=e.length,a=j(e),i=tt(e),u=tt(s),c=Tn(t,j(s));for(let h=0;h<a;++h){const l=nl(h,o,i),p=new Array(l.length);for(let f=0;f<p.length;f++)p[f]=l[r[f]];const d=ca(p,o,u);c[d]=n[h]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(n,e,t,r){const[s,o]=on(n,r),a=rn(e,"int32"),i=Cn(j(s),a),u=j(o);for(let c=0;c<i.length;++c){const h=c*u;let l=1;for(let p=0;p<u;++p)l*=t[h+p];i[c]=l}return{outVals:i,outShape:s,outDtype:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PS(n,e,t,r){const s=n===e,o=n<e&&t<0,a=e<n&&t>1;if(s||o||a)return Cn(0,r);const i=Math.abs(Math.ceil((e-n)/t)),u=Cn(i,r);e<n&&t===1&&(t=-1),u[0]=n;for(let c=1;c<u.length;c++)u[c]=u[c-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LS=Rn(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BS=Rn(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(n,e,t,r,s){const o=di(r,e,t),a=j(t),i=tt(r);if(o){const l=fi(e,i);return s==="string"?n.slice(l,l+a):n.subarray(l,l+a)}const u=s==="string"?cs(n):n,c=Qe(r,s,u),h=Qe(t,s);for(let l=0;l<h.size;++l){const p=h.indexToLoc(l),d=p.map((f,g)=>f+e[g]);h.set(c.get(...d),...p)}return s==="string"?zf(h.values):h.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VS(n,e,t,r,s,o,a){const i=e[0],u=o[0],c=new Array(u),h=new Array(i),l=e[1];if(u===0){if(i!==0)throw new Error(If(i));const y=_t(t,0),w=_t(s,0);return[y,[0,l],w,c,h]}let p=!0,d=0;const f=new Array(u).fill(0);for(let y=0;y<i;++y){const w=n[y*l];if(w<0)throw new Error(Rf(y,w));if(w>=u)throw new Error(_f(y,w,u));++f[w],p=p&&w>=d,d=w}let g=!0;for(let y=0;y<u;++y){const w=f[y]===0;c[y]=w,g=g&&!w,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(g&&p){const y=n,w=r;for(let $=0;$<i;++$)h[$]=$;return[y,[i,l],w,c,h]}else{const y=f[u-1],w=_t(t,y*l),$=_t(s,y),S=new Array(u).fill(0);for(let T=0;T<i;++T){const C=n[T*l],_=S[C],k=(C===0?0:f[C-1])+_;S[C]++;for(let R=0;R<l;++R)w[k*l+R]=n[T*l+R];$[k]=r[T],h[T]=k}for(let T=0;T<u;++T)if(S[T]===0){const _=T===0?0:f[T-1];w[_*l+0]=T;for(let k=1;k<l;++k)w[_*l+k]=0;$[_]=a}return[w,[y,l],$,c,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(n,e,t,r,s){const o=j(r),a=e[0],i=s.length,u=[];let c=1,h=-1;for(let y=0;y<i;++y){const w=s[y];if(w===-1){if(h!==-1)throw new Error(Af(h,y));h=y,u.push(1)}else{if(w<0)throw new Error(Of(y,w));c*=w,u.push(w)}}if(h!==-1){if(c<=0)throw new Error(Ff());const y=Math.trunc(o/c);if(c*y!==o)throw new Error(Df(r,u));u[h]=y}if(j(u)!==o)throw new Error(Pf(r,u));const p=r.length,d=[];if(p>0){d[p-1]=1;for(let y=p-2;y>=0;--y)d[y]=d[y+1]*r[y+1]}const f=[];if(i>0){f[i-1]=1;for(let y=i-2;y>=0;--y)f[y]=f[y+1]*u[y+1]}const g=_t(t,a*i);for(let y=0;y<a;++y){let w=0;for(let $=0;$<p;++$)w+=n[y*p+$]*d[$];for(let $=0;$<i;++$)g[y*i+$]=Math.trunc(w/f[$]),w%=f[$]}return[g,[a,i],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n,e,t,r,s,o=!1,a=0){const i=r.length,u=[e[0],n.length/e[0]],c=u[1],l=i>0?s[i-1]+1:0;if(l<0)throw new Error(Oa());const p=e.slice();p[0]=l;const d=p.reduce((S,T)=>S*T,1),f=_t(t,d);if(i===0)return l>0&&f.fill(a),[f,p];if(l<=0)throw new Error(Oa());let g=0,y=1,w=0,$=s[g];for(;;){let S=0;if(y<i){if(S=s[y],$===S){++y;continue}if($>=S)throw new Error(Lf())}if($<0||$>=l)throw new Error(Bf($,l));$>w&&f.fill(a,w*c,$*c);for(let T=g;T<y;++T){const C=r[T];if(C<0||C>=u[0])throw new Error(Mf(T,r[T],u[0]));for(let _=0;_<c;_++)f[$*c+_]+=n[C*c+_]}if(o)for(let T=0;T<c;T++)f[$*c+T]/=y-g;if(g=y,++y,w=$+1,$=S,y>i)break}return w<l&&f.fill(a,w*c,l*c),[f,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zS=Rn(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GS=Vt((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(n,e,t,r){const s=Qe(n,e.dtype);for(let o=0;o<s.size;o++){const a=s.indexToLoc(o),i=new Array(a.length);for(let u=0;u<i.length;u++)i[u]=a[u]*t[u]+r[u];s.set(e.get(...i),...a)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jS{constructor(e,t,r,s,o,a){this.separator=zn(e),this.nGramWidths=t,this.leftPad=zn(r),this.rightPad=zn(s),this.padWidth=o,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,o,a){for(let i=0;i<o;++i){const u=this.getPadWidth(a),c=Math.max(0,u-i),h=Math.max(0,u-(o-(i+1))),l=a-(c+h),p=t+(c>0?0:i-u);let d=0;d+=c*this.leftPad.length;for(let $=0;$<l;++$)d+=e[p+$].length;d+=h*this.rightPad.length,d+=(c+h+l-1)*this.separator.length,r[s+i]=new Uint8Array(d);const g=r[s+i];let y=0;const w=$=>$.forEach(S=>g[y++]=S);for(let $=0;$<c;++$)w(this.leftPad),w(this.separator);for(let $=0;$<l-1;++$)w(e[p+$]),w(this.separator);if(l>0){w(e[p+l-1]);for(let $=0;$<h;++$)w(this.separator),w(this.rightPad)}else{for(let $=0;$<h-1;++$)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<s;++c){let h=t[c]>=u;if(h=h&&t[c]<=r,!h)throw new Error(`Invalid split value ${t[c]}, must be in [${u}, ${r}]`);u=t[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const o=s-1,a=_t("int32",s);if(r===0||s===0){const u=new Array(r);for(let c=0;c<=o;++c)a[c]=0;return[u,a]}a[0]=0;for(let u=1;u<=o;++u){const c=t[u]-t[u-1];let h=0;this.nGramWidths.forEach(l=>{h+=this.getNumNGrams(c,l)}),this.preserveShort&&c>0&&h===0&&(h=1),a[u]=a[u-1]+h}const i=new Array(a[o]);for(let u=0;u<o;++u){const c=t[u];let h=a[u];if(this.nGramWidths.forEach(l=>{const p=t[u+1]-t[u],d=this.getNumNGrams(p,l);this.createNGrams(e,c,i,h,d,l),h+=d}),this.preserveShort&&h===a[u]){const l=t[u+1]-t[u];if(l===0)continue;const p=l+2*this.padWidth,d=1;this.createNGrams(e,c,i,h,d,p)}}return[i,a]}}function KS(n,e,t,r,s,o,a,i){return new jS(t,r,s,o,a,i).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(n,e,t,r){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let a=n.indexOf(o);for(;a!==-1;){const i=n.subarray(0,a);(!t||i.length!==0)&&r.push(i),n=n.subarray(a+1),a=n.indexOf(o)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const a=n.subarray(s,o);(!t||a.length!==0)&&r.push(a),s=o+1}}function qS(n,e,t){const r=n.length,s=[];let o=0,a=0;const i=new Array(r);for(let p=0;p<r;++p){const d=s.length;XS(n[p],e,t,s);const f=s.length-d;i[p]=f,o+=f,a=Math.max(a,f)}const u=_t("int32",o*2),c=new Array(o),h=[r,a];let l=0;for(let p=0;p<r;++p)for(let d=0;d<i[p];++d)u[l*2]=p,u[l*2+1]=d,c[l]=s[l],++l;return[u,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YS(n,e){const t=_t("int32",n.length);for(let r=0;r<n.length;++r)t[r]=Ty(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QS=Vt((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZS(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Qe(t,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),a=new Array(n.rank);for(let u=0;u<a.length;u++)a[u]=o[u]%n.shape[u];const i=n.locToIndex(a);r.values[s]=n.values[i]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jr=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function em(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const i=r-t+1,u=e-t+1,c=Math.log(i),h=.5*Math.exp(2*c/3),l=.5*Math.sqrt(c*h*(i-h)/i)*Math.sign(u-i/2),p=Math.max(t,Math.floor(e-u*h/i+l)),d=Math.min(r,Math.floor(e+(i-u)*h/i+l));em(n,e,p,d)}const s=n[e];let o=t,a=r;for(Kr(n,t,e),Jr(n[r],s)>0&&Kr(n,t,r);o<a;){for(Kr(n,o,a),o++,a--;Jr(n[o],s)<0;)o=o+1;for(;Jr(n[a],s)>0;)a=a-1}Jr(n[t],s)===0?Kr(n,t,a):(a=a+1,Kr(n,a,r)),a<=e&&(t=a+1),e<=a&&(r=a-1)}}function JS(n,e,t,r,s){const o=e[e.length-1],[a,i]=[n.length/o,o],u=Tn(t,a*r),c=Tn("int32",a*r);for(let l=0;l<a;l++){const p=l*i,d=n.subarray(p,p+i);let f=new Array(d.length);d.forEach(($,S)=>f[S]={value:$,index:S}),r<f.length&&(em(f,r),f=f.slice(0,r)),s&&f.sort(Jr);const g=l*r,y=u.subarray(g,g+r),w=c.subarray(g,g+r);for(let $=0;$<r;$++)y[$]=f[$].value,w[$]=f[$].index}const h=e.slice();return h[h.length-1]=r,[Qe(h,t,u),Qe(h,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eT(n,e,t,r){const s=Ze(e,t)[0],o=[1,t[0],1];for(let f=0;f<s;f++)o[0]*=t[f];o[1]=t[s];for(let f=s+1;f<t.length;f++)o[2]*=t[f];const a={},i=new Int32Array(t[s]),u=new ss(o,r,n),c=[],h=o[0]===1&&o[2]===1;for(let f=0;f<t[s];f++){let g;if(h)g=n[f].toString();else{const y=[];for(let w=0;w<o[0];w++)for(let $=0;$<o[2];$++)y.push(u.get(w,f,$));g=y.join(",")}if(a[g]!==void 0)i[f]=a[g];else{const y=Object.keys(a).length;a[g]=y,i[f]=y,c.push(f)}}const l=o.slice();l[1]=Object.keys(a).length;const p=new ss(l,r);c.forEach((f,g)=>{for(let y=0;y<o[0];y++)for(let w=0;w<o[2];w++)p.set(u.get(y,f,w),y,g,w)});const d=t.slice();return d[s]=l[1],{outputValues:p.values,outputShape:d,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var tT=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:hS,addImpl:pS,bincountImpl:dS,bincountReduceImpl:fS,ceilImpl:mS,concatImpl:gS,equalImpl:yS,expImpl:xS,expm1Impl:bS,floorImpl:vS,gatherNdImpl:wS,gatherV2Impl:$S,greaterImpl:SS,greaterEqualImpl:TS,lessImpl:CS,lessEqualImpl:NS,linSpaceImpl:ES,logImpl:kS,maxImpl:IS,maximumImpl:RS,minimumImpl:_S,multiplyImpl:Jf,negImpl:AS,notEqualImpl:OS,prodImpl:DS,rangeImpl:PS,rsqrtImpl:LS,sigmoidImpl:BS,sliceImpl:MS,sparseFillEmptyRowsImpl:VS,sparseReshapeImpl:US,sparseSegmentReductionImpl:WS,sqrtImpl:zS,squaredDifferenceImpl:GS,stridedSliceImpl:HS,stringNGramsImpl:KS,stringSplitImpl:qS,stringToHashBucketFastImpl:YS,subImpl:QS,tileImpl:ZS,topKImpl:JS,transposeImpl:FS,uniqueImpl:eT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:nT,bincountImpl:tm,bincountReduceImpl:rT,ceilImpl:sT,concatImpl:oT,equalImpl:aT,expImpl:iT,expm1Impl:uT,floorImpl:cT,gatherNdImpl:lT,gatherV2Impl:hT,greaterImpl:pT,greaterEqualImpl:dT,lessImpl:fT,lessEqualImpl:mT,linSpaceImpl:gT,logImpl:yT,maxImpl:xT,maximumImpl:bT,minimumImpl:vT,multiplyImpl:wT,negImpl:$T,notEqualImpl:ST,prodImpl:TT,rangeImpl:CT,rsqrtImpl:NT,sigmoidImpl:ET,simpleAbsImpl:nm,sliceImpl:kT,sparseFillEmptyRowsImpl:IT,sparseReshapeImpl:RT,sparseSegmentReductionImpl:rm,sqrtImpl:_T,stridedSliceImpl:AT,stringNGramsImpl:OT,stringSplitImpl:FT,stringToHashBucketFastImpl:DT,subImpl:PT,tileImpl:LT,topKImpl:BT,transposeImpl:Fi,uniqueImpl:MT}=tT;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sm(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function it(n,e){return e===1?[n]:sm(n,e)}function VT(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UT{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ft(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=it("rc",this.rank),r=Ae(this.rank),s=this.getOutOfBoundsCondition(t),o=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)o=`${e[e.length-1-a]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class om{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${WT(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Ai():_i(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function WT(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?n$(["r","c","d"],"inputShape"):tr(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zT{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,r){const s=Gu(t,r),o=Hu(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=zu(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const u=this.freeTextures[o].shift();return this.usedTextures[o].push(u),u}let i;return s===Ye.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===Ye.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===Ye.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===Ye.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===Ye.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const o=Gu(r,s),a=Hu(t,o,s);a in this.freeTextures||(this.freeTextures[a]=[]);const i=zu(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=B().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[a],h=c.indexOf(e);if(h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(h,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function GT(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function zu(n,e,t,r,s){const o=HT(e,r);let a;if(s){const[u,c]=Or(n[0],n[1]);a=u*c}else{const[u,c]=vs(n[0],n[1]);a=u*c}const i=GT(t,o);return a*i}function HT(n,e){switch(n){case Ye.PACKED_2X2_FLOAT32:return Qf(e);case Ye.PACKED_2X2_FLOAT16:return Zf(e);case Ye.UNPACKED_FLOAT32:return Xf(e);case Ye.UNPACKED_FLOAT16:return qf(e);case Ye.PACKED_4X1_UNSIGNED_BYTE:return Yf(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function jT(n){return B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ye.PACKED_2X2_FLOAT32:Ye.UNPACKED_FLOAT32:n?Ye.PACKED_2X2_FLOAT16:Ye.UNPACKED_FLOAT16}function Gu(n,e){if(n===wt.UPLOAD)return Ye.PACKED_2X2_FLOAT32;if(n===wt.RENDER||n==null)return jT(e);if(n===wt.DOWNLOAD||n===wt.PIXELS)return Ye.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Hu(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ln{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ut="if (isnan(x)) return x;",KT="return x;",ju="return abs(x);",XT="return (x >= 0.0) ? x : (exp(x) - 1.0);",qT=Ut+`
  return (x < 0.0) ? 0.0 : x;
`,YT=Ut+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,lr="return x;",QT="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZT="return x;",JT=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,eC=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tC=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nC="return 1.0 / (1.0 + exp(-1.0 * x));";class Un{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length);const t=e.length,r=it("rc",t),s=Ae(t),o=VT(t,r),a=r.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sC=nf,oC=1e-7,aC=1e-4,Bs={};function iC(n){return n in Bs||(Bs[n]={}),Bs[n]}const uC=B().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),cC=600;function lC(){return B().global.screen==null?1024:B().global.screen.height*B().global.screen.width*window.devicePixelRatio*cC/1024/1024}class bo extends Qc{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!B().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Xo)t=e;else{const r=qt(B().getNumber("WEBGL_VERSION"),e);t=new Xo(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=qt(B().getNumber("WEBGL_VERSION"));t=new Xo(r),this.binaryCache=iC(B().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zT(this.gpgpu),this.numMBBeforeWarning=lC(),this.texData=new Bg(this,Pn())}nextDataId(){return bo.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,r){if((B().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||B().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:wt.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,o){if(B().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:wt.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:a,shape:i,isPacked:u}=t;if(a!=null){let p;u?p=new Un(i,lr):p=new ln(i,lr);const d=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:s}],s),f=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),f}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let h;c&&(h=Gt());let l;if(s==="complex64"){const p=this.readSync(o.real.dataId),d=this.readSync(o.imag.dataId);l=Aa(p,d)}else l=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Gt()-h),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:r,shape:s,slice:o,dtype:a,complexTensorInfos:i,isPacked:u}=t;if(o!=null){let f;u?f=new Un(s,lr):f=new ln(s,lr);const g=this.runWebGLProgram(f,[{dataId:e,shape:s,dtype:a}],a),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(B().getBool("DEBUG")&&!B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&B().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(a!=="complex64"&&B().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const f=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...Fs(s))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let l;if(a==="complex64"){const f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),g=f[0],y=f[1];l=Aa(g,y)}else if(c==null)l=this.getValuesFromTexture(e);else{const f=j(s);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const f=this.gpgpu.gl;Q(f,()=>f.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(f=>f(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Pn().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:o,slice:a,dtype:i,isPacked:u,texture:c}=r;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let d;u?d=new Un(o,lr):d=new ln(o,lr);const f=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:i}],i),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),l=Pn().makeTensorFromDataId(h.dataId,h.shape,h.dtype),p=this.texData.get(h.dataId);return Object.assign({tensorRef:l},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);let r=t;if(e.dtype==="string")try{r=t.map(s=>rs(s))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,r)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!k2(r))throw B().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),o=j(t);if(B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),d=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...Fs(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),f}const a=B().getBool("WEBGL_PACK")&&s===!0,i=a?Ho(t):t,u=a?new H$(i):new G$(i),c=this.runWebGLProgram(u,[{shape:i,dtype:r,dataId:e}],"float32"),h=this.texData.get(c.dataId),l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),l}timerAvailable(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=wr(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=wr(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);i.kernelMs=Mg(u),i.getExtraProfileInfo=()=>u.map((c,h)=>({name:a[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gt(),endMs:null}}endTimer(e){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Gt(),e)}async getQueryTime(e){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:o,isPacked:a,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,o,a)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=uC){return B().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&j(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){jt("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return sC(e.shape,t)}packedUnaryOp(e,t,r){const s=new Un(e.shape,t),o=this.compileAndRun(s,[e],r);return Pn().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=nm(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(B().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ju,e.dtype);const t=new ln(e.shape,ju),r=this.compileAndRun(t,[e]);return Pn().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&oo(r[0])){const o=r.map(a=>zn(a));s=this.write(o,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){const{dataId:s}=this.makeTensorInfo(e,t,r);return Pn().makeTensorFromDataId(s,e,t,this)}unpackTensor(e){const t=new rC(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new UT(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[Cr(e.shape),...Nr(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Cr(t),...Nr(t)],a=new om(o,r),i=!0,u=[r],c=this.runWebGLProgram(a,[s],e.dtype,u,i);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:a}=r;if(t!=null){const p=j(o),d=t[0]*t[1]*4;I(p<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=Ho(o);let u;s?u=new z$(i):u=new W$(i);const c=!0,h=[t!=null?t:Fs(i)],l=this.runWebGLProgram(u,[{shape:i,dtype:a,dataId:e}],a,h,c,t);return{dtype:a,shape:o,dataId:l.dataId}}runWebGLProgram(e,t,r,s,o=!1,a){const i=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(i.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===ls.DENSE){const w=a!=null?a:Fs(e.outputShape);u.texShape=w.map($=>$*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),j(i.shape)===0)return u.values=Tn(i.dtype,0),i;const c=[],h=t.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(w.dataId);if($.texture==null){if(!e.packedInputs&&j(w.shape)<=B().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!$.isPacked!=!!e.packedInputs)w=$.isPacked?this.unpackTensor(w):this.packTensor(w),c.push(w),$=this.texData.get(w.dataId);else if($.isPacked&&!Js($.shape,w.shape)){const S=w,T=w.shape;w.shape=$.shape,w=this.packedReshape(w,T),c.push(w),$=this.texData.get(w.dataId),S.shape=T}return{shape:w.shape,texData:$,isUniform:!1}});this.uploadToGPU(i.dataId);const l={shape:i.shape,texData:u,isUniform:!1},p=U$(e,h,l),d=this.getAndSaveBinary(p,()=>M$(this.gpgpu,e,h,l)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),V$(this.gpgpu,d,h,l,s),c.forEach(w=>this.disposeIntermediateTensorInfo(w)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=B().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const w=Gt();w-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!B().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const w=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),w}return i}compileAndRun(e,t,r,s,o=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(B().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ae(()=>{if(!B().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=B().getBool("DEBUG");B().set("DEBUG",!1);const t=this.abs(me(1e-8)).dataSync()[0];if(B().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?oC:aC}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:o,texture:a,usage:i,isPacked:u}=t;if(a!=null)return;const c=this.activeTimers!=null;let h;c&&(h=Gt());let l=t.texShape;if(l==null&&(l=K2(r,u),t.texShape=l),o!=null){const p=Ho(r);let d,f=l[1],g=l[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!y)&&([f,g]=Or(l[0],l[1])),u?d=new K$(p,y):d=new j$(p,y);const w=y?[g,f]:l,$=this.makeTensorInfo(w,s),S=this.texData.get($.dataId);y?S.usage=wt.PIXELS:S.usage=wt.UPLOAD,S.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),f,g,o);const T=[[g,f]],C=!0,_=this.runWebGLProgram(d,[$],s,T,C),k=this.texData.get(_.dataId);t.texture=k.texture,t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,this.disposeIntermediateTensorInfo($),this.texData.delete(_.dataId),t.values=null,c&&(this.uploadWaitMs+=Gt()-h)}else{const p=this.acquireTexture(l,i,s,u);t.texture=p}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return this.releaseGPUData(e),t!=null&&(r.values=hC(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*aa(t)}}bo.nextDataId=0;function hC(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Xp()&&Bx("webgl",()=>new bo,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const am=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Er{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=Se(t,r),this.enableShapeUniforms=ft(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vo=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class Ss{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Se(t,r);const o=this.outputShape.length;this.enableShapeUniforms=ft(o);let a="";if(s)if(o===0||j(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ae(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=it("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xt(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const pC={kernelName:si,backendName:"webgl",kernelFunc:xt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _n(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,o=t.makeTensorInfo(r.shape,"complex64"),a=t.texData.get(o.dataId),i=xt({inputs:{x:r},backend:t}),u=xt({inputs:{x:s},backend:t});return a.complexTensorInfos={real:i,imag:u},o}const dC={kernelName:Nl,backendName:"webgl",kernelFunc:_n};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const im="return (a < 0.) ? b * a : a;",um=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function fC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:o}=r,a=t.makeTensorInfo([],"float32",Ir(o,"float32")),i=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ss(um,s.shape,a.shape):new Er(im,s.shape,a.shape),u=t.runWebGLProgram(i,[s,a],"float32");return t.disposeIntermediateTensorInfo(a),u}const mC={kernelName:lh,backendName:"webgl",kernelFunc:fC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cm="return (a < 0.) ? b * a : a;",lm=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function gC(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,o=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ss(lm,r.shape,s.shape):new Er(cm,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],"float32")}const yC={kernelName:Wh,backendName:"webgl",kernelFunc:gC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Br="if (isnan(x)) return x;",xC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,bC=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function ge({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:o})=>{const{x:a}=s,i=o,u=r||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){const l=i.texData.get(a.dataId),p=t(l.values,u);return i.makeTensorInfo(a.shape,u,p)}const c=B().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return c?h=new Un(a.shape,e):h=new ln(a.shape,n),i.runWebGLProgram(h,[a],u)}}function Je({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:a,backend:i})=>{const{a:u,b:c}=a,h=i;if(r&&u.dtype==="complex64"){const f=h.texData.get(u.dataId),g=h.texData.get(c.dataId),[y,w]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(S=>{const[T,C]=S,_={dataId:T.dataId,dtype:T.dtype,shape:u.shape},k={dataId:C.dataId,dtype:C.dtype,shape:c.shape},R=new Er(n,u.shape,c.shape);return h.runWebGLProgram(R,[_,k],rn(T.dtype,C.dtype))}),$=_n({inputs:{real:y,imag:w},backend:h});return h.disposeIntermediateTensorInfo(y),h.disposeIntermediateTensorInfo(w),$}const l=o||rn(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([u,c]))&&s!=null){const f=h.texData.get(u.dataId).values,g=h.texData.get(c.dataId).values,y=u.dtype==="string"?cs(f):f,w=u.dtype==="string"?cs(g):g,[$,S]=s(u.shape,c.shape,y,w,l),T=h.makeTensorInfo(S,l),C=h.texData.get(T.dataId);return C.values=$,T}const p=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return p?d=new Ss(e,u.shape,c.shape,t):d=new Er(n,u.shape,c.shape),h.runWebGLProgram(d,[u,c],l)}}function wo(n,e=!1){if(n==="linear")return e?ZT:KT;if(n==="relu")return e?eC:qT;if(n==="elu")return e?JT:XT;if(n==="relu6")return e?tC:YT;if(n==="prelu")return e?lm:cm;if(n==="leakyrelu")return e?um:im;if(n==="sigmoid")return e?nC:QT;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hm{constructor(e,t,r,s=!1,o=!1,a=!1,i=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ft(this.outputShape.length);const h=s?e[1]:e[2],l=Math.ceil(h/2),p=s?"i * 2, rc.y":"rc.y, i * 2",d=o?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",w="";i&&(u?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:c?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:y=`vec4 activation(vec4 x) {
          ${i}
        }`,w="result = activation(result);");const $=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let S="rc.x",T="rc.x";e[0]<t[0]?S=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(T=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${l}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${l}; i++) {
          int batchA = ${S};
          int batchB = ${T};
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${w}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ku={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Xu{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Se(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qu="return a * b;";function Di(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,o=rn(r.dtype,s.dtype);if(r.dtype==="complex64"){const i=t.texData.get(r.dataId),u=t.texData.get(s.dataId),c=new Xu(Ku.REAL,r.shape,s.shape),h=new Xu(Ku.IMAG,r.shape,s.shape),l=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],p=t.runWebGLProgram(c,l,"float32"),d=t.runWebGLProgram(h,l,"float32"),f=_n({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),f}if(t.shouldExecuteOnCPU([r,s])){const i=t.texData.get(r.dataId),u=t.texData.get(s.dataId),[c,h]=wT(r.shape,s.shape,i.values,u.values,o),l=t.makeTensorInfo(h,o),p=t.texData.get(l.dataId);return p.values=c,l}let a;return B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ss(qu,r.shape,s.shape):a=new Er(qu,r.shape,s.shape),t.runWebGLProgram(a,[r,s],o)}const vC={kernelName:_h,backendName:"webgl",kernelFunc:Di};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wC(n,e,t){const r=[Cr(n.shape),...Nr(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[Cr(e),...Nr(e)],a=new om(o,r),i=!0,u=[r],c=t.runWebGLProgram(a,[s],n.dtype,u,i);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:o}=r,a=t,i=j(s.shape),u=Vg(o,i),c=j(u);I(i===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const h=a.texData.get(s.dataId);return h.isPacked&&!Js(s.shape,u)&&!(h.texture!==null&&Js(h.shape,u))?wC(s,u,a):(a.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}const $C={kernelName:Xh,backendName:"webgl",kernelFunc:X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yu{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:a}=e;this.outputShape=[s,a];const i=Math.floor(r/4)*4,u=r%4;let c="sumValue += dot(values, ones);";if(t!=null){const l=1/t;c=`sumValue += dot(values * ${ts(l)?l.toPrecision(2):l}, ones);`}let h="";o%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SC{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:a}=e;this.outputShape=[s,a];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const h=Math.floor(r/4)*4,l=r%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";o%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${l===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${l===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${l===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TC(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=yo(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function rr(n,e,t,r){const s=TC(n.shape);let o=n;for(let a=0;a<s.length;a++){const{inSize:i,windowSize:u,outSize:c}=s[a];let h,l;t==="mean"?h=a===0?new Yu({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:c},i):new Yu({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:c}):h=new SC({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:c},t),l=o,o=r.runWebGLProgram(h,[o],e),l.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(l)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CC{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[t[a]];this.outputShape=r,this.rank=r.length;const s=Ae(this.rank),o=NC(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function NC(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EC{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let h=0;h<r.length;h++)r[h]=e[t[h]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Ae(this.rank),o=sm("rc",this.rank),a=new Array(this.rank);for(let h=0;h<t.length;h++)a[t[h]]=o[h];const i=`vec2(${a.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${u}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${u}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(n,e,t){const r=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EC(n.shape,e):new CC(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kC(n,e,t,r){const s=e,o=n.shape.length,a=Ze(s,n.shape);let i=a;const u=Bt(i,o),c=u!=null;let h=n;c&&(h=$o(n,u,r),i=Mt(i.length,o)),Zt("sum",i,o);const[l,p]=on(h.shape,i);let d=l;t&&(d=Lt(l,a));const f=j(p),y=j(n.shape)/f,w=X({inputs:{x:h},attrs:{shape:[y,f]},backend:r}),$=ui(n.dtype),S=rr(w,$,"sum",r),T=X({inputs:{x:S},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),c&&r.disposeIntermediateTensorInfo(h),T}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function So(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:a}=r;return kC(s,o,a,t)}const IC={kernelName:hp,backendName:"webgl",kernelFunc:So};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ct(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:o}=r,a=t,i=s.shape.length,u=new Array(i);for(let h=0;h<u.length;h++)u[h]=s.shape[o[h]];let c;if(a.shouldExecuteOnCPU([s])){const l=a.texData.get(s.dataId).values,p=Fi(l,s.shape,s.dtype,o,u);c=a.makeTensorInfo(u,s.dtype);const d=a.texData.get(c.dataId);d.values=p}else c=$o(s,o,a);return c}const RC={kernelName:Rp,backendName:"webgl",kernelFunc:ct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pm=1e3;function eo({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){const c=n.shape.length,h=e.shape.length,l=t?n.shape[c-2]:n.shape[c-1],p=r?e.shape[h-1]:e.shape[h-2],d=t?n.shape[c-1]:n.shape[c-2],f=r?e.shape[h-2]:e.shape[h-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),w=j(g),$=j(y),T=Se(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);I(l===p,()=>`Error in matMul: inner shapes (${l}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const C=t?[w,l,d]:[w,d,l],_=r?[$,f,p]:[$,p,f],k=X({inputs:{x:n},backend:s,attrs:{shape:C}}),R=X({inputs:{x:e},backend:s,attrs:{shape:_}}),A=[k,R],P=Math.max(w,$),U=t?k.shape[1]:k.shape[2],H=o!=null,G=a!=null,q=u==="leakyrelu",te=u!=null?wo(u,!0):null,ne=H||G||q||te!=null;let ue;if((d===1||f===1)&&U>pm&&ne===!1){let Le=k,nt=R;t&&(Le=ct({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),A.push(Le)),r&&(nt=ct({inputs:{x:R},backend:s,attrs:{perm:[0,2,1]}}),A.push(nt));const Ct=f!==1,sr=f===1;let Ur=Le;Ct&&(Ur=X({inputs:{x:Le},backend:s,attrs:{shape:[P,U,1]}}),A.push(Ur));const Co=f===1?2:1;let or=nt;sr&&(or=X({inputs:{x:nt},backend:s,attrs:{shape:[P,1,U]}}),A.push(or));const Ns=Di({inputs:{a:Ur,b:or},backend:s});ue=So({inputs:{x:Ns},backend:s,attrs:{axis:Co,keepDims:!0}}),A.push(Ns)}else{const Le=rn(n.dtype,e.dtype),nt=new hm(C,_,[P,d,f],t,r,H,te,G,q),Ct=[k,R];if(o!=null&&Ct.push(o),G&&Ct.push(a),q){const sr=s.makeTensorInfo([],"float32",Ir(i,"float32"));Ct.push(sr),A.push(sr)}ue=s.runWebGLProgram(nt,Ct,Le)}const ze=X({inputs:{x:ue},backend:s,attrs:{shape:T}});A.push(ue);for(const Le of A)s.disposeIntermediateTensorInfo(Le);return ze}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _C(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:c,activation:h,leakyreluAlpha:l}=r;return eo({a:s,b:o,transposeA:u,transposeB:c,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:l,activation:h})}const AC={kernelName:ha,backendName:"webgl",kernelFunc:_C};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qu="return abs(x);";function OC(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=t.texData.get(r.dataId),a=nm(o.values);return t.makeTensorInfo(r.shape,r.dtype,a)}let s;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Un(r.shape,Qu):s=new ln(r.shape,Qu),t.runWebGLProgram(s,[r],r.dtype)}const FC={kernelName:ol,backendName:"webgl",kernelFunc:OC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DC=Ut+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,PC=ge({opSnippet:DC}),LC={kernelName:al,backendName:"webgl",kernelFunc:PC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BC=Ut+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,MC=ge({opSnippet:BC}),VC={kernelName:il,backendName:"webgl",kernelFunc:MC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zu="return a + b;",UC=Je({opSnippet:Zu,packedOpSnippet:Zu,supportsComplex:!0,cpuKernelImpl:nT}),WC={kernelName:ni,backendName:"webgl",kernelFunc:UC};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zC{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GC{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return xt({inputs:{x:r[0]},backend:t});if(r.length>B().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=Ws({inputs:r.slice(0,u),backend:t}),h=Ws({inputs:r.slice(u),backend:t});return Ws({inputs:[c,h],backend:t})}const s=r.map(u=>u.dtype).reduce((u,c)=>rn(u,c)),o=r.map(u=>u.shape),i=B().getBool("WEBGL_PACK")?new GC(r[0].shape,o):new zC(r[0].shape,o);return t.runWebGLProgram(i,r,s)}const HC={kernelName:ul,backendName:"webgl",kernelFunc:Ws};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,u=Ze(o,s.shape);let c=u;const h=Bt(c,i);let l=s;h!=null&&(l=ct({inputs:{x:s},backend:t,attrs:{perm:h}}),c=Mt(c.length,i)),Zt("all",c,i);const[p,d]=on(l.shape,c),f=j(d),g=X({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}}),y=rr(g,g.dtype,"all",t);let w;if(a){const $=Lt(p,u);w=X({inputs:{x:y},backend:t,attrs:{shape:$}})}else w=X({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),h!=null&&t.disposeIntermediateTensorInfo(l),w}const KC={kernelName:cl,backendName:"webgl",kernelFunc:jC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,u=Ze(o,s.shape);let c=u;const h=Bt(c,i);let l=s;h!=null&&(l=ct({inputs:{x:s},backend:t,attrs:{perm:h}}),c=Mt(c.length,i)),Zt("any",c,i);const[p,d]=on(l.shape,c),f=j(d),g=X({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}}),y=rr(g,g.dtype,"any",t);let w;if(a){const $=Lt(p,u);w=X({inputs:{x:y},backend:t,attrs:{shape:$}})}else w=X({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),h!=null&&t.disposeIntermediateTensorInfo(l),w}const qC={kernelName:ll,backendName:"webgl",kernelFunc:XC};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YC{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:a}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];const i=t==="max"?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QC{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),s||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,c=Ae(u),h=it("coords",u);let l,p;if(a===1){p=u+1;const R=Ae(p);l=`
        ${R} sourceLocR = ${R}(${h.join()}, 0);
        ++${h[u-1]};
        ${R} sourceLocG = ${R}(${h.join()}, 0);
        ++${h[u-2]};
        ${R} sourceLocA = ${R}(${h.join()}, 0);
        --${h[u-1]};
        ${R} sourceLocB = ${R}(${h.join()}, 0);
        --${h[u-2]};`}else p=u,l=`
        ${c} sourceLocR = coords;
        ++${h[u-1]};
        ${c} sourceLocG = coords;
        ++${h[u-2]};
        ${c} sourceLocA = coords;
        --${h[u-1]};
        ${c} sourceLocB = coords;
        --${h[u-2]};`;const d=["x","y","z","w","u","v"].slice(0,p),f="."+d[p-1],g=d.map(R=>"int "+R),y=it("sourceLocR",p-1).concat("inIdx.r"),w=it("sourceLocG",p-1).concat("inIdx.g"),$=it("sourceLocB",p-1).concat("inIdx.b"),S=it("sourceLocA",p-1).concat("inIdx.a"),T=r==="max"?"greaterThan":"lessThan",C=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${S.join()})));`,_=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,k=s?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${h[u-2]} < ${i[u-2]-1};
        ${l}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${T}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dm(n,e,t,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const a=yo(o),i={windowSize:a,inSize:o,batchSize:s,outSize:Math.ceil(o/a)},u=new YC(i,t,r==null),c=[e];r!=null&&c.push(r);const h=n.runWebGLProgram(u,c,"int32");if(h.shape[1]===1)return h;const l=dm(n,e,t,h);return n.disposeIntermediateTensorInfo(h),l}function fm(n,e,t,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],a=yo(o),i=new QC(s,a,t,r==null),u=r==null?[e]:[e,r],c=n.runWebGLProgram(i,u,"int32");if(c.shape.length===e.shape.length){const h=fm(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}return c}function mm(n,e,t,r){const s=[t];if(Zt("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!B().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],a=n.texData.get(e.dataId),i=a!==null&&a.isPacked;let u=e;i&&(u=n.unpackTensor(e),o.push(u));const[c,h]=on(u.shape,s),l=j(h),p=X({inputs:{x:u},backend:n,attrs:{shape:[-1,l]}});o.push(p);const d=dm(n,p,r);o.push(d);const f=X({inputs:{x:d},backend:n,attrs:{shape:c}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return fm(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let a=Ze(o,s.shape);const i=Bt(a,s.shape.length);let u=s;const c=[];i!=null&&(u=ct({inputs:{x:s},backend:t,attrs:{perm:i}}),c.push(u),a=Mt(a.length,u.shape.length)),Zt("argMax",[a[0]],u.shape.length);const h=mm(t,u,a[0],"max");return c.forEach(l=>t.disposeIntermediateTensorInfo(l)),h}const JC={kernelName:hl,backendName:"webgl",kernelFunc:ZC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let a=Ze(o,s.shape);const i=Bt(a,s.shape.length);let u=s;const c=[];i!=null&&(u=ct({inputs:{x:s},backend:t,attrs:{perm:i}}),c.push(u),a=Mt(a.length,u.shape.length)),Zt("argMin",[a[0]],u.shape.length);const h=mm(t,u,a[0],"min");return c.forEach(l=>t.disposeIntermediateTensorInfo(l)),h}const tN={kernelName:pl,backendName:"webgl",kernelFunc:eN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nN=Ut+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,rN=ge({opSnippet:nN}),sN={kernelName:dl,backendName:"webgl",kernelFunc:rN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=Ut+"return log(x + sqrt(x * x + 1.0));",aN=ge({opSnippet:oN}),iN={kernelName:fl,backendName:"webgl",kernelFunc:aN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uN=Ut+`
  return atan(x);
`,cN=ge({opSnippet:uN}),lN={kernelName:ml,backendName:"webgl",kernelFunc:cN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hN=xC+`
  return atan(a, b);
`,pN=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+bC+`
  return result;
`,dN=Je({opSnippet:hN,packedOpSnippet:pN}),fN={kernelName:yl,backendName:"webgl",kernelFunc:dN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mN=Ut+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,gN=ge({opSnippet:mN}),yN={kernelName:gl,backendName:"webgl",kernelFunc:gN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hs{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(g||($="-1.0 / 1e-20"),r){const R=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${l};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${R} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?y:w:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let T=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(T="avgValue / count");const C=Math.floor(a/4)*4,_=a%4,k=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${l};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${C};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${T});
      }
    `}}class Pi{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,u=e.strideHeight,c=e.strideWidth,h=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,w=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const S=t==="avg";let T="0.0";if(S||(T="-1.0 / 1e-20"),r){const P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${c});
        const ivec3 pads = ivec3(${y}, ${w}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${l}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / count");const k=Math.floor(a/4)*4,R=a%4,A=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${c});
      const ivec3 pads = ivec3(${y}, ${w}, ${$});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${k};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${A}
            }
          }
          setOutput(${_});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;ws(s,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:u}=r,c=1;I(Tt(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=Rr(s.shape,o,a,c,i,u);if(h.filterWidth===1&&h.filterHeight===1&&We(h.inShape,h.outShape))return xt({inputs:{x:s},backend:t});const l=new hs(h,"avg",!1);return t.runWebGLProgram(l,[s],"float32")}const bN={kernelName:xl,backendName:"webgl",kernelFunc:xN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:u,dataFormat:c}=r,h=[1,1,1],l=gs(s.shape,o,a,h,i,u,c),p=new Pi(l,"avg",!1);return t.runWebGLProgram(p,[s],"float32")}const wN={kernelName:bl,backendName:"webgl",kernelFunc:vN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $N{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=u-1-e.padInfo.top,l=c-1-e.padInfo.left,p=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${l});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class SN{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,l=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.front,g=p-1-e.padInfo.top,y=d-1-e.padInfo.left,w=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${y});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,a=o,{filterSize:i,strides:u,pad:c,dimRoundingMode:h}=r,l=[1,1,1],p=gs(a.shape,i,u,l,c,h),d=new SN(p);return t.runWebGLProgram(d,[s],a.dtype)}const CN={kernelName:ey,backendName:"webgl",kernelFunc:TN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,a=o;ws([s,o],"avgPoolGrad");const{filterSize:i,strides:u,pad:c}=r,h=Rr(a.shape,i,u,1,c),l=new $N(h);return t.runWebGLProgram(l,[s],a.dtype)}const EN={kernelName:Jg,backendName:"webgl",kernelFunc:NN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kN(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:a,transposeB:i}=r;return eo({a:s,b:o,transposeA:a,transposeB:i,backend:t})}const IN={kernelName:vl,backendName:"webgl",kernelFunc:kN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RN{constructor(e,t,r,s,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Se(e,t),Se(e,r);let i="0.0";s!=null&&(Se(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";o!=null&&(Se(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _N{constructor(e,t,r,s,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Se(e,t),Se(e,r);let i="vec4(0.0)";s!=null&&(Se(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(Se(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AN=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:o,offset:a,scale:i}=n;I(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const c=[r,s,o];let h=null;a!=null&&(h=a.shape,c.push(a));let l=null;i!=null&&(l=i.shape,c.push(i));const p=B().getBool("WEBGL_PACK_NORMALIZATION")?new _N(r.shape,s.shape,o.shape,h,l,u):new RN(r.shape,s.shape,o.shape,h,l,u);return e.runWebGLProgram(p,c,c[0].dtype)},ON={kernelName:nh,backendName:"webgl",kernelFunc:AN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FN{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ae(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=DN(this.rank);let s;const o=e.map((a,i)=>`sourceLoc.${Da[i]} = start[${i}] + coords.${Da[i]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const Da=["x","y","z","w","u","v"];function DN(n){if(n===1)return"sourceLoc";if(n<=6)return Da.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PN{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Ae(this.rank),r=it("coords",this.rank),s=it("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${a};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${a};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((h,l)=>`start[${l}]`).join()});`:e.map((h,l)=>`${s[l]} = ${r[l]} + start[${l}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LN(n,e,t,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(t,n.dtype),a=r.texData.get(o.dataId);Object.assign(a,s),a.refCount=1,a.shape=t,a.dtype=n.dtype;let i=fi(e,tt(n.shape));s.slice&&(i+=s.slice.flatOffset),a.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||n.dataId};const u=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,u+1),o}function Mr(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,size:a}=r,[i,u]=wd(s,o,a);if(hd(s,i,u),j(u)===0)return t.makeTensorInfo(u,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const l=t.texData.get(s.dataId),p=kT(l.values,i,u,s.shape,s.dtype);return t.makeTensorInfo(u,s.dtype,p)}const{isPacked:c}=t.texData.get(s.dataId),h=di(s.shape,i,u);if(c||!h){const l=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PN(u):new FN(u),p=[i];return t.runWebGLProgram(l,[s],s.dtype,p)}return t.uploadToGPU(s.dataId),LN(s,i,u,t)}const BN={kernelName:sp,backendName:"webgl",kernelFunc:Mr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MN=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:a}=r;I(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce(($,S)=>$*S),u=Ei(s.shape,o,i),c=ki(u.length,o.length),h=Ii(s.shape,o,i),l=df(a,o.length),p=ff(h,a,o.length),d=[],f=X({inputs:{x:s},backend:t,attrs:{shape:u}}),g=ct({inputs:{x:f},backend:t,attrs:{perm:c}}),y=X({inputs:{x:g},backend:t,attrs:{shape:h}}),w=Mr({inputs:{x:y},backend:t,attrs:{begin:l,size:p}});return d.push(f),d.push(g),d.push(y),d.forEach($=>t.disposeIntermediateTensorInfo($)),w},VN={kernelName:wl,backendName:"webgl",kernelFunc:MN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:a}=r,i=t.readSync(s.dataId),u=t.readSync(o.dataId),c=tm(i,u,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,c)}const WN={kernelName:$l,backendName:"webgl",kernelFunc:UN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,o=t.readSync(r.dataId),a=t.readSync(s.dataId),i=Se(Array.from(o),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const GN={kernelName:Sl,backendName:"webgl",kernelFunc:zN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HN="return float(a != b);",gm=Je({opSnippet:HN,cpuKernelImpl:ST,dtype:"bool"}),jN={kernelName:Oh,backendName:"webgl",kernelFunc:gm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ts(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return xt({inputs:{x:s.complexTensorInfos.real},backend:t})}const KN={kernelName:Hh,backendName:"webgl",kernelFunc:Ts};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XN="return float(int(x));";function qN(n,e){const t=new ln(n.shape,XN),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return xt({inputs:{x:s},backend:t});const a=En(s.shape),i=Pa({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),u=_n({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),u}if(s.dtype==="complex64"){const a=Ts({inputs:{input:s},backend:t}),i=Pa({inputs:{x:a},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(a),i}if(!zg(s.dtype,o)){const a=xt({inputs:{x:s},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32")return qN(s,t);if(o==="bool"){const a=t.makeTensorInfo([],"bool",Tn("bool",1)),u=gm({inputs:{a:s,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const YN={kernelName:ri,backendName:"webgl",kernelFunc:Pa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ju="return ceil(x);",QN=ge({opSnippet:Ju,packedOpSnippet:Ju,cpuKernelImpl:sT}),ZN={kernelName:Tl,backendName:"webgl",kernelFunc:QN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JN{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eE{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:o,clipValueMax:a}=r;let i;B().getBool("WEBGL_PACK_CLIP")?i=new eE(s.shape):i=new JN(s.shape);const u=[[o],[a]];return t.runWebGLProgram(i,[s],s.dtype,u)}const nE={kernelName:Cl,backendName:"webgl",kernelFunc:tE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rE{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ec(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function sE(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),o=new rE(r.shape),a=[ec(r,s.complexTensorInfos.real),ec(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(o,a,a[0].dtype)}const oE={kernelName:El,backendName:"webgl",kernelFunc:sE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aE{constructor(e){this.outputShape=[],this.outputShape=Qn(e,1),this.variableNames=e.map((a,i)=>`T${i}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const i=t[a-1];r.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}const s=t.length,o=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iE{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Qn(e,t);const r=this.outputShape,s=r.length,o=Ae(s),a=it("coords",s),i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((g,y)=>`T${y}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let g=1;g<u.length;g++)u[g]=u[g-1]+e[g][t];const c=i[t],h=i.slice(-2),l=i.join();let p=`if (${c} < ${u[0]}) {
        return getChannel(
            getT0(${l}), vec2(${h.join()}));
        }`;for(let g=1;g<u.length;g++){const y=u[g-1];p+=`
        if (${c} < ${u[g]}  && ${c} >= ${u[g-1]}) {
          return getChannel(
            getT${g}(${Ms(i,c,y)}),
            vec2(${Ms(h,c,y)}));
        }`}const d=u.length,f=u[u.length-1];p+=`
        return getChannel(
          getT${d}(${Ms(i,c,f)}),
          vec2(${Ms(h,c,f)}));`,this.userCode=`
      float getValue(${i.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[s-1]} = ${a[s-1]} + 1;
        if (${a[s-1]} < ${r[s-1]}) {
          result.g = getValue(${a});
        }

        ${a[s-2]} = ${a[s-2]} + 1;
        if (${a[s-2]} < ${r[s-2]}) {
          result.a = getValue(${a});
        }

        ${a[s-1]} = ${a[s-1]} - 1;
        if (${a[s-2]} < ${r[s-2]} &&
            ${a[s-1]} < ${r[s-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Ms(n,e,t){const r=n.indexOf(e);return n.map((o,a)=>a===r?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function To(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return xt({inputs:{x:s.complexTensorInfos.imag},backend:t})}const uE={kernelName:uh,backendName:"webgl",kernelFunc:To};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr(n,e,t){const r=n[0].dtype;if(r==="complex64"){const h=n.map(g=>Ts({inputs:{input:g},backend:t})),l=n.map(g=>To({inputs:{input:g},backend:t})),p=gr(h,e,t),d=gr(l,e,t),f=_n({inputs:{real:p,imag:d},backend:t});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),f}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const h=n.map(w=>{const $=j(w.shape.slice(e));return X({inputs:{x:w},backend:t,attrs:{shape:[-1,$]}})}),l=h.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),p=Qn(h.map(w=>w.shape),1),d=h[0].shape[0]===1,f=oT(l,p,r,d),g=Qn(n.map(w=>w.shape),e),y=t.makeTensorInfo(g,r,f);return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),y}if(n.length>B().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const h=Math.floor(n.length/2),l=gr(n.slice(0,h),e,t),p=gr(n.slice(h),e,t),d=gr([l,p],e,t);return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),d}if(B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const h=new iE(n.map(l=>l.shape),e);return t.runWebGLProgram(h,n,r)}const{tensors2D:o,outShape:a}=cE(n,e,t),i=new aE(o.map(h=>h.shape)),u=t.runWebGLProgram(i,o,r);o.forEach(h=>t.disposeIntermediateTensorInfo(h));const c=X({inputs:{x:u},attrs:{shape:a},backend:t});return t.disposeIntermediateTensorInfo(u),c}function cE(n,e,t){const r=Qn(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>X({inputs:{x:o},attrs:{shape:[-1,j(o.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ym(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,o=Ze(s,e[0].shape)[0],a=Qn(e.map(c=>c.shape),o);if(j(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const i=e.filter(c=>j(c.shape)>0);if(i.length===1)return xt({inputs:{x:i[0]},backend:t});const u=i.map(c=>c.shape);return hf(u,o),gr(i,o,t)}const lE={kernelName:kl,backendName:"webgl",kernelFunc:ym};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xm{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,l=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",w=y?1:2,$=y?2:3,S=y?3:1;let T="",C="";r&&(s?T=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?T=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:T=`
          float activation(float x) {
            ${r}
          }
        `,C="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${T}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${l};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${C}
        setOutput(result);
      }
    `}}class hE{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,l=e.filterDepth,p=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${l}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pE{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ft(this.outputShape.length);const{dataFormat:r}=t,s=lt(),o=r==="channelsLast",a=o?0:1,i=o?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let c="";for(let h=0;h<=1;h++)for(let l=0;l<=1;l++)c+=`
          blockIndex = rc.y + ${l};
          pos = rc.x + ${h};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+l}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+l}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bm({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const u=n.shape,c=r.texData.get(n.dataId),h=t.inChannels,l=u[0]*u[1]*u[2],p=t.outChannels,d=t.dataFormat==="channelsLast",f=!1,g=!1;let y;const w=[];if(!((l===1||p===1)&&h>pm)&&c.isPacked&&d&&c.texture!=null&&u[2]%2!==0&&We(c.shape.slice(-3),u.slice(-3))){const T=u[0]*u[1]*(u[2]+1),C={dataId:n.dataId,shape:[1,T,t.inChannels],dtype:n.dtype},_=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,I(Js(c.shape,C.shape),()=>`packed reshape ${c.shape} to ${C.shape} isn't free`);const k=X({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});w.push(k);const R=eo({a:C,b:k,backend:r,transposeA:f,transposeB:g,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),A=r.texData.get(R.dataId);I(A.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=_,A.shape=t.outShape,y=xt({inputs:{x:R},backend:r}),y.shape=t.outShape,w.push(R)}else{const T=d?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],C=X({inputs:{x:n},backend:r,attrs:{shape:[1,T,t.inChannels]}}),_=X({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=eo({a:C,b:_,transposeA:f,transposeB:g,backend:r,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a});y=X({inputs:{x:k},backend:r,attrs:{shape:t.outShape}}),w.push(C),w.push(_),w.push(k)}for(const T of w)r.disposeIntermediateTensorInfo(T);return y}function vm({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const{filterWidth:u,filterHeight:c,inChannels:h,outWidth:l,outHeight:p,dataFormat:d}=t,f=d==="channelsLast",g=u*c*h,y=p*l,w=[g,y],$=!0,S=!1,T=[],C=X({inputs:{x:n},backend:r,attrs:{shape:n.shape.slice(1)}}),_=X({inputs:{x:e},backend:r,attrs:{shape:[1,g,j(e.shape)/g]}});T.push(C),T.push(_);const k=new pE(w,t),R=[C.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=r.runWebGLProgram(k,[C],"float32",R),P=X({inputs:{x:A},backend:r,attrs:{shape:[1,w[0],w[1]]}});T.push(A),T.push(P);const U=s!=null,H=o!=null,G=i==="leakyrelu",q=i?wo(i,!0):null,te=new hm(P.shape,_.shape,[1,y,t.outChannels],$,S,U,q,H,G),ne=[P,_];if(s&&ne.push(s),H&&ne.push(o),G){const nt=r.makeTensorInfo([],"float32",Ir(a,"float32"));ne.push(nt),T.push(nt)}const ue=r.runWebGLProgram(te,ne,"float32"),ze=f?[1,p,l,t.outChannels]:[1,t.outChannels,p,l],Le=X({inputs:{x:ue},backend:r,attrs:{shape:ze}});T.push(ue);for(const nt of T)r.disposeIntermediateTensorInfo(nt);return Le}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:a,pad:i,dataFormat:u,dilations:c,dimRoundingMode:h}=r,l=_r(u),p=St(s.shape,o.shape,a,c,i,h,!1,l);let d;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))d=bm({x:s,filter:o,convInfo:p,backend:t});else if(B().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)d=vm({x:s,filter:o,convInfo:p,backend:t});else{const g=new xm(p);d=t.runWebGLProgram(g,[s,o],"float32")}const f=X({inputs:{x:d},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(d),f}const fE={kernelName:Il,backendName:"webgl",kernelFunc:dE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mE{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class gE{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=r-1-e.padInfo.left,c=a?1:2,h=a?2:3,l=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${l}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class yE{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class xE{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,c=r-1-e.padInfo.top,h=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:h}=r,l=_r(u),p=St(s.shape,h,a,1,i,c,!1,l),d=new mE(p);return t.runWebGLProgram(d,[s,o],"float32")}const vE={kernelName:Rl,backendName:"webgl",kernelFunc:bE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{inputShape:a,strides:i,pad:u,dataFormat:c,dimRoundingMode:h}=r,l=_r(c),p=St(a,o.shape,i,1,u,h,!1,l),d=new gE(p);return t.runWebGLProgram(d,[s,o],"float32")}const $E={kernelName:_l,backendName:"webgl",kernelFunc:wE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:a,pad:i,dilations:u}=r,c=ys(s.shape,o.shape,a,u,i),h=new hE(c);return t.runWebGLProgram(h,[s,o],"float32")}const TE={kernelName:Al,backendName:"webgl",kernelFunc:SE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:a,pad:i,filterShape:u}=r,c=ys(s.shape,u,a,1,i),h=new yE(c);return t.runWebGLProgram(h,[s,o],"float32")}const NE={kernelName:ty,backendName:"webgl",kernelFunc:CE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{pad:a,strides:i,inputShape:u}=r,c=ys(u,o.shape,i,1,a),h=new xE(c);return t.runWebGLProgram(h,[s,o],"float32")}const kE={kernelName:ny,backendName:"webgl",kernelFunc:EE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IE=Br+`
  return cos(x);
`,RE=ge({opSnippet:IE}),_E={kernelName:Ol,backendName:"webgl",kernelFunc:RE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AE=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,OE=ge({opSnippet:AE}),FE={kernelName:Fl,backendName:"webgl",kernelFunc:OE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DE{constructor(e,t,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,u,c]=e,[h]=t,[l,p]=r;this.outputShape=[h,l,p,c];const d=s==="bilinear"?1:0,[f,g]=[`${i-1}.0`,`${u-1}.0`],[y,w,$]=l>1?[`${(i-1)/(l-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[S,T,C]=p>1?[`${(u-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${T};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PE=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:o,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:c}=r,h=new DE(s.shape,o.shape,i,u,c);return t.runWebGLProgram(h,[s,o,a],"float32")},LE={kernelName:Pl,backendName:"webgl",kernelFunc:PE};class tc{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const s=e.length,o=t?"0.0":`getX(${nc(s,"coords")})`,a=e[e.length-1];let i="",u="";t?(i=r?`end != ${a-1}`:"end != 0",u=r?"end + 1":"end - 1"):(i=r?`end + pow2 < ${a}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ae(s)} coords = getOutputCoords();
        int end = ${rc(s,"coords")};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${u};
          ${rc(s,"coords")} = idx;
          val += getX(${nc(s,"coords")});
        }
        setOutput(val);
      }
    `}}function nc(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function rc(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:a,reverse:i}=r,u=s.shape.length,c=Bt([o],u);let h=s;c!=null&&(h=ct({inputs:{x:s},backend:t,attrs:{perm:c}}));const l=Mt(1,u)[0];if(l!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const p=h.shape[l];let d=xt({inputs:{x:h},backend:t});for(let f=0;f<=Math.ceil(Math.log2(p))-1;f++){const g=new tc(h.shape,!1,i),y=[[f]],w=d;d=t.runWebGLProgram(g,[d],d.dtype,y),t.disposeIntermediateTensorInfo(w)}if(a){const f=new tc(h.shape,a,i),g=d;d=t.runWebGLProgram(f,[d],d.dtype),t.disposeIntermediateTensorInfo(g)}if(c!=null){const f=$i(c),g=ct({inputs:{x:d},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}return d}const ME={kernelName:Dl,backendName:"webgl",kernelFunc:BE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:a,binaryOutput:i}=r;if(s.shape.length===1){const u=t.readSync(s.dataId),c=t.readSync(o.dataId),h=tm(u,c,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,h)}else if(s.shape.length===2){const u=t.bufferSync(s),c=t.bufferSync(o),h=rT(u,c,a,i);return t.makeTensorInfo(h.shape,o.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const UE={kernelName:Ll,backendName:"webgl",kernelFunc:VE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WE{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:o,dataFormat:a}=r,i=s.shape[0],u=a==="NHWC"?s.shape[1]:s.shape[2],c=a==="NHWC"?s.shape[2]:s.shape[3],h=a==="NHWC"?s.shape[3]:s.shape[1],l=u*o,p=c*o,d=h/(o*o),f=a==="NHWC"?[i,l,p,d]:[i,d,l,p],g=new WE(f,o,a);return t.runWebGLProgram(g,[s],s.dtype)}const GE={kernelName:Bl,backendName:"webgl",kernelFunc:zE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wm{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ft(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels;let c="",h="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,h="result = activation(result);");const l=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${l}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $m{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ft(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,c=e.dilationWidth,h=e.filterHeight,l=e.filterWidth,p=l;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<l;w++)d+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;d+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let w=0;w<l;w++)d+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(p+1)/2;w++){const $=w*2;if(d+=`
          xC = xCCorner + ${$*c};
          `,u===1){if($<l&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,c===1&&$>0?d+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<l)){const S=i%2===0?Zc(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,c>1&&(d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                      xTexelC${$} = getX(batch, xR, xCOffset, d1);
                      xTexelC${$}Ready = 1;
                    }
                    `),d+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                  `):S===1?d+=`
                    xC${$+1} = xTexelC${$};
                    `:d+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<l&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<l&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<l&&(d+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<l&&(d+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<l&&(d+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let f="",g="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:c}=r;let h=u;h==null&&(h=[1,1]),I(Tt(a,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const l=St(s.shape,o.shape,a,h,i,c,!0);let p;B().getBool("WEBGL_PACK_DEPTHWISECONV")&&l.strideWidth<=2&&l.outChannels/l.inChannels===1?p=new $m(l):p=new wm(l);const d=[[l.padInfo.top,l.padInfo.left],[l.strideHeight,l.strideWidth],[l.dilationHeight,l.dilationWidth],[l.inHeight,l.inWidth]];return t.runWebGLProgram(p,[s,o],"float32",d)}const jE={kernelName:Ml,backendName:"webgl",kernelFunc:HE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KE{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class XE{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=r-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:c,filterShape:h}=r,l=St(s.shape,h,a,i,u,c,!0),p=new KE(l);return t.runWebGLProgram(p,[s,o],"float32")}const YE={kernelName:Vl,backendName:"webgl",kernelFunc:qE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QE(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:c,inputShape:h}=r,l=St(h,o.shape,a,i,u,c,!0),p=new XE(l);return t.runWebGLProgram(p,[s,o],"float32")}const ZE={kernelName:Ul,backendName:"webgl",kernelFunc:QE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JE{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],o=j(r.shape),a=X({inputs:{x:r},backend:t,attrs:{shape:[o]}}),i=new JE(o),u=t.runWebGLProgram(i,[a],a.dtype),c=X({inputs:{x:u},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),c}const tk={kernelName:ry,backendName:"webgl",kernelFunc:ek};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nk{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:u,dilationHeight:c,dilationWidth:h}=e,{top:l,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${l}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rk(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:a,pad:i,dilations:u}=r,c=Cd(s.shape,o.shape,a,i,"NHWC",u);let h;const l=new nk(c);h=t.runWebGLProgram(l,[s,o],"float32");const p=X({inputs:{x:h},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(h),p}const sk={kernelName:Wl,backendName:"webgl",kernelFunc:rk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ok(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,o=e,{allDims:a,summedDims:i,idDims:u}=Sf(s,o.length);Cf(a.length,u,o);const{path:c,steps:h}=Nf(i,u),l=h.length;let p=null,d=a.length;const f=[];for(let g=0;g<l;++g){for(const y of h[g]){const{permutationIndices:w,expandDims:$}=Tf(d,u[y]);let S;Ef(w)?S=o[y]:(S=ct({inputs:{x:o[y]},backend:t,attrs:{perm:w}}),f.push(S));const T=S.shape.slice();for(let C=0;C<$.length;++C)T.splice($[C],0,1);We(S.shape,T)||(S=X({inputs:{x:S},backend:t,attrs:{shape:T}}),f.push(S)),p===null?p=S:(p=Di({inputs:{a:S,b:p},backend:t}),f.push(p))}g<l-1&&(c[g]>=0&&(p=So({inputs:{x:p},backend:t,attrs:{axis:c[g]-(a.length-d),keepDims:!1}}),f.push(p)),d--)}for(const g of f)g!==p&&t.disposeIntermediateTensorInfo(g);return p}const ak={kernelName:Gl,backendName:"webgl",kernelFunc:ok};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ik="return (x >= 0.0) ? x : (exp(x) - 1.0);",uk=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ck=ge({opSnippet:ik,packedOpSnippet:uk}),lk={kernelName:Hl,backendName:"webgl",kernelFunc:ck};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hk="return (b >= 1.0) ? a : a * (b + 1.0);",pk=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,dk=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,o=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ss(pk,r.shape,s.shape):new Er(hk,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],r.dtype)},fk={kernelName:sy,backendName:"webgl",kernelFunc:dk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mk=`
  return vec4(equal(a, b));
`,gk="return float(a == b);",yk=Je({opSnippet:gk,packedOpSnippet:mk,dtype:"bool",cpuKernelImpl:aT}),xk={kernelName:Kl,backendName:"webgl",kernelFunc:yk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bk=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${yf};
  float a1 = ${xf};
  float a2 = ${bf};
  float a3 = ${vf};
  float a4 = ${wf};
  float a5 = ${$f};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,vk=ge({opSnippet:bk}),wk={kernelName:jl,backendName:"webgl",kernelFunc:vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $k=Br+`
  return exp(x);
`,Sk=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Sm=ge({opSnippet:$k,packedOpSnippet:Sk,cpuKernelImpl:iT,dtype:"float32"}),Tk={kernelName:Xl,backendName:"webgl",kernelFunc:Sm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function La(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:o}=e,a=o.shape.length,i=o.shape.slice();let u=s;return s<0&&(I(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),X({inputs:{x:o},backend:r,attrs:{shape:i}})}const Ck={kernelName:ql,backendName:"webgl",kernelFunc:La};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sc="return exp(x) - 1.0;",Nk=ge({opSnippet:sc,packedOpSnippet:sc,cpuKernelImpl:uT}),Ek={kernelName:Yl,backendName:"webgl",kernelFunc:Nk};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oc{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=r?`${s}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tm(n,e,t){const r=t.texData.get(n.dataId),s=j(n.shape),o=n.shape[n.shape.length-1],a=s/o,i=X({inputs:{x:n},backend:t,attrs:{shape:[a,o]}}),u=i.shape,c=new oc("real",u,e),h=new oc("imag",u,e),l=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=t.runWebGLProgram(c,l,"float32"),d=t.runWebGLProgram(h,l,"float32"),f=_n({inputs:{real:p,imag:d},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d);const g=X({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kk(n){const{inputs:e,backend:t}=n,{input:r}=e;return Tm(r,!1,t)}const Ik={kernelName:Ql,backendName:"webgl",kernelFunc:kk};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rk{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cs(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:o}=t;if(o=o||ao(s),o==="string"){const a=_t(o,j(r));return a.fill(s),e.makeTensorInfo(r,o,a)}else{const a=new Rk(r,s),i=[[s]];return e.runWebGLProgram(a,[],o,i)}}const _k={kernelName:Zl,backendName:"webgl",kernelFunc:Cs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ak{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ok={kernelName:Jl,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new Ak(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ac="return floor(x);",Fk=ge({opSnippet:ac,packedOpSnippet:ac,cpuKernelImpl:cT}),Dk={kernelName:eh,backendName:"webgl",kernelFunc:Fk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pk=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Lk=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Bk=Je({opSnippet:Pk,packedOpSnippet:Lk,dtype:"int32"}),Mk={kernelName:th,backendName:"webgl",kernelFunc:Bk};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vk{constructor(e){this.variableNames=["A"];const t=lt(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uk{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=lt(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wk={kernelName:la,backendName:"webgl",kernelFunc:zk};let hr;function zk(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:o}=r,a=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[u,c]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],h=[c,u],l=[c,u,o];(i||a)&&(hr==null&&(hr=document.createElement("canvas").getContext("2d")),hr.canvas.width=u,hr.canvas.height=c,hr.drawImage(s,0,0,u,c),s=hr.canvas);const p=t.makeTensorInfo(h,"int32");t.texData.get(p.dataId).usage=wt.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),s);const d=B().getBool("WEBGL_PACK")?new Uk(l):new Vk(l),f=t.runWebGLProgram(d,[p],"int32");return t.disposeData(p.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gk(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:a,preluActivationWeights:i}=e,{strides:u,pad:c,dataFormat:h,dilations:l,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,g=_r(h),y=St(s.shape,o.shape,u,l,c,p,!1,g);let w;const $=[];if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))w=bm({x:s,filter:o,convInfo:y,backend:t,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else if(B().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)w=vm({x:s,filter:o,convInfo:y,backend:t,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else{const T=a!=null,C=i!=null,_=d==="leakyrelu",k=d?wo(d,!1):null,R=new xm(y,T,k,C,_),A=[s,o];if(a&&A.push(a),i&&A.push(i),_){const P=t.makeTensorInfo([],"float32",Ir(f,"float32"));A.push(P),$.push(P)}w=t.runWebGLProgram(R,A,"float32")}const S=X({inputs:{x:w},backend:t,attrs:{shape:y.outShape}});return $.push(w),$.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}const Hk={kernelName:pa,backendName:"webgl",kernelFunc:Gk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jk(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:a,preluActivationWeights:i}=e,{strides:u,pad:c,dilations:h,dimRoundingMode:l,activation:p,leakyreluAlpha:d}=r,f=[];let g=h;g==null&&(g=[1,1]),I(Tt(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);const y=St(s.shape,o.shape,u,g,c,l,!0),w=B().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,$=p?wo(p,w):null,S=[s,o],T=a!=null,C=i!=null,_=p==="leakyrelu";if(T&&S.push(a),C&&S.push(i),_){const P=t.makeTensorInfo([],"float32",Ir(d,"float32"));S.push(P),f.push(P)}let k;w?k=new $m(y,T,$,C,_):k=new wm(y,T,$,C,_);const R=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],A=t.runWebGLProgram(k,S,"float32",R);return f.forEach(P=>t.disposeIntermediateTensorInfo(P)),A}const Kk={kernelName:da,backendName:"webgl",kernelFunc:jk};class Xk{constructor(e,t,r){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=r;const s=Ae(t.length),o=Ae(r.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,o=s.shape,a=o[o.length-1],i=j(r.shape),[u,c,h,l]=ud(r,s),p=X({inputs:{x:s},backend:t,attrs:{shape:[c,a]}}),d=X({inputs:{x:r},backend:t,attrs:{shape:[j(r.shape)/h,h]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const w=t.readSync(s.dataId),$=t.bufferSync(r),S=lT(w,$,r.dtype,c,a,h,l,r.shape,i);return t.makeTensorInfo(u,r.dtype,S.values)}const f=new Xk(a,l,[c,h]),g=t.runWebGLProgram(f,[d,p],d.dtype),y=X({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),y}const Yk={kernelName:sh,backendName:"webgl",kernelFunc:qk};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qk{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Ae(this.rank),s=Zk(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function Zk(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cm(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:o}=e,{axis:a,batchDims:i}=r,u=Ze(a,s.shape)[0];if(B().get("DEBUG")){const $=t.readSync(o.dataId),S=s.shape[u];for(let T=0;T<$.length;++T){const C=$[T];I(C<=S-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${S-1}]`)}}const c=Wf(s,o,u,i),h=j(o.shape),l=[],p=X({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=X({inputs:{x:o},backend:t,attrs:{shape:[c.batchSize,h/c.batchSize]}});l.push(p),l.push(d);const f=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const $=t.bufferSync(d),S=t.bufferSync(p),T=hT(S,$,f);return l.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(c.outputShape,T.dtype,T.values)}const g=new Qk(p.shape,f),y=t.runWebGLProgram(g,[p,d],p.dtype);l.push(y);const w=X({inputs:{x:y},backend:t,attrs:{shape:c.outputShape}});return l.forEach($=>t.disposeIntermediateTensorInfo($)),w}const Jk={kernelName:rh,backendName:"webgl",kernelFunc:Cm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eI="return float(a > b);",tI=`
  return vec4(greaterThan(a, b));
`,nI=Je({opSnippet:eI,packedOpSnippet:tI,cpuKernelImpl:pT,dtype:"bool"}),rI={kernelName:oh,backendName:"webgl",kernelFunc:nI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI="return float(a >= b);",oI=`
  return vec4(greaterThanEqual(a, b));
`,aI=Je({opSnippet:sI,packedOpSnippet:oI,dtype:"bool",cpuKernelImpl:dT}),iI={kernelName:ah,backendName:"webgl",kernelFunc:aI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(n){const{inputs:e,backend:t}=n,{input:r}=e;return Tm(r,!0,t)}const cI={kernelName:ih,backendName:"webgl",kernelFunc:uI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lI="return float(!isnan(x) && !isinf(x));",hI=ge({opSnippet:lI,dtype:"bool"}),pI={kernelName:oy,backendName:"webgl",kernelFunc:hI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dI="return float(isinf(x));",fI=ge({opSnippet:dI,dtype:"bool"}),mI={kernelName:ay,backendName:"webgl",kernelFunc:fI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gI="return float(isnan(x));",yI=ge({opSnippet:gI,dtype:"bool"}),xI={kernelName:ch,backendName:"webgl",kernelFunc:yI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bI="return float(a < b);",vI=`
  return vec4(lessThan(a, b));
`,wI=Je({opSnippet:bI,packedOpSnippet:vI,cpuKernelImpl:fT,dtype:"bool"}),$I={kernelName:hh,backendName:"webgl",kernelFunc:wI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SI="return float(a <= b);",TI=`
  return vec4(lessThanEqual(a, b));
`,CI=Je({opSnippet:SI,packedOpSnippet:TI,cpuKernelImpl:mT,dtype:"bool"}),NI={kernelName:ph,backendName:"webgl",kernelFunc:CI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:o}=t,a=gT(r,s,o);return e.makeTensorInfo([a.length],"float32",a)}const kI={kernelName:dh,backendName:"webgl",kernelFunc:EI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const II=Br+`
  return x < 0.0 ? 0./0. : log(x);
`,RI=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,_I=ge({opSnippet:II,packedOpSnippet:RI,cpuKernelImpl:yT}),AI={kernelName:fh,backendName:"webgl",kernelFunc:_I};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OI=Br+`
  return log(1.0 + x);
`,FI=ge({opSnippet:OI}),DI={kernelName:mh,backendName:"webgl",kernelFunc:FI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PI="return float(a >= 1.0 && b >= 1.0);",LI=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,BI=Je({opSnippet:PI,packedOpSnippet:LI,dtype:"bool"}),MI={kernelName:gh,backendName:"webgl",kernelFunc:BI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VI="return float(!(x >= 1.0));",UI=ge({opSnippet:VI}),WI={kernelName:yh,backendName:"webgl",kernelFunc:UI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zI="return float(a >= 1.0 || b >= 1.0);",GI=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,HI=Je({opSnippet:zI,packedOpSnippet:GI,dtype:"bool"}),jI={kernelName:xh,backendName:"webgl",kernelFunc:HI};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KI{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;this.outputShape=e;let u;const c=`float(${r}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${c})`:o===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XI{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;this.outputShape=e;let u;const c=`float(${r}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${c})`:o===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qI=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:o,bias:a,alpha:i,beta:u}=r,c=B().getBool("WEBGL_PACK_NORMALIZATION")?new XI(s.shape,o,a,i,u):new KI(s.shape,o,a,i,u);return t.runWebGLProgram(c,[s],s.dtype)},YI={kernelName:bh,backendName:"webgl",kernelFunc:qI};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QI{constructor(e,t,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZI=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:o,dy:a}=e,{depthRadius:i,bias:u,alpha:c,beta:h}=r,l=new QI(s.shape,i,u,c,h);return t.runWebGLProgram(l,[s,o,a],s.dtype)},JI={kernelName:iy,backendName:"webgl",kernelFunc:ZI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eR(n,e,t,r){const s=j(e),a=j(n.shape)/s,i=X({inputs:{x:n},attrs:{shape:[a,s]},backend:r}),u=rr(i,n.dtype,"max",r),c=X({inputs:{x:u},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nm(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:o,keepDims:a}=r,i=s.shape.length,u=Ze(o,s.shape);let c=u;const h=Bt(c,i),l=h!=null,p=t.shouldExecuteOnCPU([s]);let d=s;if(l){if(p){const S=t.texData.get(d.dataId).values,T=new Array(i);for(let k=0;k<T.length;k++)T[k]=s.shape[h[k]];const C=Fi(S,s.shape,s.dtype,h,T);d=t.makeTensorInfo(T,s.dtype);const _=t.texData.get(d.dataId);_.values=C}else d=$o(s,h,t);c=Mt(c.length,i)}Zt("max",c,i);const[f,g]=on(d.shape,c);let y=f;a&&(y=Lt(f,u));let w;if(p){const S=t.texData.get(d.dataId).values,T=xT(S,j(g),y,s.dtype);w=t.makeTensorInfo(y,s.dtype);const C=t.texData.get(w.dataId);C.values=T}else w=eR(d,g,y,t);return l&&t.disposeIntermediateTensorInfo(d),w}const tR={kernelName:vh,backendName:"webgl",kernelFunc:Nm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nR=am+`
  return max(a, b);
`,rR=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+vo+`
  return result;
`,sR=Je({opSnippet:nR,packedOpSnippet:rR,cpuKernelImpl:bT}),oR={kernelName:wh,backendName:"webgl",kernelFunc:sR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;ws(s,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:u}=r,c=1;I(Tt(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=Rr(s.shape,o,a,c,i,u);if(h.filterWidth===1&&h.filterHeight===1&&We(h.inShape,h.outShape))return xt({inputs:{x:s},backend:t});const l=new hs(h,"max",!1);return t.runWebGLProgram(l,[s],s.dtype)}const iR={kernelName:$h,backendName:"webgl",kernelFunc:aR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:a,pad:i,dataFormat:u,dimRoundingMode:c}=r,h=[1,1,1],l=gs(s.shape,o,a,h,i,c,u),p=new Pi(l,"max",!1);return t.runWebGLProgram(p,[s],s.dtype)}const cR={kernelName:Sh,backendName:"webgl",kernelFunc:uR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lR{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,u=a-1-e.padInfo.left,c=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class hR{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,l=u-1-e.padInfo.front,p=c-1-e.padInfo.top,d=h-1-e.padInfo.left,f=u*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,a=o,{filterSize:i,strides:u,pad:c,dimRoundingMode:h}=r,l=[1,1,1],p=gs(a.shape,i,u,l,c,h),d=new Pi(p,"max",!0),f=t.runWebGLProgram(d,[a],a.dtype),g=new hR(p),y=t.runWebGLProgram(g,[s,f],a.dtype);return t.disposeIntermediateTensorInfo(f),y}const dR={kernelName:cy,backendName:"webgl",kernelFunc:pR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o,output:a}=e,i=o;ws([o,a],"maxPoolGrad");const{filterSize:u,strides:c,pad:h,dimRoundingMode:l}=r,p=Rr(i.shape,u,c,1,h,l),d=!0,f=new hs(p,"max",d),g=t.runWebGLProgram(f,[i],i.dtype),y=new lR(p),w=t.runWebGLProgram(y,[s,g],i.dtype);return t.disposeIntermediateTensorInfo(g),w}const mR={kernelName:uy,backendName:"webgl",kernelFunc:fR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(n,e,t,r){let s=new hs(t,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");s=new hs(t,"max",!0,!0,e);const a=r.runWebGLProgram(s,[n],"float32");return[o,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yR={kernelName:Th,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=e,u=t;I(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];I(Tt(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=Rr(r.shape,s,o,c,a),[l,p]=gR(r,i,h,u);return[l,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xR(n,e,t,r){const s=j(e),a=j(n.shape)/s,i=X({inputs:{x:n},attrs:{shape:[a,s]},backend:r}),u=rr(i,"float32","mean",r),c=X({inputs:{x:u},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bR={kernelName:Ch,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:o}=e,a=t,i=r.shape.length,u=Ze(o,r.shape);let c=u;const h=Bt(c,i),l=h!=null,p=a.shouldExecuteOnCPU([r]),d=[];let f=r;if(l){if(p){const T=a.texData.get(f.dataId).values,C=new Array(i);for(let R=0;R<C.length;R++)C[R]=r.shape[h[R]];const _=Fi(T,r.shape,r.dtype,h,C);f=a.makeTensorInfo(C,r.dtype);const k=a.texData.get(f.dataId);k.values=_}else f=$o(r,h,a);d.push(f),c=Mt(c.length,i)}Zt("sum",c,i);const[g,y]=on(f.shape,c);let w=g;s&&(w=Lt(g,u));const $=xR(f,y,w,a);for(const S of d)a.disposeIntermediateTensorInfo(S);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,u=Ze(o,s.shape);let c=u;const h=Bt(c,i);let l=s;h!=null&&(l=ct({inputs:{x:s},backend:t,attrs:{perm:h}}),c=Mt(c.length,s.shape.length)),Zt("min",c,i);const[p,d]=on(l.shape,c),f=j(d),g=X({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}}),y=rr(g,g.dtype,"min",t);let w;if(a){const $=Lt(p,u);w=X({inputs:{x:y},backend:t,attrs:{shape:$}})}else w=X({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),h!=null&&t.disposeIntermediateTensorInfo(l),w}const wR={kernelName:Nh,backendName:"webgl",kernelFunc:vR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $R=am+`
  return min(a, b);
`,SR=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+vo+`
  return result;
`,TR=Je({opSnippet:$R,packedOpSnippet:SR,cpuKernelImpl:vT}),CR={kernelName:Eh,backendName:"webgl",kernelFunc:TR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NR{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((h,l)=>h[0]+e[l]+h[1]);const s=e.length,o=Ae(s),a=t.map(h=>h[0]).join(","),i=t.map((h,l)=>h[0]+e[l]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ER{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const s=e.length,o=Ae(s),a=t.map(f=>f[0]).join(","),i=t.map((f,g)=>f[0]+e[g]).join(","),u=it("rc",s),c=it("source",s),h=`${u[s-1]} < ${this.outputShape[s-1]}`,l=s===1?"source":`vec2(${c.slice(-2).join()})`,p=r==="reflect"?0:1;let d="";if(s===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${l});
        ${u[s-1]} += 1;
        if(${h}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${l});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${l});
        ${u[s-1]} += 1;
        if(${h}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${l});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${l});
          ${u[s-1]} += 1;
          if(${h}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${l});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:o}=t,a=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ER(r.shape,s,o):new NR(r.shape,s,o);return e.runWebGLProgram(a,[r],r.dtype)},IR={kernelName:kh,backendName:"webgl",kernelFunc:kR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RR=`if (b == 0.0) return NAN;
  return mod(a, b);`,_R=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+vo+`
  return result;
`,AR=Je({opSnippet:RR,packedOpSnippet:_R}),OR={kernelName:Ih,backendName:"webgl",kernelFunc:AR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FR{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DR=`
if (a == b) {
  return 1.0;
};
return a / b;`,PR=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Em=Je({opSnippet:DR,packedOpSnippet:PR,checkOutOfBounds:!0}),LR={kernelName:zl,backendName:"webgl",kernelFunc:Em};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ic="return a - b;",km=Je({opSnippet:ic,packedOpSnippet:ic,supportsComplex:!0,cpuKernelImpl:PT}),BR={kernelName:Cp,backendName:"webgl",kernelFunc:km};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Im(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:o}=r,a=Ze([o],s.shape),i=Nm({inputs:{x:s},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=Lt(i.shape,a),c=X({inputs:{x:i},backend:t,attrs:{shape:u}}),h=km({inputs:{a:s,b:c},backend:t}),l=Sm({inputs:{x:h},backend:t}),p=So({inputs:{x:l},backend:t,attrs:{axis:a,keepDims:!1}}),d=X({inputs:{x:p},backend:t,attrs:{shape:u}}),f=Em({inputs:{a:l,b:d},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),f}const MR={kernelName:fp,backendName:"webgl",kernelFunc:Im};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VR(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:o,seed:a,normalized:i}=r,u=i?s:Im({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=u.shape[0],h=u.shape[1],l=new FR(c,h,o),p=[[a]],d=t.runWebGLProgram(l,[u],"int32",p);return i||t.disposeIntermediateTensorInfo(u),d}const UR={kernelName:Rh,backendName:"webgl",kernelFunc:VR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WR=Ut+`
  return -x;
`,zR=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function GR(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId),[a,i]=$T(o.values,r.shape,r.dtype);return t.makeTensorInfo(i,r.dtype,a)}let s;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Un(r.shape,zR):s=new ln(r.shape,WR),t.runWebGLProgram(s,[r],r.dtype)}const HR={kernelName:Ah,backendName:"webgl",kernelFunc:GR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jR=uf;function KR(n){jt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=r,c=t.readSync(s.dataId),h=t.readSync(o.dataId),{selectedIndices:l}=jR(c,h,a,i,u);return t.makeTensorInfo([l.length],"int32",new Int32Array(l))}const XR={kernelName:Fh,backendName:"webgl",kernelFunc:KR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qR=cf;function YR(n){jt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=r,h=t.readSync(s.dataId),l=t.readSync(o.dataId),{selectedIndices:p,validOutputs:d}=qR(h,l,a,i,u,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const QR={kernelName:Dh,backendName:"webgl",kernelFunc:YR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZR=lf;function JR(n){jt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=r,h=t.readSync(s.dataId),l=t.readSync(o.dataId),p=a,d=i,f=u,g=c,{selectedIndices:y,selectedScores:w}=ZR(h,l,p,d,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const e_={kernelName:Ph,backendName:"webgl",kernelFunc:JR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t_{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{depth:o,onValue:a,offValue:i}=r,u=j(s.shape),c=new t_(u,o,a,i),h=X({inputs:{x:s},backend:t,attrs:{shape:[u]}}),l=t.runWebGLProgram(c,[h],s.dtype);t.disposeIntermediateTensorInfo(h);const p=[...s.shape,o],d=X({inputs:{x:l},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(l),d},r_={kernelName:Bh,backendName:"webgl",kernelFunc:n_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function to(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=Ts({inputs:{input:r},backend:t}),o=to({inputs:{x:s},backend:t}),a=To({inputs:{input:r},backend:t}),i=to({inputs:{x:a},backend:t}),u=_n({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Cs({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const s_={kernelName:Op,backendName:"webgl",kernelFunc:to};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rm(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Ts({inputs:{input:r},backend:t}),o=Rm({inputs:{x:s},backend:t}),a=To({inputs:{input:r},backend:t}),i=to({inputs:{x:a},backend:t}),u=_n({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Cs({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const o_={kernelName:Lh,backendName:"webgl",kernelFunc:Rm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return La({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,a=e[0].dtype;e.forEach(h=>{Yt(o,h.shape,"All tensors passed to stack must have matching shapes"),I(a===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=e.map(h=>{const l=La({inputs:{input:h},backend:t,attrs:{dim:s}});return i.push(l),l}),c=ym({inputs:u,backend:t,attrs:{axis:s}});return i.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const i_={kernelName:Mh,backendName:"webgl",kernelFunc:a_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u_{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const s=e.length,o=Ae(s),a=t.map(c=>c[0]).join(","),i=t.map((c,h)=>c[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c_{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const s=e.length,o=Ae(s),a=t.map(g=>g[0]).join(","),i=t.map((g,y)=>g[0]+e[y]).join(","),u=it("rc",s),c=it("source",s),h=`${u[s-1]} < ${this.outputShape[s-1]}`,l=s===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${h}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${h}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,y=s===1?2:4;g<y;g++)f+=`
        ${p[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${l});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _m=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,constantValue:a}=r;if(j(s.shape)===0){const c=o.map((h,l)=>h[0]+s.shape[l]+h[1]);return Cs({backend:t,attrs:{shape:c,value:a,dtype:s.dtype}})}const i=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c_(s.shape,o,a):new u_(s.shape,o,a),u=[[a]];return t.runWebGLProgram(i,[s],s.dtype,u)},l_={kernelName:Vh,backendName:"webgl",kernelFunc:_m};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h_=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,p_=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+vo+`
  return result;
`,d_=Je({opSnippet:h_,packedOpSnippet:p_}),f_={kernelName:Uh,backendName:"webgl",kernelFunc:d_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:a}=r,i=s.shape.length,u=[],c=Ze(o,s.shape);let h=c;const l=Bt(h,i);let p=s;l!=null&&(p=ct({inputs:{x:s},backend:t,attrs:{perm:l}}),h=Mt(h.length,i),u.push(p)),Zt("prod",h,i);let d;if(t.shouldExecuteOnCPU([p])){const f=t.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:w}=TT(p.shape,p.dtype,f,h);d=t.makeTensorInfo(y,w,g)}else{const[f,g]=on(p.shape,h),y=j(g),w=X({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}}),$=ui(s.dtype),S=rr(w,$,"prod",t);d=X({inputs:{x:S},backend:t,attrs:{shape:f}}),u.push(w),u.push(S)}if(a){u.push(d);const f=Lt(d.shape,c);d=X({inputs:{x:d},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}const g_={kernelName:zh,backendName:"webgl",kernelFunc:m_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Am=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:o,dtype:a}=t,i=CT(r,s,o,a);return e.makeTensorInfo([i.length],a,i)},y_={kernelName:Gh,backendName:"webgl",kernelFunc:Am};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x_="return 1.0 / x;",b_=ge({opSnippet:x_}),v_={kernelName:jh,backendName:"webgl",kernelFunc:b_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w_=Ut+`
  return (x < 0.0) ? 0.0 : x;
`,$_=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,S_=ge({opSnippet:w_,packedOpSnippet:$_}),T_={kernelName:Kh,backendName:"webgl",kernelFunc:S_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C_=Ut+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,N_=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,E_=ge({opSnippet:C_,packedOpSnippet:N_}),k_={kernelName:Qh,backendName:"webgl",kernelFunc:E_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I_{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,r,c];const h=[s&&t>1?i-1:i,s&&r>1?u-1:u],l=[s&&t>1?t-1:t,s&&r>1?r-1:r];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/l[0]},
          ${h[1]/l[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,r,c];const h=[s&&t>1?i-1:i,s&&r>1?u-1:u],l=[s&&t>1?t-1:t,s&&r>1?r-1:r];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/l[0]},
          ${h[1]/l[1]},
          ${h[1]/l[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:i}=r,[u,c]=i,h=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new R_(s.shape,u,c,o,a):new I_(s.shape,u,c,o,a);return t.runWebGLProgram(h,[s],"float32")}const A_={kernelName:Yh,backendName:"webgl",kernelFunc:__};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O_{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,a,i]=e,u=[r&&a>1?s-1:s,r&&i>1?o-1:o],c=[r&&a>1?a-1:a,r&&i>1?i-1:i],h=u[0]/c[0],l=u[1]/c[1],p=1/h,d=1/l,f=Math.ceil(p)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${l});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:a}=r,i=new O_(o.shape,s.shape,a);return t.runWebGLProgram(i,[o],o.dtype)}const D_={kernelName:hy,backendName:"webgl",kernelFunc:F_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P_{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,r,c];const h=[s&&t>1?i-1:i,s&&r>1?u-1:u],l=[s&&t>1?t-1:t,s&&r>1?r-1:r],p=s?"0.5":"0.0";let d;o?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/l[0]},
          ${h[1]/l[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L_{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,r,c];const h=[s&&t>1?i-1:i,s&&r>1?u-1:u],l=[s&&t>1?t-1:t,s&&r>1?r-1:r],p=s?"0.5":"0.0";let d;o?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/l[0]},
          ${h[1]/l[1]},
          ${h[1]/l[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:a,size:i}=r,[u,c]=i,h=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new L_(s.shape,u,c,o,a):new P_(s.shape,u,c,o,a);return t.runWebGLProgram(h,[s],s.dtype)}const M_={kernelName:qh,backendName:"webgl",kernelFunc:B_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V_{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,a,i]=e,u=[r&&a>1?s-1:s,r&&i>1?o-1:o],c=[r&&a>1?a-1:a,r&&i>1?i-1:i],h=u[0]/c[0],l=u[1]/c[1],p=1/h,d=1/l,f=Math.ceil(p)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${l});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:a}=r,i=new V_(o.shape,s.shape,a);return t.runWebGLProgram(i,[o],o.dtype)}const W_={kernelName:ly,backendName:"webgl",kernelFunc:U_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z_{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,o=e.map((i,u)=>s(u)).join(","),a=Ae(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G_{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=it("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,a=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,i=Ae(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${o}){
            result.g = ${c(s.slice())};
          }
          if(${a}) {
            result.b = ${h(s.slice())};
            if(${o}) {
              result.a = ${l(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return p(f)}function c(f){return f[r-1]="("+f[r-1]+" + 1)",p(f)}function h(f){return f[r-2]="("+f[r-2]+" + 1)",p(f)}function l(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",p(f)}function p(f){const g=e.map(($,S)=>d(S,f)),y=g.join(","),w=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${w}))`}function d(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r,a=s.shape.length,i=Ze(o,s.shape);if(a===0)return xt({inputs:{x:s},backend:t});const u=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G_(s.shape,i):new z_(s.shape,i);return t.runWebGLProgram(u,[s],s.dtype)}const j_={kernelName:Zh,backendName:"webgl",kernelFunc:H_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K_{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X_={kernelName:Dp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:o,center:a}=e,i=t,u=new K_(r.shape,o),[c,h]=pf(a,r.shape[1],r.shape[2]),l=[[c,h,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(u,[r],r.dtype,l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Y_=ge({opSnippet:q_}),Q_={kernelName:Jh,backendName:"webgl",kernelFunc:Y_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z_="return inversesqrt(x);",J_=ge({opSnippet:Z_,cpuKernelImpl:NT}),eA={kernelName:ep,backendName:"webgl",kernelFunc:J_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Om{constructor(e,t,r,s,o,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=Ae(o.length),c=Ae(a.length);let h="";r===1?h="i":r===2&&(h="i, j");const l=`getIndices(${h})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const d=`getUpdates(${p})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${l});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:o}=e,{shape:a}=r,{sliceRank:i,numUpdates:u,sliceSize:c,strides:h,outputSize:l}=pi(o,s,a),p=[l/c,c];if(l===0)return t.makeTensorInfo(a,s.dtype);const d=X({inputs:{x:s},backend:t,attrs:{shape:[u,i]}}),f=X({inputs:{x:o},backend:t,attrs:{shape:[u,c]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new Om(u,i,d.shape.length,f.shape.length,h,p),w=t.runWebGLProgram(y,[f,d,g],f.dtype),$=X({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(g),$}const nA={kernelName:tp,backendName:"webgl",kernelFunc:tA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rA{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let h=0;h<t.length;h++)c.push(`${i[h]}`),h<e&&u.push(`${i[h]}`);s=u.join(),o=c.join()}const a=Ae(r);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e,a=new rA(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(a,[r,s,o],rn(s.dtype,o.dtype))}const oA={kernelName:np,backendName:"webgl",kernelFunc:sA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aA=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${mf};
  float scale = ${gf};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,iA=ge({opSnippet:aA}),uA={kernelName:rp,backendName:"webgl",kernelFunc:iA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cA=Br+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,lA=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hA=ge({opSnippet:cA,packedOpSnippet:lA,cpuKernelImpl:ET}),pA={kernelName:up,backendName:"webgl",kernelFunc:hA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dA=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,fA=ge({opSnippet:dA}),mA={kernelName:ip,backendName:"webgl",kernelFunc:fA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gA=Br+`
  return sin(x);
`,yA=ge({opSnippet:gA}),xA={kernelName:op,backendName:"webgl",kernelFunc:yA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bA=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,vA=ge({opSnippet:bA}),wA={kernelName:ap,backendName:"webgl",kernelFunc:vA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $A=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,SA=ge({opSnippet:$A}),TA={kernelName:cp,backendName:"webgl",kernelFunc:SA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CA=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:a}=r;I(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((w,$)=>w*$),u=[[0,0]];u.push(...a);for(let w=1+o.length;w<s.shape.length;++w)u.push([0,0]);const c=[],h=_m({inputs:{x:s},backend:t,attrs:{paddings:u,constantValue:0}}),l=Ei(h.shape,o,i,!1),p=ki(l.length,o.length,!1),d=Ii(h.shape,o,i,!1),f=X({inputs:{x:h},backend:t,attrs:{shape:l}}),g=ct({inputs:{x:f},backend:t,attrs:{perm:p}}),y=X({inputs:{x:g},backend:t,attrs:{shape:d}});return c.push(h),c.push(f),c.push(g),c.forEach(w=>t.disposeIntermediateTensorInfo(w)),y},NA={kernelName:pp,backendName:"webgl",kernelFunc:CA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=t.readSync(r.dataId),u=t.readSync(s.dataId),c=t.readSync(o.dataId),h=t.readSync(a.dataId)[0],[l,p,d,f,g]=IT(i,r.shape,r.dtype,u,s.dtype,c,h);return[t.makeTensorInfo(p,r.dtype,l),t.makeTensorInfo([p[0]],s.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const kA={kernelName:mp,backendName:"webgl",kernelFunc:EA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IA(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(t.readSync(s.dataId)),i=t.readSync(r.dataId),u=Array.from(t.readSync(o.dataId)),[c,h,l]=RT(i,r.shape,r.dtype,a,u);return[t.makeTensorInfo(h,r.dtype,c),t.makeTensorInfo([l.length],o.dtype,new Int32Array(l))]}const RA={kernelName:gp,backendName:"webgl",kernelFunc:IA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _A(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const a=t.readSync(r.dataId),i=t.readSync(s.dataId),u=t.readSync(o.dataId),[c,h]=rm(a,r.shape,r.dtype,i,u,!0);return t.makeTensorInfo(h,r.dtype,c)}const AA={kernelName:yp,backendName:"webgl",kernelFunc:_A};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OA(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const a=t.readSync(r.dataId),i=t.readSync(s.dataId),u=t.readSync(o.dataId),[c,h]=rm(a,r.shape,r.dtype,i,u);return t.makeTensorInfo(h,r.dtype,c)}const FA={kernelName:xp,backendName:"webgl",kernelFunc:OA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DA(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:a}=e,{outputShape:i}=r,{sliceRank:u,numUpdates:c,strides:h,outputSize:l}=pi(o,s,i),p=!1,d=new Om(c,u,s.shape.length,o.shape.length,h,[l,1],p),f=t.runWebGLProgram(d,[o,s,a],o.dtype),g=X({inputs:{x:f},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),g}const PA={kernelName:bp,backendName:"webgl",kernelFunc:DA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:a}=r,i=Ze(a,s.shape)[0],u=kf(s,o,i),c=s.shape.length,h=new Array(c).fill(0),l=s.shape.slice();return u.map(p=>{const d=[...l];d[i]=p;const f=Mr({inputs:{x:s},backend:t,attrs:{begin:h,size:d}});return h[i]+=p,f})}const BA={kernelName:dp,backendName:"webgl",kernelFunc:LA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uc="return sqrt(x);",MA=ge({opSnippet:uc,packedOpSnippet:uc,cpuKernelImpl:_T}),VA={kernelName:lp,backendName:"webgl",kernelFunc:MA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UA="return x * x;",WA=ge({opSnippet:UA}),zA={kernelName:py,backendName:"webgl",kernelFunc:WA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cc="return (a - b) * (a - b);",GA=Je({opSnippet:cc,packedOpSnippet:cc}),HA={kernelName:vp,backendName:"webgl",kernelFunc:GA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=Ut+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new ln(r.shape,s);return t.runWebGLProgram(o,[r],r.dtype)}const KA={kernelName:Fp,backendName:"webgl",kernelFunc:jA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XA{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Ae(r.length),a=Ae(r.length);let i="";if(s===1)i="coords * strides + begin";else{let u=0;i=r.map((c,h)=>(u++,r.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${u-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,end:a,strides:i,beginMask:u,endMask:c,ellipsisMask:h,newAxisMask:l,shrinkAxisMask:p}=r,{finalShapeSparse:d,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:w,begin:$,end:S,strides:T}=$d(s.shape,o,a,i,u,c,h,l,p);let C;if(g)C=X({inputs:{x:s},backend:t,attrs:{shape:f}});else if(y||w){I(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=pd($,S,T),R=Mr({inputs:{x:s},backend:t,attrs:{begin:$,size:k}});C=X({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(R)}else if(t.shouldExecuteOnCPU([s])){const R=t.readSync(s.dataId),A=Qe(s.shape,s.dtype,R),P=AT(d,A,T,$);C=t.makeTensorInfo(f,s.dtype,P.values)}else{const R=new XA($,T,d);C=t.runWebGLProgram(R,[s],s.dtype)}const _=X({inputs:{x:C},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(C),_}const YA={kernelName:wp,backendName:"webgl",kernelFunc:qA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:c}=r,{data:h,dataSplits:l}=e,p=t.readSync(h.dataId),d=t.readSync(l.dataId),[f,g]=OT(p,d,s,o,a,i,u,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(l.shape,"int32",g)]}const ZA={kernelName:$p,backendName:"webgl",kernelFunc:QA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=t.readSync(o.dataId),u=t.readSync(a.dataId)[0],[c,h,l]=FT(i,u,s),p=h.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(l))]}const eO={kernelName:Sp,backendName:"webgl",kernelFunc:JA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tO(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(o.dataId),i=DT(a,s);return t.makeTensorInfo(o.shape,"int32",i)}const nO={kernelName:Tp,backendName:"webgl",kernelFunc:tO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rO="return tan(x);",sO=ge({opSnippet:rO}),oO={kernelName:Np,backendName:"webgl",kernelFunc:sO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aO=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,iO=ge({opSnippet:aO}),uO={kernelName:Ep,backendName:"webgl",kernelFunc:iO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cO{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[a]*t[a];this.outputShape=r,this.rank=r.length;const s=Ae(this.rank),o=lO(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function lO(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fm(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const u=t.readSync(s.dataId),c=s.dtype==="string"?u.map(p=>rs(p)):u,h=Qe(s.shape,s.dtype,c),l=LT(h,o);return t.makeTensorInfo(l.shape,l.dtype,l.values)}const a=new cO(s.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const hO={kernelName:oi,backendName:"webgl",kernelFunc:Fm};class pO{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class dO{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fn(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function lc(n){let e=1;for(;e<n;)e*=2;return e}function fO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:o,sorted:a}=r,i=B().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=B().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,h=c[c.length-1];if(t.shouldExecuteOnCPU([s])||h<i||o>u){const P=t.readSync(s.dataId),[U,H]=BT(P,c,s.dtype,o,a);return[t.makeTensorInfo(U.shape,U.dtype,U.values),t.makeTensorInfo(H.shape,H.dtype,H.values)]}if(o===0)return c[c.length-1]=0,[t.makeTensorInfo(c,s.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(h===1)return[s,Cs({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const l=t.texData.get(s.dataId),p=l!==null&&l.isPacked,d=p?t.unpackTensor(s):s,g=j(c)/h,y=X({inputs:{x:d},attrs:{shape:[g,h]},backend:t});p&&Fn(t,d);const w=lc(o),$=lc(h);let S=null;const T=()=>S===null?[y,y]:[y,S],C=(P,U,H)=>{const G=T(),q=new pO(H),ne=[[h],[S===null?1:0],[Number.NEGATIVE_INFINITY],[P],[U]],ue=S;S=t.runWebGLProgram(q,G,"int32",ne),Fn(t,ue)};for(let P=1;P<w;P*=2){const U=P*2;for(let H=P;H>=1;H/=2)C(U,H,[g,$])}for(let P=$;P>w;P/=2){const U=T(),H=new dO([g,P/2]),q=[[h],[S===null?1:0],[w]],te=S;S=t.runWebGLProgram(H,U,"int32",q),Fn(t,te);const ne=w/2,ue=ne*2;for(let ze=ne;ze>=1;ze/=2)C(ue,ze,S.shape)}let _=S;S=Mr({inputs:{x:S},backend:t,attrs:{begin:0,size:[g,o]}}),Fn(t,_);let k=Cm({inputs:{x:y,indices:S},backend:t,attrs:{axis:1,batchDims:1}});Fn(t,y);const R=c.slice(0,-1);R.push(o),_=S,S=X({inputs:{x:S},attrs:{shape:R},backend:t}),Fn(t,_);const A=k;return k=X({inputs:{x:k},attrs:{shape:R},backend:t}),Fn(t,A),[k,S]}const mO={kernelName:kp,backendName:"webgl",kernelFunc:fO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gO{constructor(e,t,r,s,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i=r==="nearest"?1:2;let u;switch(s){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yO(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:c}=r,[h,l,p,d]=s.shape,[f,g]=c!=null?c:[l,p],y=[h,f,g,d],w=new gO(l,p,a,i,u,y);return t.runWebGLProgram(w,[s,o],"float32")}const xO={kernelName:Ip,backendName:"webgl",kernelFunc:yO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:o}=e;ws(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(o.dataId),{outputValues:i,outputShape:u,indices:c}=MT(a,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}const vO={kernelName:_p,backendName:"webgl",kernelFunc:bO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const a=s,i=a.shape.length,u=s.shape[o],c=new Array(i-1);let h=0;for(let g=0;g<i;g++)g!==o&&(c[h++]=a.shape[g]);const l=[],p=new Array(i).fill(0),d=a.shape.slice();d[o]=1;const f=new Array(u);for(let g=0;g<f.length;g++){p[o]=g;const y=Mr({inputs:{x:a},backend:t,attrs:{begin:p,size:d}}),w=X({inputs:{x:y},backend:t,attrs:{shape:c}});f[g]=w,l.push(y)}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const $O={kernelName:Ap,backendName:"webgl",kernelFunc:wO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SO{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/r);this.outputShape=[s,i];const u="0.0",c="sumValue",h=Math.floor(r/4)*4,l=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${l===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:o}=e,{numSegments:a}=r,i=s.shape.length,u=[];let c=0;const h=Bt([c],i);let l=s;h!=null&&(l=ct({inputs:{x:s},backend:t,attrs:{perm:h}}),u.push(l),c=Mt(1,i)[0]);const p=Uf(l.shape,c,a),d=j([l.shape[c]]),f=X({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});u.push(f);const g=ui(s.dtype),y=(T,C,_,k,R)=>{const A=T.shape[0],P=T.shape[1],U=Vf(P,R),H={windowSize:U,inSize:P,batchSize:A,numSegments:R},G=new SO(H,C),q=t.compileAndRun(G,[T,_],k);if(u.push(q),q.shape[1]===R)return q;const te=Am({backend:t,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),ne=Fm({inputs:{x:te},backend:t,attrs:{reps:[P/U]}});return u.push(te),u.push(ne),y(q,C,ne,k,R)},w=y(f,"unsortedSegmentSum",o,g,a),$=X({inputs:{x:w},backend:t,attrs:{shape:p}});let S=$;if(h!=null){u.push($);const T=$i(h);S=ct({inputs:{x:S},backend:t,attrs:{perm:T}})}return u.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}const CO={kernelName:dy,backendName:"webgl",kernelFunc:TO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NO=[AC,FC,LC,VC,WC,HC,KC,qC,JC,tN,sN,iN,lN,fN,yN,bN,wN,CN,EN,IN,ON,VN,WN,GN,YN,ZN,nE,dC,oE,lE,fE,vE,$E,TE,NE,kE,_E,FE,LE,ME,UE,GE,jE,YE,ZE,tk,sk,ak,lk,fk,xk,wk,Tk,Ck,Ek,Ik,_k,Ok,Dk,Mk,Wk,Hk,Kk,Yk,Jk,rI,iI,pC,cI,uE,pI,mI,xI,mC,$I,NI,kI,AI,DI,MI,WI,jI,YI,JI,tR,oR,iR,cR,dR,mR,yR,bR,wR,CR,IR,OR,UR,vC,HR,XR,QR,e_,jN,r_,o_,i_,l_,f_,yC,g_,y_,KN,LR,v_,T_,k_,$C,A_,D_,M_,W_,j_,X_,Q_,eA,nA,oA,uA,pA,mA,xA,wA,BN,MR,TA,NA,kA,RA,AA,FA,PA,BA,VA,zA,HA,KA,YA,ZA,eO,nO,BR,IC,oO,uO,hO,mO,xO,RC,vO,$O,CO,s_];for(const n of NO)gy(n);var EO={exports:{}},Dm={exports:{}};function kO(n){return n>64&&n<91?n-65:n>96&&n<123?n-71:n>47&&n<58?n+4:n===43?62:n===47?63:0}function IO(n,e){for(var t=n.replace(/[^A-Za-z0-9\+\/]/g,""),r=t.length,s=e?Math.ceil((r*3+1>>2)/e)*e:r*3+1>>2,o=new Uint8Array(s),a,i,u=0,c=0,h=0;h<r;h++)if(i=h&3,u|=kO(t.charCodeAt(h))<<18-6*i,i===3||r-h===1){for(a=0;a<3&&c<s;a++,c++)o[c]=u>>>(16>>>a&24)&255;u=0}return o}var RO={decode:IO},_O=function(n,e){return new Promise(function(t,r){var s=new XMLHttpRequest;e&&(s.responseType=e),s.open("GET",n),s.onload=function(){s.status===200?t(s.response):r(Error(s.statusText))},s.onerror=function(){r(Error("Network Error"))},s.send()})};(function(n){var e=RO,t=_O;function r(k){return function(R){return typeof R=="string"&&k.test(R)}}function s(k,R){return typeof k=="string"?k+R:typeof k=="function"?k(R):R}function o(k,R,A,P){var U=a(R)?i:u(R)?c:h(R)?l:p(R)?d:f(R)?g:y(R)?w:$(R)?S:T(R)?C:null,H=A||{};return U?U(k,R,H):P?Promise.resolve(P):Promise.reject("Source not valid ("+R+")")}o.fetch=t;function a(k){return k instanceof ArrayBuffer}function i(k,R,A){return new Promise(function(P,U){k.decodeAudioData(R,function(H){P(H)},function(){U("Can't decode audio data ("+R.slice(0,30)+"...)")})})}var u=r(/\.(mp3|wav|ogg)(\?.*)?$/i);function c(k,R,A){var P=s(A.from,R);return o(k,o.fetch(P,"arraybuffer"),A)}function h(k){return k&&typeof k.then=="function"}function l(k,R,A){return R.then(function(P){return o(k,P,A)})}var p=Array.isArray;function d(k,R,A){return Promise.all(R.map(function(P){return o(k,P,A,P)}))}function f(k){return k&&typeof k=="object"}function g(k,R,A){var P={},U=Object.keys(R).map(function(H){if(A.only&&A.only.indexOf(H)===-1)return null;var G=R[H];return o(k,G,A,G).then(function(q){P[H]=q})});return Promise.all(U).then(function(){return P})}var y=r(/\.json(\?.*)?$/i);function w(k,R,A){var P=s(A.from,R);return o(k,o.fetch(P,"text").then(JSON.parse),A)}var $=r(/^data:audio/);function S(k,R,A){var P=R.indexOf(",");return o(k,e.decode(R.slice(P+1)).buffer,A)}var T=r(/\.js(\?.*)?$/i);function C(k,R,A){var P=s(A.from,R);return o(k,o.fetch(P,"text").then(_),A)}function _(k){var R=k.indexOf("MIDI.Soundfont.");if(R<0)throw Error("Invalid MIDI.js Soundfont format");R=k.indexOf("=",R)+2;var A=k.lastIndexOf(",");return JSON.parse(k.slice(R,A)+"}")}n.exports&&(n.exports=o),typeof window!="undefined"&&(window.loadAudio=o)})(Dm);var Pm={exports:{}},AO=OO;function OO(n){var e=n.createGain(),t=e._voltage=PO(n),r=pr(t),s=pr(t),o=pr(t);return e._startAmount=pr(s),e._endAmount=pr(o),e._multiplier=pr(r),e._multiplier.connect(e),e._startAmount.connect(e),e._endAmount.connect(e),e.value=r.gain,e.startValue=s.gain,e.endValue=o.gain,e.startValue.value=0,e.endValue.value=0,Object.defineProperties(e,FO),e}var FO={attack:{value:0,writable:!0},decay:{value:0,writable:!0},sustain:{value:1,writable:!0},release:{value:0,writable:!0},getReleaseDuration:{value:function(){return this.release}},start:{value:function(n){var e=this._multiplier.gain,t=this._startAmount.gain,r=this._endAmount.gain;this._voltage.start(n),this._decayFrom=this._decayFrom=n+this.attack,this._startedAt=n;var s=this.sustain;e.cancelScheduledValues(n),t.cancelScheduledValues(n),r.cancelScheduledValues(n),r.setValueAtTime(0,n),this.attack?(e.setValueAtTime(0,n),e.linearRampToValueAtTime(1,n+this.attack),t.setValueAtTime(1,n),t.linearRampToValueAtTime(0,n+this.attack)):(e.setValueAtTime(1,n),t.setValueAtTime(0,n)),this.decay&&e.setTargetAtTime(s,this._decayFrom,hc(this.decay))}},stop:{value:function(n,e){e&&(n=n-this.release);var t=n+this.release;if(this.release){var r=this._multiplier.gain,s=this._startAmount.gain,o=this._endAmount.gain;r.cancelScheduledValues(n),s.cancelScheduledValues(n),o.cancelScheduledValues(n);var a=hc(this.release);if(this.attack&&n<this._decayFrom){var i=LO(0,1,this._startedAt,this._decayFrom,n);r.linearRampToValueAtTime(i,n),s.linearRampToValueAtTime(1-i,n),s.setTargetAtTime(0,n,a)}o.setTargetAtTime(1,n,a),r.setTargetAtTime(0,n,a)}return this._voltage.stop(t),t}},onended:{get:function(){return this._voltage.onended},set:function(n){this._voltage.onended=n}}},DO=new Float32Array([1,1]);function PO(n){var e=n.createBufferSource(),t=n.createBuffer(1,2,n.sampleRate);return t.getChannelData(0).set(DO),e.buffer=t,e.loop=!0,e}function pr(n){var e=n.context.createGain();return n.connect(e),e}function hc(n){return Math.log(n+1)/Math.log(100)}function LO(n,e,t,r,s){var o=e-n,a=r-t,i=s-t,u=i/a,c=n+u*o;return c<=n&&(c=n),c>=e&&(c=e),c}var BO=AO,MO={},VO={gain:1,attack:.01,decay:.1,sustain:.9,release:.3,loop:!1,cents:0,loopStart:0,loopEnd:0};function UO(n,e,t){var r=!1,s=0,o={},a=n.createGain();a.gain.value=1;var i=Object.assign({},VO,t),u={context:n,out:a,opts:i};return e instanceof AudioBuffer?u.buffer=e:u.buffers=e,u.start=function(l,p,d){if(u.buffer&&l!==null)return u.start(null,l,p);var f=l?u.buffers[l]:u.buffer;if(f){if(!r){console.warn("SamplePlayer not connected to any node.");return}}else{console.warn("Buffer "+l+" not found.");return}var g=d||MO;p=Math.max(n.currentTime,p||0),u.emit("start",p,l,g);var y=h(l,f,g);return y.id=c(l,y),y.env.start(p),y.source.start(p),u.emit("started",p,y.id,y),g.duration&&y.stop(p+g.duration),y},u.play=function(l,p,d){return u.start(l,p,d)},u.stop=function(l,p){var d;return p=p||Object.keys(o),p.map(function(f){return d=o[f],d?(d.stop(l),d.id):null})},u.connect=function(l){return r=!0,a.connect(l),u},u.emit=function(l,p,d,f){u.onevent&&u.onevent(l,p,d,f);var g=u["on"+l];g&&g(p,d,f)},u;function c(l,p){return p.id=s++,o[p.id]=p,p.source.onended=function(){var d=n.currentTime;p.source.disconnect(),p.env.disconnect(),p.disconnect(),u.emit("ended",d,p.id,p)},p.id}function h(l,p,d){var f=n.createGain();return f.gain.value=0,f.connect(a),f.env=zO(n,d,i),f.env.connect(f.gain),f.source=n.createBufferSource(),f.source.buffer=p,f.source.connect(f),f.source.loop=d.loop||i.loop,f.source.playbackRate.value=GO(d.cents||i.cents),f.source.loopStart=d.loopStart||i.loopStart,f.source.loopEnd=d.loopEnd||i.loopEnd,f.stop=function(g){var y=g||n.currentTime;u.emit("stop",y,l);var w=f.env.stop(y);f.source.stop(w)},f}}function pc(n){return typeof n=="number"}var WO=["attack","decay","sustain","release"];function zO(n,e,t){var r=BO(n),s=e.adsr||t.adsr;return WO.forEach(function(o,a){s?r[o]=s[a]:r[o]=e[o]||t[o]}),r.value.value=pc(e.gain)?e.gain:pc(t.gain)?t.gain:1,r}function GO(n){return n?Math.pow(2,n/1200):1}var HO=UO,jO=function(n){return n.on=function(e,t){if(arguments.length===1&&typeof e=="function")return n.on("event",e);var r="on"+e,s=n[r];return n[r]=s?KO(s,t):t,n},n};function KO(n,e){return function(t,r,s,o){n(t,r,s,o),e(t,r,s,o)}}var Lm=/^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/;function XO(){return Lm}var qO=[0,2,4,5,7,9,11];function Bm(n,e,t){if(typeof n!="string")return null;var r=Lm.exec(n);if(!r||!e&&r[4])return null;var s={letter:r[1].toUpperCase(),acc:r[2].replace(/x/g,"##")};return s.pc=s.letter+s.acc,s.step=(s.letter.charCodeAt(0)+3)%7,s.alt=s.acc[0]==="b"?-s.acc.length:s.acc.length,s.chroma=qO[s.step]+s.alt,r[3]&&(s.oct=+r[3],s.midi=s.chroma+12*(s.oct+1),s.freq=Mm(s.midi,t)),e&&(s.tonicOf=r[4]),s}function Mm(n,e){return Math.pow(2,(n-69)/12)*(e||440)}var Vm={parse:Bm,regex:XO,midiToFreq:Mm},YO=["letter","acc","pc","step","alt","chroma","oct","midi","freq"];YO.forEach(function(n){Vm[n]=function(e){var t=Bm(e);return t&&typeof t[n]!="undefined"?t[n]:null}});var QO=Vm,ZO=QO,JO=function(n){return n!==null&&n!==[]&&n>=0&&n<129},eF=function(n){return JO(n)?+n:ZO.midi(n)},tF=function(n){if(n.buffers){var e=n.opts.map,t=typeof e=="function"?e:eF,r=function(o){return o?t(o)||o:null};n.buffers=nF(n.buffers,r);var s=n.start;n.start=function(o,a,i){var u=r(o),c=u%1;return c&&(u=Math.floor(u),i=Object.assign(i||{},{cents:Math.floor(c*100)})),s(u,a,i)}}return n};function nF(n,e){return Object.keys(n).reduce(function(t,r){return t[e(r)]=n[r],t},{})}var rF=Array.isArray,sF=function(n){return n&&typeof n=="object"},oF={},aF=function(n){return n.schedule=function(e,t){var r=n.context.currentTime,s=e<r?r:e;n.emit("schedule",s,t);var o,a,i,u;return t.map(function(c){if(c)rF(c)?(o=c[0],a=c[1]):(o=c.time,a=c);else return null;return sF(a)?(i=a.name||a.key||a.note||a.midi||null,u=a):(i=a,u=oF),n.start(i,s+(o||0),u)})},n},Um={exports:{}};(function(n,e){(function(t){n.exports=t()})(function(){return function t(r,s,o){function a(c,h){if(!s[c]){if(!r[c]){var l=typeof _s=="function"&&_s;if(!h&&l)return l(c,!0);if(i)return i(c,!0);var p=new Error("Cannot find module '"+c+"'");throw p.code="MODULE_NOT_FOUND",p}var d=s[c]={exports:{}};r[c][0].call(d.exports,function(f){var g=r[c][1][f];return a(g||f)},d,d.exports,t,r,s,o)}return s[c].exports}for(var i=typeof _s=="function"&&_s,u=0;u<o.length;u++)a(o[u]);return a}({1:[function(t,r,s){Object.defineProperty(s,"__esModule",{value:!0}),s.default=function(o){function a(i){if(this._event=i,this._data=i.data,this.receivedTime=i.receivedTime,this._data&&this._data.length<2){console.warn("Illegal MIDI message of length",this._data.length);return}switch(this._messageCode=i.data[0]&240,this.channel=i.data[0]&15,this._messageCode){case 128:this.messageType="noteoff",this.key=i.data[1]&127,this.velocity=i.data[2]&127;break;case 144:this.messageType="noteon",this.key=i.data[1]&127,this.velocity=i.data[2]&127;break;case 160:this.messageType="keypressure",this.key=i.data[1]&127,this.pressure=i.data[2]&127;break;case 176:this.messageType="controlchange",this.controllerNumber=i.data[1]&127,this.controllerValue=i.data[2]&127,this.controllerNumber===120&&this.controllerValue===0?this.channelModeMessage="allsoundoff":this.controllerNumber===121?this.channelModeMessage="resetallcontrollers":this.controllerNumber===122?this.controllerValue===0?this.channelModeMessage="localcontroloff":this.channelModeMessage="localcontrolon":this.controllerNumber===123&&this.controllerValue===0?this.channelModeMessage="allnotesoff":this.controllerNumber===124&&this.controllerValue===0?this.channelModeMessage="omnimodeoff":this.controllerNumber===125&&this.controllerValue===0?this.channelModeMessage="omnimodeon":this.controllerNumber===126?this.channelModeMessage="monomodeon":this.controllerNumber===127&&(this.channelModeMessage="polymodeon");break;case 192:this.messageType="programchange",this.program=i.data[1];break;case 208:this.messageType="channelpressure",this.pressure=i.data[1]&127;break;case 224:this.messageType="pitchbendchange";var u=i.data[2]&127,c=i.data[1]&127;this.pitchBend=(u<<8)+c;break}}return new a(o)},r.exports=s.default},{}]},{},[1])(1)})})(Um);var iF=Um.exports,uF=function(n){return n.listenToMidi=function(e,t){var r={},s=t||{},o=s.gain||function(a){return a/127};return e.onmidimessage=function(a){var i=a.messageType?a:iF(a);if(i.messageType==="noteon"&&i.velocity===0&&(i.messageType="noteoff"),!(s.channel&&i.channel!==s.channel))switch(i.messageType){case"noteon":r[i.key]=n.play(i.key,0,{gain:o(i.velocity)});break;case"noteoff":r[i.key]&&(r[i.key].stop(),delete r[i.key]);break}},n},n};(function(n){var e=HO,t=jO,r=tF,s=aF,o=uF;function a(i,u,c){return o(s(r(t(e(i,u,c)))))}n.exports&&(n.exports=a),typeof window!="undefined"&&(window.SamplePlayer=a)})(Pm);function dc(n,e){return Array(e+1).join(n)}function Li(n){return typeof n=="number"}function cF(n){return typeof n=="string"}function lF(n){return typeof n!="undefined"}function Wm(n,e){return Math.pow(2,(n-69)/12)*(e||440)}var zm=/^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/;function hF(){return zm}var pF=[0,2,4,5,7,9,11];function mn(n,e,t){if(typeof n!="string")return null;var r=zm.exec(n);if(!r||!e&&r[4])return null;var s={letter:r[1].toUpperCase(),acc:r[2].replace(/x/g,"##")};s.pc=s.letter+s.acc,s.step=(s.letter.charCodeAt(0)+3)%7,s.alt=s.acc[0]==="b"?-s.acc.length:s.acc.length;var o=pF[s.step]+s.alt;return s.chroma=o<0?12+o:o%12,r[3]&&(s.oct=+r[3],s.midi=o+12*(s.oct+1),s.freq=Wm(s.midi,t)),e&&(s.tonicOf=r[4]),s}var dF="CDEFGAB";function fF(n){return Li(n)?n<0?dc("b",-n):dc("#",n):""}function mF(n){return Li(n)?""+n:""}function Gm(n,e,t){return n===null||typeof n=="undefined"?null:n.step?Gm(n.step,n.alt,n.oct):n<0||n>6?null:dF.charAt(n)+fF(e)+mF(t)}function Hm(n){if((Li(n)||cF(n))&&n>=0&&n<128)return+n;var e=mn(n);return e&&lF(e.midi)?e.midi:null}function gF(n,e){var t=Hm(n);return t===null?null:Wm(t,e)}function yF(n){return(mn(n)||{}).letter}function xF(n){return(mn(n)||{}).acc}function bF(n){return(mn(n)||{}).pc}function vF(n){return(mn(n)||{}).step}function wF(n){return(mn(n)||{}).alt}function $F(n){return(mn(n)||{}).chroma}function SF(n){return(mn(n)||{}).oct}var TF=Object.freeze(Object.defineProperty({__proto__:null,regex:hF,parse:mn,build:Gm,midi:Hm,freq:gF,letter:yF,acc:xF,pc:bF,step:vF,alt:wF,chroma:$F,oct:SF},Symbol.toStringTag,{value:"Module"})),CF=yy(TF),Ba=CF;function tn(n,e){if(console.warn("new Soundfont() is deprected"),console.log("Please use Soundfont.instrument() instead of new Soundfont().instrument()"),!(this instanceof tn))return new tn(n);this.nameToUrl=e||tn.nameToUrl,this.ctx=n,this.instruments={},this.promises=[]}tn.prototype.onready=function(n){console.warn("deprecated API"),console.log("Please use Promise.all(Soundfont.instrument(), Soundfont.instrument()).then() instead of new Soundfont().onready()"),Promise.all(this.promises).then(n)};tn.prototype.instrument=function(n,e){console.warn("new Soundfont().instrument() is deprecated."),console.log("Please use Soundfont.instrument() instead.");var t=this.ctx;if(n=n||"default",n in this.instruments)return this.instruments[n];var r={name:n,play:EF(t,e)};if(this.instruments[n]=r,n!=="default"){var s=tn.instrument(t,n,e).then(function(o){return r.play=o.play,r});this.promises.push(s),r.onready=function(o){console.warn("onready is deprecated. Use Soundfont.instrument().then()"),s.then(o)}}else r.onready=function(o){console.warn("onready is deprecated. Use Soundfont.instrument().then()"),o()};return r};function NF(n,e,t){return console.warn("Soundfont.loadBuffers is deprecate."),console.log("Use Soundfont.instrument(..) and get buffers properties from the result."),tn.instrument(n,e,t).then(function(r){return r.buffers})}tn.loadBuffers=NF;function EF(n,e){return e=e||{},function(t,r,s,o){console.warn("The oscillator player is deprecated."),console.log("Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.");var a=t>0&&t<129?+t:Ba.midi(t),i=a?Ba.midiToFreq(a,440):null;if(!!i){s=s||.2,o=o||{};var u=o.destination||e.destination||n.destination,c=o.vcoType||e.vcoType||"sine",h=o.gain||e.gain||.4,l=n.createOscillator();l.type=c,l.frequency.value=i;var p=n.createGain();return p.gain.value=h,l.connect(p),p.connect(u),l.start(r),s>0&&l.stop(r+s),l}}}tn.noteToMidi=Ba.midi;var kF=tn;(function(n){var e=Dm.exports,t=Pm.exports;function r(i,u,c){if(arguments.length===1)return function(f,g){return r(i,f,g)};var h=c||{},l=h.isSoundfontURL||s,p=h.nameToUrl||o,d=l(u)?u:p(u,h.soundfont,h.format);return e(i,d,{only:h.only||h.notes}).then(function(f){var g=t(i,f,h).connect(h.destination?h.destination:i.destination);return g.url=d,g.name=u,g})}function s(i){return/\.js(\?.*)?$/i.test(i)}function o(i,u,c){return c=c==="ogg"?c:"mp3",u=u==="FluidR3_GM"?u:"MusyngKite","https://gleitz.github.io/midi-js-soundfonts/"+u+"/"+i+"-"+c+".js"}var a=kF;a.instrument=r,a.nameToUrl=o,n.exports&&(n.exports=a),typeof window!="undefined"&&(window.Soundfont=a)})(EO);var IF={};(function(){var n;function e(m){var b=0;return function(){return b<m.length?{done:!1,value:m[b++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(m,b,v){return m==Array.prototype||m==Object.prototype||(m[b]=v.value),m};function r(m){m=[typeof globalThis=="object"&&globalThis,m,typeof window=="object"&&window,typeof self=="object"&&self,typeof hn=="object"&&hn];for(var b=0;b<m.length;++b){var v=m[b];if(v&&v.Math==Math)return v}throw Error("Cannot find global object")}var s=r(this);function o(m,b){if(b)e:{var v=s;m=m.split(".");for(var E=0;E<m.length-1;E++){var D=m[E];if(!(D in v))break e;v=v[D]}m=m[m.length-1],E=v[m],b=b(E),b!=E&&b!=null&&t(v,m,{configurable:!0,writable:!0,value:b})}}o("Symbol",function(m){function b(V){if(this instanceof b)throw new TypeError("Symbol is not a constructor");return new v(E+(V||"")+"_"+D++,V)}function v(V,L){this.g=V,t(this,"description",{configurable:!0,writable:!0,value:L})}if(m)return m;v.prototype.toString=function(){return this.g};var E="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",D=0;return b}),o("Symbol.iterator",function(m){if(m)return m;m=Symbol("Symbol.iterator");for(var b="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),v=0;v<b.length;v++){var E=s[b[v]];typeof E=="function"&&typeof E.prototype[m]!="function"&&t(E.prototype,m,{configurable:!0,writable:!0,value:function(){return a(e(this))}})}return m});function a(m){return m={next:m},m[Symbol.iterator]=function(){return this},m}function i(m){var b=typeof Symbol!="undefined"&&Symbol.iterator&&m[Symbol.iterator];return b?b.call(m):{next:e(m)}}function u(m){if(!(m instanceof Array)){m=i(m);for(var b,v=[];!(b=m.next()).done;)v.push(b.value);m=v}return m}var c=typeof Object.create=="function"?Object.create:function(m){function b(){}return b.prototype=m,new b},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var l;e:{var p={a:!0},d={};try{d.__proto__=p,l=d.a;break e}catch{}l=!1}h=l?function(m,b){if(m.__proto__=b,m.__proto__!==b)throw new TypeError(m+" is not extensible");return m}:null}var f=h;function g(m,b){if(m.prototype=c(b.prototype),m.prototype.constructor=m,f)f(m,b);else for(var v in b)if(v!="prototype")if(Object.defineProperties){var E=Object.getOwnPropertyDescriptor(b,v);E&&Object.defineProperty(m,v,E)}else m[v]=b[v];m.ea=b.prototype}function y(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function w(m){if(m.l)throw new TypeError("Generator is already running");m.l=!0}y.prototype.o=function(m){this.h=m};function $(m,b){m.j={U:b,V:!0},m.g=m.m||m.s}y.prototype.return=function(m){this.j={return:m},this.g=this.s};function S(m,b,v){return m.g=v,{value:b}}function T(m){this.g=new y,this.h=m}function C(m,b){w(m.g);var v=m.g.i;return v?_(m,"return"in v?v.return:function(E){return{value:E,done:!0}},b,m.g.return):(m.g.return(b),k(m))}function _(m,b,v,E){try{var D=b.call(m.g.i,v);if(!(D instanceof Object))throw new TypeError("Iterator result "+D+" is not an object");if(!D.done)return m.g.l=!1,D;var V=D.value}catch(L){return m.g.i=null,$(m.g,L),k(m)}return m.g.i=null,E.call(m.g,V),k(m)}function k(m){for(;m.g.g;)try{var b=m.h(m.g);if(b)return m.g.l=!1,{value:b.value,done:!1}}catch(v){m.g.h=void 0,$(m.g,v)}if(m.g.l=!1,m.g.j){if(b=m.g.j,m.g.j=null,b.V)throw b.U;return{value:b.return,done:!0}}return{value:void 0,done:!0}}function R(m){this.next=function(b){return w(m.g),m.g.i?b=_(m,m.g.i.next,b,m.g.o):(m.g.o(b),b=k(m)),b},this.throw=function(b){return w(m.g),m.g.i?b=_(m,m.g.i.throw,b,m.g.o):($(m.g,b),b=k(m)),b},this.return=function(b){return C(m,b)},this[Symbol.iterator]=function(){return this}}function A(m,b){return b=new R(new T(b)),f&&m.prototype&&f(b,m.prototype),b}function P(m,b){m instanceof String&&(m+="");var v=0,E=!1,D={next:function(){if(!E&&v<m.length){var V=v++;return{value:b(V,m[V]),done:!1}}return E=!0,{done:!0,value:void 0}}};return D[Symbol.iterator]=function(){return D},D}var U=typeof Object.assign=="function"?Object.assign:function(m,b){for(var v=1;v<arguments.length;v++){var E=arguments[v];if(E)for(var D in E)Object.prototype.hasOwnProperty.call(E,D)&&(m[D]=E[D])}return m};o("Object.assign",function(m){return m||U}),o("Promise",function(m){function b(L){this.h=0,this.i=void 0,this.g=[],this.o=!1;var M=this.j();try{L(M.resolve,M.reject)}catch(z){M.reject(z)}}function v(){this.g=null}function E(L){return L instanceof b?L:new b(function(M){M(L)})}if(m)return m;v.prototype.h=function(L){if(this.g==null){this.g=[];var M=this;this.i(function(){M.l()})}this.g.push(L)};var D=s.setTimeout;v.prototype.i=function(L){D(L,0)},v.prototype.l=function(){for(;this.g&&this.g.length;){var L=this.g;this.g=[];for(var M=0;M<L.length;++M){var z=L[M];L[M]=null;try{z()}catch(Y){this.j(Y)}}}this.g=null},v.prototype.j=function(L){this.i(function(){throw L})},b.prototype.j=function(){function L(Y){return function(re){z||(z=!0,Y.call(M,re))}}var M=this,z=!1;return{resolve:L(this.C),reject:L(this.l)}},b.prototype.C=function(L){if(L===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(L instanceof b)this.F(L);else{e:switch(typeof L){case"object":var M=L!=null;break e;case"function":M=!0;break e;default:M=!1}M?this.u(L):this.m(L)}},b.prototype.u=function(L){var M=void 0;try{M=L.then}catch(z){this.l(z);return}typeof M=="function"?this.G(M,L):this.m(L)},b.prototype.l=function(L){this.s(2,L)},b.prototype.m=function(L){this.s(1,L)},b.prototype.s=function(L,M){if(this.h!=0)throw Error("Cannot settle("+L+", "+M+"): Promise already settled in state"+this.h);this.h=L,this.i=M,this.h===2&&this.D(),this.A()},b.prototype.D=function(){var L=this;D(function(){if(L.B()){var M=s.console;typeof M!="undefined"&&M.error(L.i)}},1)},b.prototype.B=function(){if(this.o)return!1;var L=s.CustomEvent,M=s.Event,z=s.dispatchEvent;return typeof z=="undefined"?!0:(typeof L=="function"?L=new L("unhandledrejection",{cancelable:!0}):typeof M=="function"?L=new M("unhandledrejection",{cancelable:!0}):(L=s.document.createEvent("CustomEvent"),L.initCustomEvent("unhandledrejection",!1,!0,L)),L.promise=this,L.reason=this.i,z(L))},b.prototype.A=function(){if(this.g!=null){for(var L=0;L<this.g.length;++L)V.h(this.g[L]);this.g=null}};var V=new v;return b.prototype.F=function(L){var M=this.j();L.J(M.resolve,M.reject)},b.prototype.G=function(L,M){var z=this.j();try{L.call(M,z.resolve,z.reject)}catch(Y){z.reject(Y)}},b.prototype.then=function(L,M){function z(he,oe){return typeof he=="function"?function(Z){try{Y(he(Z))}catch(se){re(se)}}:oe}var Y,re,Ce=new b(function(he,oe){Y=he,re=oe});return this.J(z(L,Y),z(M,re)),Ce},b.prototype.catch=function(L){return this.then(void 0,L)},b.prototype.J=function(L,M){function z(){switch(Y.h){case 1:L(Y.i);break;case 2:M(Y.i);break;default:throw Error("Unexpected state: "+Y.h)}}var Y=this;this.g==null?V.h(z):this.g.push(z),this.o=!0},b.resolve=E,b.reject=function(L){return new b(function(M,z){z(L)})},b.race=function(L){return new b(function(M,z){for(var Y=i(L),re=Y.next();!re.done;re=Y.next())E(re.value).J(M,z)})},b.all=function(L){var M=i(L),z=M.next();return z.done?E([]):new b(function(Y,re){function Ce(Z){return function(se){he[Z]=se,oe--,oe==0&&Y(he)}}var he=[],oe=0;do he.push(void 0),oe++,E(z.value).J(Ce(he.length-1),re),z=M.next();while(!z.done)})},b}),o("Object.is",function(m){return m||function(b,v){return b===v?b!==0||1/b===1/v:b!==b&&v!==v}}),o("Array.prototype.includes",function(m){return m||function(b,v){var E=this;E instanceof String&&(E=String(E));var D=E.length;for(v=v||0,0>v&&(v=Math.max(v+D,0));v<D;v++){var V=E[v];if(V===b||Object.is(V,b))return!0}return!1}}),o("String.prototype.includes",function(m){return m||function(b,v){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(b,v||0)!==-1}}),o("Array.prototype.keys",function(m){return m||function(){return P(this,function(b){return b})}});var H=this||self;function G(m,b){m=m.split(".");var v=H;m[0]in v||typeof v.execScript=="undefined"||v.execScript("var "+m[0]);for(var E;m.length&&(E=m.shift());)m.length||b===void 0?v[E]&&v[E]!==Object.prototype[E]?v=v[E]:v=v[E]={}:v[E]=b}function q(m,b){return b=String.fromCharCode.apply(null,b),m==null?b:m+b}var te,ne=typeof TextDecoder!="undefined",ue,ze=typeof TextEncoder!="undefined";function Le(m){if(ze)m=(ue||(ue=new TextEncoder)).encode(m);else{var b=void 0;b=b===void 0?!1:b;for(var v=0,E=new Uint8Array(3*m.length),D=0;D<m.length;D++){var V=m.charCodeAt(D);if(128>V)E[v++]=V;else{if(2048>V)E[v++]=V>>6|192;else{if(55296<=V&&57343>=V){if(56319>=V&&D<m.length){var L=m.charCodeAt(++D);if(56320<=L&&57343>=L){V=1024*(V-55296)+L-56320+65536,E[v++]=V>>18|240,E[v++]=V>>12&63|128,E[v++]=V>>6&63|128,E[v++]=V&63|128;continue}else D--}if(b)throw Error("Found an unpaired surrogate");V=65533}E[v++]=V>>12|224,E[v++]=V>>6&63|128}E[v++]=V&63|128}}m=E.subarray(0,v)}return m}var nt={},Ct=null;function sr(m,b){b===void 0&&(b=0),or(),b=nt[b];for(var v=Array(Math.floor(m.length/3)),E=b[64]||"",D=0,V=0;D<m.length-2;D+=3){var L=m[D],M=m[D+1],z=m[D+2],Y=b[L>>2];L=b[(L&3)<<4|M>>4],M=b[(M&15)<<2|z>>6],z=b[z&63],v[V++]=Y+L+M+z}switch(Y=0,z=E,m.length-D){case 2:Y=m[D+1],z=b[(Y&15)<<2]||E;case 1:m=m[D],v[V]=b[m>>2]+b[(m&3)<<4|Y>>4]+z+E}return v.join("")}function Ur(m){var b=m.length,v=3*b/4;v%3?v=Math.floor(v):"=.".indexOf(m[b-1])!=-1&&(v="=.".indexOf(m[b-2])!=-1?v-2:v-1);var E=new Uint8Array(v),D=0;return Co(m,function(V){E[D++]=V}),E.subarray(0,D)}function Co(m,b){function v(z){for(;E<m.length;){var Y=m.charAt(E++),re=Ct[Y];if(re!=null)return re;if(!/^[\s\xa0]*$/.test(Y))throw Error("Unknown base64 encoding at char: "+Y)}return z}or();for(var E=0;;){var D=v(-1),V=v(0),L=v(64),M=v(64);if(M===64&&D===-1)break;b(D<<2|V>>4),L!=64&&(b(V<<4&240|L>>2),M!=64&&b(L<<6&192|M))}}function or(){if(!Ct){Ct={};for(var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],v=0;5>v;v++){var E=m.concat(b[v].split(""));nt[v]=E;for(var D=0;D<E.length;D++){var V=E[D];Ct[V]===void 0&&(Ct[V]=D)}}}}var Ns=typeof Uint8Array.prototype.slice=="function",Vi;function Ui(m,b,v){return b===v?Vi||(Vi=new Uint8Array(0)):Ns?m.slice(b,v):new Uint8Array(m.subarray(b,v))}var an=0,gn=0;function Wi(m,b){b=b===void 0?{}:b,b=b.v===void 0?!1:b.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=b,m&&zi(this,m)}function zi(m,b){b=b.constructor===Uint8Array?b:b.constructor===ArrayBuffer?new Uint8Array(b):b.constructor===Array?new Uint8Array(b):b.constructor===String?Ur(b):b instanceof Uint8Array?new Uint8Array(b.buffer,b.byteOffset,b.byteLength):new Uint8Array(0),m.h=b,m.j=0,m.i=m.h.length,m.g=m.j}Wi.prototype.reset=function(){this.g=this.j};function Wr(m){var b=m.h,v=b[m.g],E=v&127;return 128>v?(m.g+=1,E):(v=b[m.g+1],E|=(v&127)<<7,128>v?(m.g+=2,E):(v=b[m.g+2],E|=(v&127)<<14,128>v?(m.g+=3,E):(v=b[m.g+3],E|=(v&127)<<21,128>v?(m.g+=4,E):(v=b[m.g+4],E|=(v&15)<<28,128>v?(m.g+=5,E>>>0):(m.g+=5,128<=b[m.g++]&&128<=b[m.g++]&&128<=b[m.g++]&&128<=b[m.g++]&&m.g++,E)))))}function Wt(m){var b=m.h[m.g],v=m.h[m.g+1],E=m.h[m.g+2],D=m.h[m.g+3];return m.g+=4,v=(b<<0|v<<8|E<<16|D<<24)>>>0,m=2*(v>>31)+1,b=v>>>23&255,v&=8388607,b==255?v?NaN:1/0*m:b==0?m*Math.pow(2,-149)*v:m*Math.pow(2,b-150)*(v+Math.pow(2,23))}var Gi=[];function Es(){this.g=new Uint8Array(64),this.h=0}Es.prototype.push=function(m){if(!(this.h+1<this.g.length)){var b=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(b)}this.g[this.h++]=m},Es.prototype.length=function(){return this.h},Es.prototype.end=function(){var m=this.g,b=this.h;return this.h=0,Ui(m,0,b)};function yn(m,b){for(;127<b;)m.push(b&127|128),b>>>=7;m.push(b)}function ks(m){var b={},v=b.N===void 0?!1:b.N;this.o={v:b.v===void 0?!1:b.v},this.N=v,b=this.o,Gi.length?(v=Gi.pop(),b&&(v.v=b.v),m&&zi(v,m),m=v):m=new Wi(m,b),this.g=m,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}ks.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function ar(m){var b=m.g;if((b=b.g==b.i)||(b=m.j)||(b=m.g,b=b.l||0>b.g||b.g>b.i),b)return!1;m.m=m.g.g,b=Wr(m.g);var v=b&7;return v!=0&&v!=5&&v!=1&&v!=2&&v!=3&&v!=4?(m.j=!0,!1):(m.i=b,m.l=b>>>3,m.h=v,!0)}function ir(m){switch(m.h){case 0:if(m.h!=0)ir(m);else{for(m=m.g;m.h[m.g]&128;)m.g++;m.g++}break;case 1:m.h!=1?ir(m):(m=m.g,m.g+=8);break;case 2:if(m.h!=2)ir(m);else{var b=Wr(m.g);m=m.g,m.g+=b}break;case 5:m.h!=5?ir(m):(m=m.g,m.g+=4);break;case 3:b=m.l;do{if(!ar(m)){m.j=!0;break}if(m.h==4){m.l!=b&&(m.j=!0);break}ir(m)}while(1);break;default:m.j=!0}}function Hi(m,b,v){var E=m.g.i,D=Wr(m.g),V=m.g.g+D;if(m.g.i=V,v(b,m),v=V-m.g.g,v!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+D+" bytes, instead read "+(D-v)+" bytes, either the data ended unexpectedly or the message misreported its own length");return m.g.g=V,m.g.i=E,b}function ji(m){var b=Wr(m.g);m=m.g;var v=m.g;m.g+=b,m=m.h;var E;if(ne)(E=te)||(E=te=new TextDecoder("utf-8",{fatal:!1})),E=E.decode(m.subarray(v,v+b));else{b=v+b;for(var D=[],V=null,L,M,z;v<b;)L=m[v++],128>L?D.push(L):224>L?v>=b?D.push(65533):(M=m[v++],194>L||(M&192)!==128?(v--,D.push(65533)):D.push((L&31)<<6|M&63)):240>L?v>=b-1?D.push(65533):(M=m[v++],(M&192)!==128||L===224&&160>M||L===237&&160<=M||((E=m[v++])&192)!==128?(v--,D.push(65533)):D.push((L&15)<<12|(M&63)<<6|E&63)):244>=L?v>=b-2?D.push(65533):(M=m[v++],(M&192)!==128||(L<<28)+(M-144)>>30!==0||((E=m[v++])&192)!==128||((z=m[v++])&192)!==128?(v--,D.push(65533)):(L=(L&7)<<18|(M&63)<<12|(E&63)<<6|z&63,L-=65536,D.push((L>>10&1023)+55296,(L&1023)+56320))):D.push(65533),8192<=D.length&&(V=q(V,D),D.length=0);E=q(V,D)}return E}function No(){this.h=[],this.i=0,this.g=new Es}function ur(m,b){b.length!==0&&(m.h.push(b),m.i+=b.length)}function Eo(m){var b=m.i+m.g.length();if(b===0)return new Uint8Array(0);b=new Uint8Array(b);for(var v=m.h,E=v.length,D=0,V=0;V<E;V++){var L=v[V];L.length!==0&&(b.set(L,D),D+=L.length)}return v=m.g,E=v.h,E!==0&&(b.set(v.g.subarray(0,E),D),v.h=0),m.h=[b],b}function zt(m,b,v){if(v!=null){yn(m.g,8*b+5),m=m.g;var E=v;E=(v=0>E?1:0)?-E:E,E===0?0<1/E?an=gn=0:(gn=0,an=2147483648):isNaN(E)?(gn=0,an=2147483647):34028234663852886e22<E?(gn=0,an=(v<<31|2139095040)>>>0):11754943508222875e-54>E?(E=Math.round(E/Math.pow(2,-149)),gn=0,an=(v<<31|E)>>>0):(b=Math.floor(Math.log(E)/Math.LN2),E*=Math.pow(2,-b),E=Math.round(8388608*E),16777216<=E&&++b,gn=0,an=(v<<31|b+127<<23|E&8388607)>>>0),v=an,m.push(v>>>0&255),m.push(v>>>8&255),m.push(v>>>16&255),m.push(v>>>24&255)}}var Ki=typeof Uint8Array=="function";function Xi(m,b,v){if(m!=null)return typeof m=="object"?Ki&&m instanceof Uint8Array?v(m):qi(m,b,v):b(m)}function qi(m,b,v){if(Array.isArray(m)){for(var E=Array(m.length),D=0;D<m.length;D++)E[D]=Xi(m[D],b,v);return Array.isArray(m)&&m.W&&zr(E),E}E={};for(D in m)E[D]=Xi(m[D],b,v);return E}function fg(m){return typeof m=="number"?isFinite(m)?m:String(m):m}var mg={W:{value:!0,configurable:!0}};function zr(m){return Array.isArray(m)&&!Object.isFrozen(m)&&Object.defineProperties(m,mg),m}var Yi;function Nt(m,b,v){var E=Yi;Yi=null,m||(m=E),E=this.constructor.ca,m||(m=E?[E]:[]),this.j=E?0:-1,this.i=null,this.g=m;e:{if(E=this.g.length,m=E-1,E&&(E=this.g[m],!(E===null||typeof E!="object"||Array.isArray(E)||Ki&&E instanceof Uint8Array))){this.l=m-this.j,this.h=E;break e}b!==void 0&&-1<b?(this.l=Math.max(b,m+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(v)for(b=0;b<v.length;b++)m=v[b],m<this.l?(m+=this.j,(E=this.g[m])?zr(E):this.g[m]=Is):(Qi(this),(E=this.h[m])?zr(E):this.h[m]=Is)}var Is=Object.freeze(zr([]));function Qi(m){var b=m.l+m.j;m.g[b]||(m.h=m.g[b]={})}function Me(m,b,v){return b===-1?null:(v===void 0?0:v)||b>=m.l?m.h?m.h[b]:void 0:m.g[b+m.j]}function Zi(m){var b=b===void 0?!1:b,v=Me(m,1,b);return v==null&&(v=Is),v===Is&&(v=zr([]),Te(m,1,v,b)),v}function Jt(m,b,v){return m=Me(m,b),m=m==null?m:+m,m==null?v===void 0?0:v:m}function Te(m,b,v,E){(E===void 0?0:E)||b>=m.l?(Qi(m),m.h[b]=v):m.g[b+m.j]=v}function ko(m,b){m.i||(m.i={});var v=m.i[1];if(!v){var E=Zi(m);v=[];for(var D=0;D<E.length;D++)v[D]=new b(E[D]);m.i[1]=v}return v}function Ji(m,b,v,E){var D=ko(m,v);b=b||new v,m=Zi(m),E!=null?(D.splice(E,0,b),m.splice(E,0,cr(b))):(D.push(b),m.push(cr(b)))}Nt.prototype.toJSON=function(){var m=cr(this);return qi(m,fg,sr)};function cr(m,b){if(m.i)for(var v in m.i){var E=m.i[v];if(Array.isArray(E))for(var D=0;D<E.length;D++)E[D]&&cr(E[D]);else E&&cr(E)}return m.g}Nt.prototype.toString=function(){return cr(this).toString()};function eu(m,b){return m=Me(m,b),m==null?0:m}function tu(m,b){return m=Me(m,b),m==null?"":m}function Io(m,b){if(m=m.m){ur(b,b.g.end());for(var v=0;v<m.length;v++)ur(b,m[v])}}function Gr(m,b){if(b.h==4)return!1;var v=b.m;return ir(b),b.N||(b=Ui(b.g.h,v,b.g.g),(v=m.m)?v.push(b):m.m=[b]),!0}function rt(m,b){var v=void 0;return new(v||(v=Promise))(function(E,D){function V(z){try{M(b.next(z))}catch(Y){D(Y)}}function L(z){try{M(b.throw(z))}catch(Y){D(Y)}}function M(z){z.done?E(z.value):new v(function(Y){Y(z.value)}).then(V,L)}M((b=b.apply(m,void 0)).next())})}function Hr(m){Nt.call(this,m)}g(Hr,Nt);function gg(m,b){for(;ar(b);)switch(b.i){case 8:var v=Wr(b.g);Te(m,1,v);break;case 21:v=Wt(b.g),Te(m,2,v);break;case 26:v=ji(b),Te(m,3,v);break;case 34:v=ji(b),Te(m,4,v);break;default:if(!Gr(m,b))return m}return m}function Ro(m){Nt.call(this,m,-1,yg)}g(Ro,Nt),Ro.prototype.addClassification=function(m,b){return Ji(this,m,Hr,b),this};var yg=[1];function jr(m){Nt.call(this,m)}g(jr,Nt);function xg(m,b){for(;ar(b);)switch(b.i){case 13:var v=Wt(b.g);Te(m,1,v);break;case 21:v=Wt(b.g),Te(m,2,v);break;case 29:v=Wt(b.g),Te(m,3,v);break;case 37:v=Wt(b.g),Te(m,4,v);break;case 45:v=Wt(b.g),Te(m,5,v);break;default:if(!Gr(m,b))return m}return m}function nu(m){Nt.call(this,m,-1,bg)}g(nu,Nt);var bg=[1];function _o(m){Nt.call(this,m)}g(_o,Nt);function ru(m,b,v){if(v=m.createShader(v===0?m.VERTEX_SHADER:m.FRAGMENT_SHADER),m.shaderSource(v,b),m.compileShader(v),!m.getShaderParameter(v,m.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+m.getShaderInfoLog(v));return v}function vg(m){return ko(m,Hr).map(function(b){return{index:eu(b,1),Y:Jt(b,2),label:Me(b,3)!=null?tu(b,3):void 0,displayName:Me(b,4)!=null?tu(b,4):void 0}})}function wg(m){return{x:Jt(m,1),y:Jt(m,2),z:Jt(m,3),visibility:Me(m,4)!=null?Jt(m,4):void 0}}function Ao(m){e:{var b=new nu;for(m=new ks(m);ar(m);)switch(m.i){case 10:var v=Hi(m,new jr,xg);Ji(b,v,jr,void 0);break;default:if(!Gr(b,m))break e}}return ko(b,jr).map(wg)}function Oo(m,b){this.h=m,this.g=b,this.l=0}function su(m,b,v){return $g(m,b),typeof m.g.canvas.transferToImageBitmap=="function"?Promise.resolve(m.g.canvas.transferToImageBitmap()):v?Promise.resolve(m.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(m.g.canvas):(m.i===void 0&&(m.i=document.createElement("canvas")),new Promise(function(E){m.i.height=m.g.canvas.height,m.i.width=m.g.canvas.width,m.i.getContext("2d",{}).drawImage(m.g.canvas,0,0,m.g.canvas.width,m.g.canvas.height),E(m.i)}))}function $g(m,b){var v=m.g;if(m.m===void 0){var E=ru(v,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),D=ru(v,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),V=v.createProgram();if(v.attachShader(V,E),v.attachShader(V,D),v.linkProgram(V),!v.getProgramParameter(V,v.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+v.getProgramInfoLog(V));E=m.m=V,v.useProgram(E),D=v.getUniformLocation(E,"sampler0"),m.j={I:v.getAttribLocation(E,"aVertex"),H:v.getAttribLocation(E,"aTex"),da:D},m.s=v.createBuffer(),v.bindBuffer(v.ARRAY_BUFFER,m.s),v.enableVertexAttribArray(m.j.I),v.vertexAttribPointer(m.j.I,2,v.FLOAT,!1,0,0),v.bufferData(v.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),v.STATIC_DRAW),v.bindBuffer(v.ARRAY_BUFFER,null),m.o=v.createBuffer(),v.bindBuffer(v.ARRAY_BUFFER,m.o),v.enableVertexAttribArray(m.j.H),v.vertexAttribPointer(m.j.H,2,v.FLOAT,!1,0,0),v.bufferData(v.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),v.STATIC_DRAW),v.bindBuffer(v.ARRAY_BUFFER,null),v.uniform1i(D,0)}E=m.j,v.useProgram(m.m),v.canvas.width=b.width,v.canvas.height=b.height,v.viewport(0,0,b.width,b.height),v.activeTexture(v.TEXTURE0),m.h.bindTexture2d(b.glName),v.enableVertexAttribArray(E.I),v.bindBuffer(v.ARRAY_BUFFER,m.s),v.vertexAttribPointer(E.I,2,v.FLOAT,!1,0,0),v.enableVertexAttribArray(E.H),v.bindBuffer(v.ARRAY_BUFFER,m.o),v.vertexAttribPointer(E.H,2,v.FLOAT,!1,0,0),v.bindFramebuffer(v.DRAW_FRAMEBUFFER?v.DRAW_FRAMEBUFFER:v.FRAMEBUFFER,null),v.clearColor(0,0,0,0),v.clear(v.COLOR_BUFFER_BIT),v.colorMask(!0,!0,!0,!0),v.drawArrays(v.TRIANGLE_FAN,0,4),v.disableVertexAttribArray(E.I),v.disableVertexAttribArray(E.H),v.bindBuffer(v.ARRAY_BUFFER,null),m.h.bindTexture2d(0)}function Sg(m){this.g=m}var Tg=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Cg(m,b){return b+m}function ou(m,b){window[m]=b}function Ng(m){var b=document.createElement("script");return b.setAttribute("src",m),b.setAttribute("crossorigin","anonymous"),new Promise(function(v){b.addEventListener("load",function(){v()},!1),b.addEventListener("error",function(){v()},!1),document.body.appendChild(b)})}function Eg(){return rt(this,function m(){return A(m,function(b){switch(b.g){case 1:return b.m=2,S(b,WebAssembly.instantiate(Tg),4);case 4:b.g=3,b.m=0;break;case 2:return b.m=0,b.j=null,b.return(!1);case 3:return b.return(!0)}})})}function Fo(m){if(this.g=m,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=m&&m.locateFile||Cg,typeof window=="object")var b=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location!="undefined")b=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=b,m.options){b=i(Object.keys(m.options));for(var v=b.next();!v.done;v=b.next()){v=v.value;var E=m.options[v].default;E!==void 0&&(this.j[v]=typeof E=="function"?E():E)}}}n=Fo.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function kg(m,b){return m.g.files===void 0?[]:typeof m.g.files=="function"?m.g.files(b):m.g.files}function Ig(m){return rt(m,function b(){var v=this,E,D,V,L,M,z,Y,re,Ce,he,oe;return A(b,function(Z){switch(Z.g){case 1:return E=v,v.R?(D=kg(v,v.j),S(Z,Eg(),2)):Z.return();case 2:if(V=Z.h,typeof window=="object")return ou("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),ou("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),z=D.filter(function(se){return se.data!==void 0}),Y=D.filter(function(se){return se.data===void 0}),re=Promise.all(z.map(function(se){var le=Rs(E,se.url);if(se.path!==void 0){var de=se.path;le=le.then(function(qe){return E.overrideFile(de,qe),Promise.resolve(qe)})}return le})),Ce=Promise.all(Y.map(function(se){return se.simd===void 0||se.simd&&V||!se.simd&&!V?Ng(E.locateFile(se.url,E.S)):Promise.resolve()})).then(function(){return rt(E,function se(){var le,de,qe=this;return A(se,function(Ee){if(Ee.g==1)return le=window.createMediapipeSolutionsWasm,de=window.createMediapipeSolutionsPackedAssets,S(Ee,le(de),2);qe.h=Ee.h,Ee.g=0})})}),he=function(){return rt(E,function se(){var le=this;return A(se,function(de){return le.g.graph&&le.g.graph.url?de=S(de,Rs(le,le.g.graph.url),0):(de.g=0,de=void 0),de})})}(),S(Z,Promise.all([Ce,re,he]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return L=D.filter(function(se){return se.simd===void 0||se.simd&&V||!se.simd&&!V}).map(function(se){return E.locateFile(se.url,E.S)}),importScripts.apply(null,u(L)),S(Z,createMediapipeSolutionsWasm(Module),6);case 6:v.h=Z.h,v.l=new OffscreenCanvas(1,1),v.h.canvas=v.l,M=v.h.GL.createContext(v.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext!="undefined"?2:1}),v.h.GL.makeContextCurrent(M),Z.g=4;break;case 7:if(v.l=document.createElement("canvas"),oe=v.l.getContext("webgl2",{}),!oe&&(oe=v.l.getContext("webgl",{}),!oe))return alert("Failed to create WebGL canvas context when passing video frame."),Z.return();v.D=oe,v.h.canvas=v.l,v.h.createContext(v.l,!0,!0,{});case 4:v.i=new v.h.SolutionWasm,v.R=!1,Z.g=0}})})}function Rg(m){return rt(m,function b(){var v=this,E,D,V,L,M,z,Y,re;return A(b,function(Ce){if(Ce.g==1){if(v.g.graph&&v.g.graph.url&&v.P===v.g.graph.url)return Ce.return();if(v.o=!0,!v.g.graph||!v.g.graph.url){Ce.g=2;return}return v.P=v.g.graph.url,S(Ce,Rs(v,v.g.graph.url),3)}for(Ce.g!=2&&(E=Ce.h,v.i.loadGraph(E)),D=i(Object.keys(v.B)),V=D.next();!V.done;V=D.next())L=V.value,v.i.overrideFile(L,v.B[L]);if(v.B={},v.g.listeners)for(M=i(v.g.listeners),z=M.next();!z.done;z=M.next())Y=z.value,Fg(v,Y);re=v.j,v.j={},v.setOptions(re),Ce.g=0})})}n.reset=function(){return rt(this,function m(){var b=this;return A(m,function(v){b.i&&(b.i.reset(),b.m={},b.s={}),v.g=0})})},n.setOptions=function(m,b){var v=this;if(b=b||this.g.options){for(var E=[],D=[],V={},L=i(Object.keys(m)),M=L.next();!M.done;V={K:V.K,L:V.L},M=L.next()){var z=M.value;z in this.j&&this.j[z]===m[z]||(this.j[z]=m[z],M=b[z],M!==void 0&&(M.onChange&&(V.K=M.onChange,V.L=m[z],E.push(function(Y){return function(){return rt(v,function re(){var Ce,he=this;return A(re,function(oe){if(oe.g==1)return S(oe,Y.K(Y.L),2);Ce=oe.h,Ce===!0&&(he.o=!0),oe.g=0})})}}(V))),M.graphOptionXref&&(z={valueNumber:M.type===1?m[z]:0,valueBoolean:M.type===0?m[z]:!1,valueString:M.type===2?m[z]:""},M=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),M.graphOptionXref),z),D.push(M))))}(E.length!==0||D.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(D),this.u=(this.u===void 0?[]:this.u).concat(E))}};function _g(m){return rt(m,function b(){var v=this,E,D,V,L,M,z,Y;return A(b,function(re){switch(re.g){case 1:if(!v.o)return re.return();if(!v.u){re.g=2;break}E=i(v.u),D=E.next();case 3:if(D.done){re.g=5;break}return V=D.value,S(re,V(),4);case 4:D=E.next(),re.g=3;break;case 5:v.u=void 0;case 2:if(v.A){for(L=new v.h.GraphOptionChangeRequestList,M=i(v.A),z=M.next();!z.done;z=M.next())Y=z.value,L.push_back(Y);v.i.changeOptions(L),L.delete(),v.A=void 0}v.o=!1,re.g=0}})})}n.initialize=function(){return rt(this,function m(){var b=this;return A(m,function(v){return v.g==1?S(v,Ig(b),2):v.g!=3?S(v,Rg(b),3):S(v,_g(b),0)})})};function Rs(m,b){return rt(m,function v(){var E=this,D,V;return A(v,function(L){return b in E.F?L.return(E.F[b]):(D=E.locateFile(b,""),V=fetch(D).then(function(M){return M.arrayBuffer()}),E.F[b]=V,L.return(V))})})}n.overrideFile=function(m,b){this.i?this.i.overrideFile(m,b):this.B[m]=b},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(m,b){return rt(this,function v(){var E=this,D,V,L,M,z,Y,re,Ce,he;return A(v,function(oe){switch(oe.g){case 1:return E.g.inputs?(D=1e3*(b==null?performance.now():b),S(oe,E.C,2)):oe.return();case 2:return S(oe,E.initialize(),3);case 3:for(V=new E.h.PacketDataList,L=i(Object.keys(m)),M=L.next();!M.done;M=L.next())if(z=M.value,Y=E.g.inputs[z]){e:{var Z=E,se=m[z];switch(Y.type){case"video":var le=Z.m[Y.stream];if(le||(le=new Oo(Z.h,Z.D),Z.m[Y.stream]=le),Z=le,Z.l===0&&(Z.l=Z.h.createTexture()),typeof HTMLVideoElement!="undefined"&&se instanceof HTMLVideoElement){var de=se.videoWidth;le=se.videoHeight}else typeof HTMLImageElement!="undefined"&&se instanceof HTMLImageElement?(de=se.naturalWidth,le=se.naturalHeight):(de=se.width,le=se.height);le={glName:Z.l,width:de,height:le},de=Z.g,de.canvas.width=le.width,de.canvas.height=le.height,de.activeTexture(de.TEXTURE0),Z.h.bindTexture2d(Z.l),de.texImage2D(de.TEXTURE_2D,0,de.RGBA,de.RGBA,de.UNSIGNED_BYTE,se),Z.h.bindTexture2d(0),Z=le;break e;case"detections":for(le=Z.m[Y.stream],le||(le=new Sg(Z.h),Z.m[Y.stream]=le),Z=le,Z.data||(Z.data=new Z.g.DetectionListData),Z.data.reset(se.length),le=0;le<se.length;++le){de=se[le];var qe=Z.data,Ee=qe.setBoundingBox,ht=le,Ue=de.T,ie=new _o;Te(ie,1,Ue.Z),Te(ie,2,Ue.$),Te(ie,3,Ue.height),Te(ie,4,Ue.width),Te(ie,5,Ue.rotation),Te(ie,6,Ue.X);var ye=Ue=new No;zt(ye,1,Me(ie,1)),zt(ye,2,Me(ie,2)),zt(ye,3,Me(ie,3)),zt(ye,4,Me(ie,4)),zt(ye,5,Me(ie,5));var we=Me(ie,6);if(we!=null&&we!=null){yn(ye.g,48);var pe=ye.g,xe=we;we=0>xe,xe=Math.abs(xe);var ce=xe>>>0;for(xe=Math.floor((xe-ce)/4294967296),xe>>>=0,we&&(xe=~xe>>>0,ce=(~ce>>>0)+1,4294967295<ce&&(ce=0,xe++,4294967295<xe&&(xe=0))),an=ce,gn=xe,we=an,ce=gn;0<ce||127<we;)pe.push(we&127|128),we=(we>>>7|ce<<25)>>>0,ce>>>=7;pe.push(we)}if(Io(ie,ye),Ue=Eo(Ue),Ee.call(qe,ht,Ue),de.O)for(qe=0;qe<de.O.length;++qe)ie=de.O[qe],ye=!!ie.visibility,Ee=Z.data,ht=Ee.addNormalizedLandmark,Ue=le,ie=Object.assign(Object.assign({},ie),{visibility:ye?ie.visibility:0}),ye=new jr,Te(ye,1,ie.x),Te(ye,2,ie.y),Te(ye,3,ie.z),ie.visibility&&Te(ye,4,ie.visibility),pe=ie=new No,zt(pe,1,Me(ye,1)),zt(pe,2,Me(ye,2)),zt(pe,3,Me(ye,3)),zt(pe,4,Me(ye,4)),zt(pe,5,Me(ye,5)),Io(ye,pe),ie=Eo(ie),ht.call(Ee,Ue,ie);if(de.M)for(qe=0;qe<de.M.length;++qe){if(Ee=Z.data,ht=Ee.addClassification,Ue=le,ie=de.M[qe],ye=new Hr,Te(ye,2,ie.Y),ie.index&&Te(ye,1,ie.index),ie.label&&Te(ye,3,ie.label),ie.displayName&&Te(ye,4,ie.displayName),pe=ie=new No,ce=Me(ye,1),ce!=null&&ce!=null)if(yn(pe.g,8),we=pe.g,0<=ce)yn(we,ce);else{for(xe=0;9>xe;xe++)we.push(ce&127|128),ce>>=7;we.push(1)}zt(pe,2,Me(ye,2)),we=Me(ye,3),we!=null&&(we=Le(we),yn(pe.g,26),yn(pe.g,we.length),ur(pe,pe.g.end()),ur(pe,we)),we=Me(ye,4),we!=null&&(we=Le(we),yn(pe.g,34),yn(pe.g,we.length),ur(pe,pe.g.end()),ur(pe,we)),Io(ye,pe),ie=Eo(ie),ht.call(Ee,Ue,ie)}}Z=Z.data;break e;default:Z={}}}switch(re=Z,Ce=Y.stream,Y.type){case"video":V.pushTexture2d(Object.assign(Object.assign({},re),{stream:Ce,timestamp:D}));break;case"detections":he=re,he.stream=Ce,he.timestamp=D,V.pushDetectionList(he);break;default:throw Error("Unknown input config type: '"+Y.type+"'")}}return E.i.send(V),S(oe,E.C,4);case 4:V.delete(),oe.g=0}})})};function Ag(m,b,v){return rt(m,function E(){var D,V,L,M,z,Y,re=this,Ce,he,oe,Z,se,le,de,qe;return A(E,function(Ee){switch(Ee.g){case 1:if(!v)return Ee.return(b);for(D={},V=0,L=i(Object.keys(v)),M=L.next();!M.done;M=L.next())z=M.value,Y=v[z],typeof Y!="string"&&Y.type==="texture"&&b[Y.stream]!==void 0&&++V;1<V&&(re.G=!1),Ce=i(Object.keys(v)),M=Ce.next();case 2:if(M.done){Ee.g=4;break}if(he=M.value,oe=v[he],typeof oe=="string")return de=D,qe=he,S(Ee,Og(re,he,b[oe]),14);if(Z=b[oe.stream],oe.type==="detection_list"){if(Z){for(var ht=Z.getRectList(),Ue=Z.getLandmarksList(),ie=Z.getClassificationsList(),ye=[],we=0;we<ht.size();++we){var pe=ht.get(we);e:{var xe=new _o;for(pe=new ks(pe);ar(pe);)switch(pe.i){case 13:var ce=Wt(pe.g);Te(xe,1,ce);break;case 21:ce=Wt(pe.g),Te(xe,2,ce);break;case 29:ce=Wt(pe.g),Te(xe,3,ce);break;case 37:ce=Wt(pe.g),Te(xe,4,ce);break;case 45:ce=Wt(pe.g),Te(xe,5,ce);break;case 48:for(var Ve=pe.g,je=128,Do=0,An=ce=0;4>An&&128<=je;An++)je=Ve.h[Ve.g++],Do|=(je&127)<<7*An;if(128<=je&&(je=Ve.h[Ve.g++],Do|=(je&127)<<28,ce|=(je&127)>>4),128<=je)for(An=0;5>An&&128<=je;An++)je=Ve.h[Ve.g++],ce|=(je&127)<<7*An+3;128>je?(Ve=Do>>>0,je=ce>>>0,(ce=je&2147483648)&&(Ve=~Ve+1>>>0,je=~je>>>0,Ve==0&&(je=je+1>>>0)),Ve=4294967296*je+(Ve>>>0),ce=ce?-Ve:Ve):(Ve.l=!0,ce=void 0),Te(xe,6,ce);break;default:if(!Gr(xe,pe))break e}}xe={Z:Jt(xe,1),$:Jt(xe,2),height:Jt(xe,3),width:Jt(xe,4),rotation:Jt(xe,5,0),X:eu(xe,6)},pe=Ao(Ue.get(we)),Ve=ie.get(we);e:for(ce=new Ro,Ve=new ks(Ve);ar(Ve);)switch(Ve.i){case 10:ce.addClassification(Hi(Ve,new Hr,gg));break;default:if(!Gr(ce,Ve))break e}xe={T:xe,O:pe,M:vg(ce)},ye.push(xe)}ht=ye}else ht=[];D[he]=ht,Ee.g=7;break}if(oe.type==="proto_list"){if(Z){for(ht=Array(Z.size()),Ue=0;Ue<Z.size();Ue++)ht[Ue]=Z.get(Ue);Z.delete()}else ht=[];D[he]=ht,Ee.g=7;break}if(Z===void 0){Ee.g=3;break}if(oe.type==="float_list"){D[he]=Z,Ee.g=7;break}if(oe.type==="proto"){D[he]=Z,Ee.g=7;break}if(oe.type!=="texture")throw Error("Unknown output config type: '"+oe.type+"'");return se=re.s[he],se||(se=new Oo(re.h,re.D),re.s[he]=se),S(Ee,su(se,Z,re.G),13);case 13:le=Ee.h,D[he]=le;case 7:oe.transform&&D[he]&&(D[he]=oe.transform(D[he])),Ee.g=3;break;case 14:de[qe]=Ee.h;case 3:M=Ce.next(),Ee.g=2;break;case 4:return Ee.return(D)}})})}function Og(m,b,v){return rt(m,function E(){var D=this,V;return A(E,function(L){return typeof v=="number"||v instanceof Uint8Array||v instanceof D.h.Uint8BlobList?L.return(v):v instanceof D.h.Texture2dDataOut?(V=D.s[b],V||(V=new Oo(D.h,D.D),D.s[b]=V),L.return(su(V,v,D.G))):L.return(void 0)})})}function Fg(m,b){for(var v=b.name||"$",E=[].concat(u(b.wants)),D=new m.h.StringList,V=i(b.wants),L=V.next();!L.done;L=V.next())D.push_back(L.value);V=m.h.PacketListener.implement({onResults:function(M){for(var z={},Y=0;Y<b.wants.length;++Y)z[E[Y]]=M.get(Y);var re=m.listeners[v];re&&(m.C=Ag(m,z,b.outs).then(function(Ce){Ce=re(Ce);for(var he=0;he<b.wants.length;++he){var oe=z[E[he]];typeof oe=="object"&&oe.hasOwnProperty&&oe.hasOwnProperty("delete")&&oe.delete()}Ce&&(m.C=Ce)}))}}),m.i.attachMultiListener(D,V),D.delete()}n.onResults=function(m,b){this.listeners[b||"$"]=m},G("Solution",Fo),G("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function au(m){switch(m===void 0&&(m=0),m){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function iu(m){var b=this;m=m||{},this.g=new Fo({locateFile:m.locateFile,files:function(v){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:au(v.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Ao},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Ao},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(v){return rt(b,function E(){var D,V,L=this,M;return A(E,function(z){return z.g==1?(D=au(v),V="third_party/mediapipe/modules/pose_landmark/"+D,S(z,Rs(L.g,D),2)):(M=z.h,L.g.overrideFile(V,M),z.return(!0))})})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=iu.prototype,n.reset=function(){this.g.reset()},n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(m){this.g.onResults(m)},n.initialize=function(){return rt(this,function m(){var b=this;return A(m,function(v){return S(v,b.g.initialize(),0)})})},n.send=function(m,b){return rt(this,function v(){var E=this;return A(v,function(D){return S(D,E.g.send(m,b),0)})})},n.setOptions=function(m){this.g.setOptions(m)},G("Pose",iu),G("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),G("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),G("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),G("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),G("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),G("VERSION","0.4.1633558788")}).call(hn);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RF=B();RF.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Et;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Et||(Et={}));var fc;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(fc||(fc={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _F={};function jm(n){return _F[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x(n,e,t,r,s){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const i=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd;if(o.type==="tensor")return ut(e.inputNames[o.inputIndexStart],t,r,s);if(o.type==="tensors")return e.inputNames.slice(i,u).map(p=>ut(p,t,r,s));const c=ut(e.inputNames.slice(i)[0],t,r,s),h=c.dataSync();return o.type==="number"?h[0]:ua(c.shape,h)}const a=e.attrParams[n];return a&&a.value}function ut(n,e,t,r){const[s,o]=mt(n);if(r!=null){const i=r.getHashTableHandleByName(s);if(i!=null)return i}const a=t.currentContextIds.find(i=>!!e[no(s,i)]);return a!==void 0?e[no(s,a)][o]:void 0}function AF(n,e,t){return e[no(n,t.currentContextId)]}function en(n,e){const[t,r,s]=mt(n);return[no(t,e&&e.currentContextId),r,s]}function no(n,e){return e?`${n}-${e}`:n}function mt(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[t,s,r]}function zs(n,e,t){let r=x("pad",n,e,t);if(r==="explicit"){r=x("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function un(n){return n.kept?n:Gn(n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var FF=Object.freeze(Object.defineProperty({__proto__:null,json:OF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var PF=Object.freeze(Object.defineProperty({__proto__:null,json:DF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var BF=Object.freeze(Object.defineProperty({__proto__:null,json:LF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var VF=Object.freeze(Object.defineProperty({__proto__:null,json:MF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var WF=Object.freeze(Object.defineProperty({__proto__:null,json:UF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var GF=Object.freeze(Object.defineProperty({__proto__:null,json:zF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var jF=Object.freeze(Object.defineProperty({__proto__:null,json:HF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var XF=Object.freeze(Object.defineProperty({__proto__:null,json:KF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qF=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var YF=Object.freeze(Object.defineProperty({__proto__:null,json:qF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QF=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var ZF=Object.freeze(Object.defineProperty({__proto__:null,json:QF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JF=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var eD=Object.freeze(Object.defineProperty({__proto__:null,json:JF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var nD=Object.freeze(Object.defineProperty({__proto__:null,json:tD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rD=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var sD=Object.freeze(Object.defineProperty({__proto__:null,json:rD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oD=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var aD=Object.freeze(Object.defineProperty({__proto__:null,json:oD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iD=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var uD=Object.freeze(Object.defineProperty({__proto__:null,json:iD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cD=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var lD=Object.freeze(Object.defineProperty({__proto__:null,json:cD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hD=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var pD=Object.freeze(Object.defineProperty({__proto__:null,json:hD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dD=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var fD=Object.freeze(Object.defineProperty({__proto__:null,json:dD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var gD=Object.freeze(Object.defineProperty({__proto__:null,json:mD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mc{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[FF,PF,BF,VF,WF,GF,jF,XF,YF,ZF,eD,nD,sD,aD,uD,lD,pD,fD,gD],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],o=[],a=[],i=r.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?s.push(g[y.name]):y.op==="Const"?o.push(g[y.name]):(y.input==null||y.input.length===0)&&a.push(g[y.name]),g),{});let u=[];const c=[];let h={},l={};t!=null&&(h=this.mapSignatureEntries(t.inputs),l=this.mapSignatureEntries(t.outputs));const p=Object.keys(i);p.forEach(g=>{const y=i[g];y.inputNames.forEach((w,$)=>{const[S,,T]=en(w),C=i[S];if(C.outputs!=null){const _=C.outputs.indexOf(T);if(_!==-1){const k=`${S}:${_}`;y.inputNames[$]=k}}y.inputs.push(C),C.children.push(y)})}),Object.keys(l).length===0?p.forEach(g=>{const y=i[g];y.children.length===0&&c.push(y)}):Object.keys(l).forEach(g=>{const[y]=en(g),w=i[y];w!=null&&(w.signatureKey=l[g],c.push(w))}),Object.keys(h).length>0?Object.keys(h).forEach(g=>{const[y]=en(g),w=i[y];w&&(w.signatureKey=h[g],u.push(w))}):u=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const f={nodes:i,inputs:u,outputs:c,weights:o,placeholders:s,signature:t,functions:d};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=jm(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,o)=>{const a=o.type;let i;switch(o.type){case"string":i=Ma(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Ma(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=ja(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=ja(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=Ua(e.attr,o.tfName,o.defaultValue||0),i===void 0&&!!o.tfDeprecatedName&&(i=Ua(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=Ha(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Ha(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=Va(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Va(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=Xa(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Xa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=Ga(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Ga(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=Ka(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Ka(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=Wa(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Wa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=za(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=za(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=gc(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=gc(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:i,type:a},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let o={};t!=null&&(o=t.reduce((l,p)=>(l[p.name]=this.mapNode(p),p.op==="Const"&&s.push(l[p.name]),l),{}));const a=[],i=[];e.signature.inputArg.forEach(l=>{const[p]=en(l.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Bi(l.type),type:"dtype"}},children:[]};d.signatureKey=l.name,a.push(d),o[p]=d}),Object.keys(o).forEach(l=>{const p=o[l];p.inputNames.forEach((d,f)=>{const[g,,y]=en(d),w=o[g];if(w.outputs!=null){const $=w.outputs.indexOf(y);if($!==-1){const S=`${g}:${$}`;p.inputNames[f]=S}}p.inputs.push(w),w.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(l=>{const[p,d]=en(c[l.name]),f=o[p];f!=null&&(f.defaultOutput=d,i.push(f))});const h=this.mapArgsToSignature(e);return{nodes:o,inputs:a,outputs:i,weights:s,placeholders:r,signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function yD(n){const e=B().global;if(typeof e.atob!="undefined")return e.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Km(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):yD(n);return e?t:t.toLowerCase()}function Ma(n,e,t,r=!1){const s=n[e];return s!=null?Km(s.s,r):t}function Va(n,e,t){const r=n[e];return r?r.b:t}function Ua(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function Bi(n){switch(typeof n=="string"&&(n=Et[n]),n){case Et.DT_FLOAT:case Et.DT_HALF:return"float32";case Et.DT_INT32:case Et.DT_INT64:case Et.DT_INT8:case Et.DT_UINT8:return"int32";case Et.DT_BOOL:return"bool";case Et.DT_DOUBLE:return"float32";case Et.DT_STRING:return"string";default:return null}}function gc(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function Wa(n,e,t){const r=n[e];return r&&r.type?Bi(r.type):t}function za(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Bi(s)):t}function Xm(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Ga(n,e,t){const r=n[e];return r&&r.shape?Xm(r.shape):t}function Ha(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function ja(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(o=>Km(o,r)):t}function Ka(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Xm(s)):t}function Xa(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xD{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return ut(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return ut(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Ua(this.node.rawAttrs,e,t);if(r.s!=null)return Ma(this.node.rawAttrs,e,t);if(r.b!=null)return Va(this.node.rawAttrs,e,t);if(r.shape!=null)return Ga(this.node.rawAttrs,e,t);if(r.type!=null)return Wa(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return Ha(this.node.rawAttrs,e,t);if(r.list.s!=null)return ja(this.node.rawAttrs,e,t);if(r.list.shape!=null)return Ka(this.node.rawAttrs,e,t);if(r.list.b!=null)return Xa(this.node.rawAttrs,e,t);if(r.list.type!=null)return za(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bD=(n,e,t)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[Ie(x("a",n,e,t),x("b",n,e,t))];case"AddN":return[Yx(x("tensors",n,e,t))];case"FloorMod":case"Mod":return[fb(x("a",n,e,t),x("b",n,e,t))];case"Mul":return[ee(x("a",n,e,t),x("b",n,e,t))];case"RealDiv":case"Div":return[ke(x("a",n,e,t),x("b",n,e,t))];case"DivNoNan":return[l1(x("a",n,e,t),x("b",n,e,t))];case"FloorDiv":return[Sd(x("a",n,e,t),x("b",n,e,t))];case"Sub":return[fe(x("a",n,e,t),x("b",n,e,t))];case"Minimum":return[Ti(x("a",n,e,t),x("b",n,e,t))];case"Maximum":return[ub(x("a",n,e,t),x("b",n,e,t))];case"Pow":return[Vd(x("a",n,e,t),x("b",n,e,t))];case"SquaredDifference":return[tf(x("a",n,e,t),x("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vD=(n,e,t)=>{switch(n.op){case"Abs":case"ComplexAbs":return[kt(x("x",n,e,t))];case"Acos":return[jx(x("x",n,e,t))];case"Acosh":return[Xx(x("x",n,e,t))];case"Asin":return[o0(x("x",n,e,t))];case"Asinh":return[i0(x("x",n,e,t))];case"Atan":return[c0(x("x",n,e,t))];case"Atan2":return[h0(x("x",n,e,t),x("y",n,e,t))];case"Atanh":return[d0(x("x",n,e,t))];case"Ceil":return[L0(x("x",n,e,t))];case"Complex":return[Kn(x("real",n,e,t),x("imag",n,e,t))];case"Cos":return[X0(x("x",n,e,t))];case"Cosh":return[Y0(x("x",n,e,t))];case"Elu":return[_d(x("x",n,e,t))];case"Erf":return[m1(x("x",n,e,t))];case"Exp":return[pn(x("x",n,e,t))];case"Expm1":return[b1(x("x",n,e,t))];case"Floor":return[T1(x("x",n,e,t))];case"Log":return[as(x("x",n,e,t))];case"Log1p":return[Fd(x("x",n,e,t))];case"Imag":return[bi(x("x",n,e,t))];case"Neg":return[bs(x("x",n,e,t))];case"Reciprocal":return[Mb(x("x",n,e,t))];case"Real":return[Qs(x("x",n,e,t))];case"Relu":return[ho(x("x",n,e,t))];case"Round":return[Zd(x("x",n,e,t))];case"Selu":return[Kb(x("x",n,e,t))];case"Sigmoid":return[xs(x("x",n,e,t))];case"Sin":return[Jb(x("x",n,e,t))];case"Sign":return[Qb(x("x",n,e,t))];case"Sinh":return[tv(x("x",n,e,t))];case"Softplus":return[W1(x("x",n,e,t))];case"Sqrt":return[_a(x("x",n,e,t))];case"Square":return[lo(x("x",n,e,t))];case"Tanh":return[E0(x("x",n,e,t))];case"Tan":return[bv(x("x",n,e,t))];case"ClipByValue":return[Ed(x("x",n,e,t),x("clipValueMin",n,e,t),x("clipValueMax",n,e,t))];case"Relu6":return[Qd(x("x",n,e,t))];case"Rsqrt":return[Hb(ut(n.inputNames[0],e,t))];case"Prod":return[Wd(x("x",n,e,t),x("axes",n,e,t))];case"LeakyRelu":return[Od(x("x",n,e,t),x("alpha",n,e,t))];case"Prelu":return[Ud(x("x",n,e,t),x("alpha",n,e,t))];case"IsNan":return[R1(ut(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function It(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){I(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];I(s<0||o<0||s===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function yc(n){return!(typeof n=="number"||n.some(e=>e<0))}function qr(n,e,t){let r=qa(n,t);const s=!yc(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=qa(o.shape,r)}),!yc(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function qa(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wD{constructor(e,t,r,s,o,a,i){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=me(0),vn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),It(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,vn(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Sn([],[0].concat(this.elementShape));const r=this.readMany(e);return It(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),dn(r,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Sn([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return It(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),yt(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,er(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:t.size/r,a=[];ae(()=>{t=W(t,[1,r,o]);for(let u=0;u<e.length;++u){const c=u===0?0:s[u-1],h=[0,c,0],l=[1,e[u],o];a[u]=W($e(t,h,l),this.elementShape)}return a});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vr{constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);It(t,o.shape,"TensorList shape mismatch: "),vn(o)}),this.idTensor=me(0),this.maxNumElements=s,vn(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Vr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);It(e,this.elementShape,"TensorList shape mismatch: ");const s=qr(this.elementShape,this.tensors,e);return ae(()=>{const o=this.tensors.map(a=>W(a,s));return dn(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=qr(this.elementShape,this.tensors,e),s=this.tensors.pop();return It(s.shape,e,"TensorList shape mismatch: "),W(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(It(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");vn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);It(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=qr(this.elementShape,this.tensors,t);return W(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);It(this.elementShape,t.shape,"TensorList shape mismatch: "),vn(t),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);It(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=qr(this.elementShape,this.tensors,r);return e.length===0?Sn([],[0].concat(s)):ae(()=>{const o=e.map(a=>W(this.tensors[a],s));return dn(o,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);It(this.elementShape,t,"TensorList shape mismatch: ");const r=qr(this.elementShape,this.tensors,t);return this.size()===0?Sn([],[0].concat(r)):ae(()=>{const s=this.tensors.map(o=>W(o,r));return yt(s,0)})}}function $D(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);It(s,e,"TensorList shape mismatch: ");const o=er(n);return new Vr(o,e,r)}function SD(n,e,t){return new Vr([],n,e,t)}function TD(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Vr([],t,n.dtype,r),a=er(n,0);return e.forEach((i,u)=>{o.setItem(i,a[u])}),o}function CD(n,e,t){let r=0;const s=e.map(h=>(r+=h,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),a=qa(o,t),i=r===0?0:n.size/r,u=ae(()=>{const h=[];n=W(n,[1,r,i]);for(let l=0;l<e.length;++l){const p=l===0?0:s[l-1],d=[0,p,0],f=[1,e[l],i];h[l]=W($e(n,d,f),a)}return n.dispose(),h}),c=new Vr([],t,n.dtype,e.length);for(let h=0;h<u.length;h++)c.setItem(h,u[h]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ND=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=x("thenBranch",n,e,t),s=x("elseBranch",n,e,t),o=x("cond",n,e,t),a=x("args",n,e,t);return(await o.data())[0]?t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=x("body",n,e,t),s=x("cond",n,e,t),o=x("args",n,e,t),a=await t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),i=o.map(h=>h.id);let u=await a[0].data();a.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&h.dispose()});let c=o;for(;u[0];){const h=c;c=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const l=c.map(d=>d.id);h.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&l.indexOf(d.id)===-1&&d.dispose()});const p=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);u=await p[0].data(),p.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&l.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{const r=x("pred",n,e,t);return[un(r)]}case"Switch":{const r=x("pred",n,e,t);let s=x("data",n,e,t);return s.kept||(s=un(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>ut(s,e,t)!==void 0);if(r){const s=ut(r,e,t);return[un(s)]}return}case"Enter":{const r=x("frameName",n,e,t),s=x("tensor",n,e,t);return t.enterFrame(r),[un(s)]}case"Exit":{const r=x("tensor",n,e,t);return t.exitFrame(),[un(r)]}case"NextIteration":{const r=x("tensor",n,e,t);return t.nextIteration(),[un(r)]}case"TensorArrayV3":{const r=x("size",n,e,t),s=x("dtype",n,e,t),o=x("elementShape",n,e,t),a=x("dynamicSize",n,e,t),i=x("clearAfterRead",n,e,t),u=x("identicalElementShapes",n,e,t),c=x("name",n,e,t),h=new wD(c,s,r,o,u,a,i);return t.addTensorArray(h),[h.idTensor,me(1)]}case"TensorArrayWriteV3":{const r=x("tensorArrayId",n,e,t),s=x("index",n,e,t),o=x("tensor",n,e,t),a=t.getTensorArray(r.id);return a.write(s,o),[a.idTensor]}case"TensorArrayReadV3":{const r=x("tensorArrayId",n,e,t),s=x("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=x("tensorArrayId",n,e,t),s=x("indices",n,e,t),o=x("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=x("tensorArrayId",n,e,t),s=x("indices",n,e,t),o=x("tensor",n,e,t),a=t.getTensorArray(r.id);return a.scatter(s,o),[a.idTensor]}case"TensorArrayConcatV3":{const r=x("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),o=x("dtype",n,e,t);return[s.concat(o)]}case"TensorArraySplitV3":{const r=x("tensorArrayId",n,e,t),s=x("tensor",n,e,t),o=x("lengths",n,e,t),a=t.getTensorArray(r.id);return a.split(o,s),[a.idTensor]}case"TensorArraySizeV3":{const r=x("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[me(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=x("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=x("tensorListId",n,e,t),s=x("index",n,e,t),o=x("tensor",n,e,t),a=t.getTensorList(r.id);return a.setItem(s,o),[a.idTensor]}case"TensorListGetItem":{const r=x("tensorListId",n,e,t),s=x("index",n,e,t),o=x("elementShape",n,e,t),a=x("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const r=x("indices",n,e,t),s=x("tensor",n,e,t),o=x("elementShape",n,e,t),a=x("numElements",n,e,t),i=TD(s,r,o,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=x("elementShape",n,e,t),s=x("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const a=x(o,n,e,t),i=SD(r,s,a);return t.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=x("tensorListId",n,e,t),s=x("indices",n,e,t),o=x("elementShape",n,e,t),a=x("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,a,o)]}case"TensorListStack":{const r=x("tensorListId",n,e,t),s=x("elementShape",n,e,t),o=x("elementDType",n,e,t),a=x("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,o,a)]}case"TensorListFromTensor":{const r=x("tensor",n,e,t),s=x("elementShape",n,e,t),o=x("elementDType",n,e,t),a=$D(r,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":{const r=x("tensorListId",n,e,t),s=t.getTensorList(r.id),o=x("dtype",n,e,t),a=x("elementShape",n,e,t);return[s.concat(o,a)]}case"TensorListPushBack":{const r=x("tensorListId",n,e,t),s=x("tensor",n,e,t),o=t.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=x("tensorListId",n,e,t),s=x("elementShape",n,e,t),o=x("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=x("tensor",n,e,t),s=x("elementShape",n,e,t),o=x("lengths",n,e,t),a=CD(r,o,s);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xc(n,e,t){const[r,s]=x("fusedOps",n,e,t),o=r==="biasadd",a=!o,i=s==="prelu",u=r==="fusedbatchnorm",c=x("numArgs",n,e,t);if(o){if(i&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=x("strides",n,e,t),l=zs(n,e,t),p=x("dataFormat",n,e,t).toUpperCase(),d=x("dilations",n,e,t);let[f,g]=x("args",n,e,t);a&&(g=f,f=void 0);const y=x("leakyreluAlpha",n,e,t);return{stride:h,pad:l,dataFormat:p,dilations:d,biasArg:f,preluArg:g,activationFunc:s,leakyreluAlpha:y}}const ED=(n,e,t)=>{switch(n.op){case"Conv1D":{const r=x("stride",n,e,t),s=x("pad",n,e,t),o=x("dataFormat",n,e,t).toUpperCase(),a=x("dilation",n,e,t);return[U0(x("x",n,e,t),x("filter",n,e,t),r,s,o,a)]}case"Conv2D":{const r=x("strides",n,e,t),s=zs(n,e,t),o=x("dataFormat",n,e,t).toUpperCase(),a=x("dilations",n,e,t);return[gi(x("x",n,e,t),x("filter",n,e,t),[r[1],r[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:i,preluArg:u,activationFunc:c,leakyreluAlpha:h}=xc(n,e,t);return[Mv({x:x("x",n,e,t),filter:x("filter",n,e,t),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:i,preluArg:u,activationFunc:c,leakyreluAlpha:h}=xc(n,e,t);return[Hv({x:x("x",n,e,t),filter:x("filter",n,e,t),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=x("outputShape",n,e,t),s=x("strides",n,e,t),o=zs(n,e,t);return[G0(x("x",n,e,t),x("filter",n,e,t),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=x("strides",n,e,t),s=zs(n,e,t),o=x("dilations",n,e,t),a=x("dataFormat",n,e,t).toUpperCase();return[Id(x("input",n,e,t),x("filter",n,e,t),[r[1],r[2]],s,a,[o[1],o[2]])]}case"Conv3D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("dataFormat",n,e,t).toUpperCase(),a=x("dilations",n,e,t);return[j0(x("x",n,e,t),x("filter",n,e,t),[r[1],r[2],r[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[v0(x("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[nb(x("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t),a=x("includeBatchInIndex",n,e,t),{result:i,indexes:u}=ab(x("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s,a);return[i,u]}case"AvgPool3D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[$0(x("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[sb(x("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("dilations",n,e,t),a=r[1],i=r[2],u=o[1],c=o[2];return[o1(x("x",n,e,t),x("filter",n,e,t),[a,i],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kD=(n,e,t)=>{switch(n.op){case"Fill":{const r=x("shape",n,e,t),s=x("dtype",n,e,t),o=x("value",n,e,t);return[xi(r,o,s)]}case"LinSpace":{const r=x("start",n,e,t),s=x("stop",n,e,t),o=x("num",n,e,t);return[D1(r,s,o)]}case"Multinomial":{const r=x("logits",n,e,t),s=x("numSamples",n,e,t),o=x("seed",n,e,t);return[yb(r,s,o)]}case"OneHot":{const r=x("indices",n,e,t),s=x("depth",n,e,t),o=x("onValue",n,e,t),a=x("offValue",n,e,t);return[Ix(r,s,o,a)]}case"Ones":return[Si(x("shape",n,e,t),x("dtype",n,e,t))];case"OnesLike":return[vb(x("x",n,e,t))];case"RandomUniform":return[Pb(x("shape",n,e,t),x("minval",n,e,t),x("maxval",n,e,t),x("dtype",n,e,t))];case"Range":{const r=x("start",n,e,t),s=x("stop",n,e,t),o=x("step",n,e,t);return[is(r,s,o,x("dtype",n,e,t))]}case"TruncatedNormal":{const r=x("shape",n,e,t),s=x("mean",n,e,t),o=x("stdDev",n,e,t),a=x("seed",n,e,t);return[Sv(r,s,o,x("dtype",n,e,t),a)]}case"Zeros":return[En(x("shape",n,e,t),x("dtype",n,e,t))];case"ZerosLike":return[yi(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qo(n,e,t){const r=x("boxes",n,e,t),s=x("scores",n,e,t),o=x("maxOutputSize",n,e,t),a=x("iouThreshold",n,e,t),i=x("scoreThreshold",n,e,t),u=x("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}}const ID=async(n,e,t)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}=qo(n,e,t),c=await $t.nonMaxSuppressionWithScoreAsync(r,s,o,a,i,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=qo(n,e,t),u=x("padToMaxOutputSize",n,e,t),c=await $t.nonMaxSuppressionPaddedAsync(r,s,o,a,i,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=qo(n,e,t);return[await $t.nonMaxSuppressionAsync(r,s,o,a,i)]}case"Where":{const r=_e(x("condition",n,e,t),"bool"),s=[await Ev(r)];return r.dispose(),s}case"ListDiff":return qb(x("x",n,e,t),x("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RD=(n,e,t)=>{switch(n.op){case"TopKV2":{const r=x("x",n,e,t),s=x("k",n,e,t),o=x("sorted",n,e,t),a=wv(r,s,o);return[a.values,a.indices]}case"Unique":{const r=x("x",n,e,t),s=Fu(r);return[s.values,s.indices]}case"UniqueV2":{const r=x("x",n,e,t),s=x("axis",n,e,t),o=Fu(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _D=(n,e,t)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=x("default",n,e,t);return[ut(n.name,e,t)||r];case"Placeholder":return[ut(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=x("x",n,e,t);return[un(c)]}case"IdentityN":return x("x",n,e,t).map(c=>un(c));case"Snapshot":const s=x("x",n,e,t);return[un(s)];case"Shape":return[et(x("x",n,e,t).shape,"int32")];case"ShapeN":return x("x",n,e,t).map(c=>et(c.shape));case"Size":return[me(x("x",n,e,t).size,"int32")];case"Rank":return[me(x("x",n,e,t).rank,"int32")];case"NoOp":return[me(1)];case"Print":const o=x("x",n,e,t),a=x("data",n,e,t),i=x("message",n,e,t),u=x("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AD{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=me(0),this.tensorMap=new Map,vn(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return me(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),ae(()=>{const s=er(t),o=r.length,a=s.length;I(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){const u=r[i],c=s[i];vn(c),this.tensorMap.set(u,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return ae(()=>{const s=[];for(let o=0;o<r.length;o++){const a=r[o],i=this.findWithDefault(a,t);s.push(i)}return dn(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r!=null?r:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OD=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=x("keyDType",n,e,t),o=x("valueDType",n,e,t),a=new AD(s,o);return r.addHashTable(n.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=x("tableHandle",n,e,t,r),o=x("keys",n,e,t),a=x("values",n,e,t);return[await r.getHashTableById(s.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const s=x("tableHandle",n,e,t,r),o=x("keys",n,e,t),a=x("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=x("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FD=(n,e,t)=>{switch(n.op){case"ResizeBilinear":{const r=x("images",n,e,t),s=x("size",n,e,t),o=x("alignCorners",n,e,t),a=x("halfPixelCenters",n,e,t);return[$t.resizeBilinear(r,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{const r=x("images",n,e,t),s=x("size",n,e,t),o=x("alignCorners",n,e,t),a=x("halfPixelCenters",n,e,t);return[$t.resizeNearestNeighbor(r,[s[0],s[1]],o,a)]}case"CropAndResize":{const r=x("image",n,e,t),s=x("boxes",n,e,t),o=x("boxInd",n,e,t),a=x("cropSize",n,e,t),i=x("method",n,e,t),u=x("extrapolationValue",n,e,t);return[$t.cropAndResize(r,s,o,a,i,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DD=(n,e,t)=>{switch(n.op){case"Equal":return[Rd(x("a",n,e,t),x("b",n,e,t))];case"NotEqual":return[Md(x("a",n,e,t),x("b",n,e,t))];case"Greater":return[co(x("a",n,e,t),x("b",n,e,t))];case"GreaterEqual":return[Ad(x("a",n,e,t),x("b",n,e,t))];case"Less":return[O1(x("a",n,e,t),x("b",n,e,t))];case"LessEqual":return[vi(x("a",n,e,t),x("b",n,e,t))];case"LogicalAnd":return[Pd(x("a",n,e,t),x("b",n,e,t))];case"LogicalNot":return[Z1(x("a",n,e,t))];case"LogicalOr":return[eb(x("a",n,e,t),x("b",n,e,t))];case"Select":case"SelectV2":return[Tr(x("condition",n,e,t),x("a",n,e,t),x("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PD=(n,e,t)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ke(x("a",n,e,t),x("b",n,e,t),x("transposeA",n,e,t),x("transposeB",n,e,t))];case"Einsum":return[p1(x("equation",n,e,t),...x("tensors",n,e,t))];case"Transpose":return[Na(x("x",n,e,t),x("perm",n,e,t))];case"_FusedMatMul":const[r,s]=x("fusedOps",n,e,t),o=r==="biasadd",a=s==="prelu",i=x("numArgs",n,e,t),u=x("leakyreluAlpha",n,e,t);if(o){if(a&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=x("args",n,e,t);return[Kv({a:x("a",n,e,t),b:x("b",n,e,t),transposeA:x("transposeA",n,e,t),transposeB:x("transposeB",n,e,t),bias:c,activation:s,preluActivationWeights:h,leakyreluAlpha:u})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LD=(n,e,t)=>{switch(n.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Au(x("x",n,e,t),x("mean",n,e,t),x("variance",n,e,t),x("offset",n,e,t),x("scale",n,e,t),x("epsilon",n,e,t))];case"FusedBatchNormV3":return[Au(x("x",n,e,t),x("mean",n,e,t),x("variance",n,e,t),x("offset",n,e,t),x("scale",n,e,t),x("epsilon",n,e,t))];case"LRN":return[L1(x("x",n,e,t),x("radius",n,e,t),x("bias",n,e,t),x("alpha",n,e,t),x("beta",n,e,t))];case"Softmax":return[rv(x("x",n,e,t))];case"LogSoftmax":return[K1(x("x",n,e,t))];case"SparseToDense":return[of(x("sparseIndices",n,e,t),x("outputShape",n,e,t),x("sparseValues",n,e,t),x("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BD=(n,e,t)=>{switch(n.op){case"Max":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[vr(x("x",n,e,t),a,i)]}case"Mean":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[Ld(x("x",n,e,t),a,i)]}case"Min":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[Ia(x("x",n,e,t),a,i)]}case"Sum":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[Fe(x("x",n,e,t),a,i)]}case"All":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[Zx(x("x",n,e,t),a,i)]}case"Any":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[e0(x("x",n,e,t),a,i)]}case"ArgMax":{const a=x("axis",n,e,t);return[Td(x("x",n,e,t),a)]}case"ArgMin":{const a=x("axis",n,e,t);return[r0(x("x",n,e,t),a)]}case"Prod":{const a=x("axis",n,e,t),i=x("keepDims",n,e,t);return[Wd(x("x",n,e,t),a,i)]}case"Cumsum":{const a=x("axis",n,e,t),i=x("exclusive",n,e,t),u=x("reverse",n,e,t);return[Z0(x("x",n,e,t),a,i,u)]}case"Bincount":const r=x("x",n,e,t),s=x("weights",n,e,t),o=x("size",n,e,t);return[Nd(r,s,o)];case"DenseBincount":{const a=x("x",n,e,t),i=x("weights",n,e,t),u=x("size",n,e,t),c=x("binaryOutput",n,e,t);return[e1(a,i,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MD=(n,e,t)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=x("n",n,e,t),s=x("axis",n,e,t);let o=x("tensors",n,e,t);return o=o.slice(0,r),[yt(o,s)]}case"Gather":{const r=x("x",n,e,t),s=x("indices",n,e,t);return[Ou(r,_e(s,"int32"),0)]}case"GatherV2":{const r=x("axis",n,e,t),s=x("batchDims",n,e,t),o=x("x",n,e,t),a=x("indices",n,e,t);return[Ou(o,_e(a,"int32"),r,s)]}case"Reverse":{const r=x("dims",n,e,t),s=[];for(let a=0;a<r.length;a++)r[a]&&s.push(a);const o=x("x",n,e,t);return[Zs(o,s)]}case"ReverseV2":{const r=x("axis",n,e,t),s=x("x",n,e,t);return[Zs(s,r)]}case"Slice":{const r=x("begin",n,e,t),s=x("size",n,e,t);return[$e(x("x",n,e,t),r,s)]}case"StridedSlice":{const r=x("begin",n,e,t),s=x("end",n,e,t),o=x("strides",n,e,t),a=x("beginMask",n,e,t),i=x("endMask",n,e,t),u=x("ellipsisMask",n,e,t),c=x("newAxisMask",n,e,t),h=x("shrinkAxisMask",n,e,t),l=x("x",n,e,t);return[yv(l,r,s,o,a,i,u,c,h)]}case"Pack":return ae(()=>{const r=x("axis",n,e,t),s=x("tensors",n,e,t),o=s[0].shape,a=Ne(s[0]).shape,i=s.map(u=>{const c=We(u.shape,o);if(!c&&!We(Ne(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:W(u,o)});return[dn(i,r)]});case"Unpack":{const r=x("axis",n,e,t),s=x("tensor",n,e,t);return er(s,r)}case"Tile":{const r=x("reps",n,e,t);return[es(x("x",n,e,t),r)]}case"Split":case"SplitV":{const r=x("axis",n,e,t),s=x("numOrSizeSplits",n,e,t),o=x("x",n,e,t);return us(o,s,r)}case"ScatterNd":{const r=x("indices",n,e,t),s=x("values",n,e,t),o=x("shape",n,e,t);return[Rv(r,s,o)]}case"GatherNd":{const r=x("x",n,e,t),s=x("indices",n,e,t);return[Fv(r,s)]}case"SparseToDense":{const r=x("sparseIndices",n,e,t),s=x("outputShape",n,e,t),o=x("sparseValues",n,e,t),a=x("defaultValue",n,e,t);return[of(r,o,s,o.dtype===a.dtype?a:_e(a,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VD=(n,e,t)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=Os.sparseFillEmptyRows(x("indices",n,e,t),x("values",n,e,t),x("denseShape",n,e,t),x("defaultValue",n,e,t));return[r,s,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=Os.sparseReshape(x("inputIndices",n,e,t),x("inputShape",n,e,t),x("newShape",n,e,t));return[r,s]}case"SparseSegmentMean":return[Os.sparseSegmentMean(x("data",n,e,t),x("indices",n,e,t),x("segmentIds",n,e,t))];case"SparseSegmentSum":return[Os.sparseSegmentSum(x("data",n,e,t),x("indices",n,e,t),x("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD=(n,e,t)=>{switch(n.op){case"FFT":return[Jd(x("x",n,e,t))];case"IFFT":return[Ra(x("x",n,e,t))];case"RFFT":return[ef(x("x",n,e,t))];case"IRFFT":return[iv(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WD=(n,e,t)=>{switch(n.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=Vo.stringNGrams(x("data",n,e,t),x("dataSplits",n,e,t),x("separator",n,e,t),x("nGramWidths",n,e,t),x("leftPad",n,e,t),x("rightPad",n,e,t),x("padWidth",n,e,t),x("preserveShortSequences",n,e,t));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=Vo.stringSplit(x("input",n,e,t),x("delimiter",n,e,t),x("skipEmpty",n,e,t));return[r,s,o]}case"StringToHashBucketFast":return[Vo.stringToHashBucketFast(x("input",n,e,t),x("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zD=(n,e,t)=>{switch(n.op){case"Cast":return[_e(x("x",n,e,t),x("dtype",n,e,t))];case"ExpandDims":{const r=x("axis",n,e,t);return[Rt(x("x",n,e,t),r)]}case"Squeeze":{const r=x("axis",n,e,t);return[Ne(x("x",n,e,t),r)]}case"Reshape":return[W(x("x",n,e,t),x("shape",n,e,t))];case"MirrorPad":return[Bd(x("x",n,e,t),x("padding",n,e,t),x("mode",n,e,t))];case"PadV2":case"Pad":return[Ys(x("x",n,e,t),x("padding",n,e,t),x("constantValue",n,e,t))];case"SpaceToBatchND":{const r=x("blockShape",n,e,t),s=x("paddings",n,e,t);return[Sb(x("x",n,e,t),r,s)]}case"BatchToSpaceND":{const r=x("blockShape",n,e,t),s=x("crops",n,e,t);return[I0(x("x",n,e,t),r,s)]}case"DepthToSpace":{const r=x("blockSize",n,e,t),s=x("dataFormat",n,e,t).toUpperCase();return[n1(x("x",n,e,t),r,s)]}case"BroadcastTo":return[Us(x("x",n,e,t),x("shape",n,e,t))];case"BroadcastArgs":return[F0(x("s0",n,e,t),x("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bc(n,e,t,r){const s=((o,a,i)=>{switch(o.category){case"arithmetic":return ae(()=>bD(o,a,i));case"basic_math":return ae(()=>vD(o,a,i));case"control":return ND(o,a,i);case"convolution":return ae(()=>ED(o,a,i));case"creation":return ae(()=>kD(o,a,i));case"dynamic":return ID(o,a,i);case"evaluation":return ae(()=>RD(o,a,i));case"image":return ae(()=>FD(o,a,i));case"graph":return ae(()=>_D(o,a,i));case"logical":return ae(()=>DD(o,a,i));case"matrices":return ae(()=>PD(o,a,i));case"normalization":return ae(()=>LD(o,a,i));case"reduction":return ae(()=>BD(o,a,i));case"slice_join":return ae(()=>MD(o,a,i));case"sparse":return ae(()=>VD(o,a,i));case"spectral":return ae(()=>UD(o,a,i));case"string":return ae(()=>WD(o,a,i));case"transformation":return ae(()=>zD(o,a,i));case"hash_table":return OD(o,a,i,r);case"custom":const u=jm(o.op);if(u&&u.customExecutor)return u.customExecutor(new xD(o,a,i));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return ns(s)?s.then(o=>[].concat(o)):[].concat(s)}class vc{constructor(e={},t={},r={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wc(n,e,t,r){const s=new Set,o=[];let a=null,i=null;const u=new Set,c=Object.keys(n).map(p=>mt(p)[0]);let h=[];r!=null&&(h=r.map(p=>mt(p.name)[0]));const l=[...e];for(;l.length>0;){const p=l.pop();if((qm(p)||XD(p)||qD(p))&&a==null&&(a=p,i=a.children.map(d=>d.name).filter(d=>s.has(d))),s.add(p.name),t[p.name]==null&&c.indexOf(p.name)===-1&&h.indexOf(p.name)===-1){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),l.push(d))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:a,syncInputs:i}}function GD(n,e,t){const{usedNodes:r,inputs:s}=t,o=[],a=Object.keys(s).map(h=>mt(h)[0]).map(h=>n.nodes[h]),i=n.initNodes;a.forEach(h=>{r.has(h.name)&&o.push(h)}),n.weights.forEach(h=>{r.has(h.name)&&o.push(h)}),i!=null&&i.forEach(h=>{r.has(h.name)&&o.push(h)});const u=new Set,c=[];for(;o.length>0;){const h=o.pop();u.add(h.name),e[h.name]||c.push(h),h.children.forEach(l=>{!u.has(l.name)&&r.has(l.name)&&l.inputs.every(p=>u.has(p.name))&&o.push(l)})}return c}const HD=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],jD=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],KD=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function qm(n){return HD.indexOf(n.op)>=0}function XD(n){return jD.indexOf(n.op)>=0}function qD(n){return KD.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ro{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new ro(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const r=e.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const r=wc(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:a}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(s.length>0){const i=t.map(c=>c.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}return GD(this.graph,this.weightMap,r)}execute(e,t){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(l=>this.graph.nodes[mt(l)[0]]),o=t.map(l=>mt(l)[0]);let a=o.map(l=>this.graph.nodes[l]);this.resetIntermediateTensors(),a.length===0&&(a=this._outputs);const i=this.getCompilationKey(s,a);let u=this.compiledMap.get(i);u==null&&(u=this.compile(e,a),this.compiledMap.set(i,u));const c={},h={};return ae(()=>{const l=new vc(this.weightMap,c,h,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(g=>{const[y,w]=mt(g),$=[];$[w]=e[g],p[y]=$});const d=this.getFrozenTensorIds(p),f={};for(let g=0;g<u.length;g++){const y=u[g];if(!p[y.name]){const w=bc(y,p,l,this._resourceManager);if(ns(w))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=w,this.checkTensorForDisposal(y.name,y,p,l,d,o,f)}}return this.parent==null&&l.dispose(d),t.map(g=>ut(g,p,l))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,o,a,i){t.category==="control"||a.indexOf(e)!==-1||(r[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){const c=AF(u.name,r,s);c!=null&&c.forEach(h=>{if(h&&!h.kept&&!o.has(h.id)){const l=i[h.id];if(l===1){if(!this.keepTensorForDebug)h.dispose();else{const[p,d]=en(t.name,s);this.intermediateTensors[p]?this.intermediateTensors[p][d]=h:(this.intermediateTensors[p]=[],this.intermediateTensors[p][d]=h)}delete i[h.id]}else l!=null&&i[h.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,r=!1,s={},o={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=B().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){console.warn(h.message)}this.resetIntermediateTensors();const a=new vc(this.weightMap,s,o,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,a,t,r);const i=t.map(h=>ut(h,this.tensorsMap,a)),u=i.map(h=>h.id),c=Object.keys(e).map(h=>e[h].id);return this.keepIds=new Set([...u,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&a.dispose(this.keepIds),i}async executeFunctionAsync(e,t,r){const s=e.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const o=Object.keys(e),a=o.map(S=>this.graph.nodes[mt(S)[0]]),i=r.map(S=>mt(S)[0]);let u=i.map(S=>this.graph.nodes[S]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:l,syncInputs:p}=wc(e,u,this.weightMap,this._initNodes),d=[...a,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[T,C]=mt(S),_=[];_[C]=e[S],f[T]=_});const g={},y=this.getFrozenTensorIds(f),w={};for(;d.length>0;){const S=this.processStack(a,d,t,f,w,y,i,g,c);await Promise.all(S)}l==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=u.filter(S=>!qm(S)&&!ut(S.name,f,t)).map(S=>S.name);if($.length>0){let S="";throw l!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${S}`)}return f}processStack(e,t,r,s,o,a,i,u,c){const h=[];for(;t.length>0;){const l=t.pop();r.currentContext=l.contexts;let p="";if(l.node.op==="Enter"&&x("isConstant",l.node,s,r)&&([p]=en(l.node.name,r)),s[l.node.name]==null){const d=bc(l.node,s,r,this._resourceManager);p||([p]=en(l.node.name,r));const f=r.currentContext;ns(d)?h.push(d.then(g=>(s[p]=g,r.currentContext=f,this.checkTensorForDisposal(p,l.node,s,r,a,i,u),this.processChildNodes(l.node,t,r,s,o,c),g))):(s[p]=d,this.checkTensorForDisposal(p,l.node,s,r,a,i,u),this.processChildNodes(l.node,t,r,s,o,c))}else this.processChildNodes(l.node,t,r,s,o,c)}return h}processChildNodes(e,t,r,s,o,a){e.children.forEach(i=>{const[u]=en(i.name,r);o[u]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(c=>!!ut(c,s,r))&&(o[u]=!0,t.push({contexts:r.currentContext,node:i})):i.inputNames.every(c=>!!ut(c,s,r))&&(o[u]=!0,t.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=mt(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const a=o.attrParams.shape.value,i=a.length===r.shape.length&&r.shape.every((u,c)=>a[c]===-1||a[c]===u);I(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&I(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const t={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];t[s.name]=e[r]}else t[r]=e[r];return t}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=mt(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[r]=mt(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class YD{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QD="?tfjs-format=file",ZD="model.json";class JD{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new YD}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Ru(e,this.loadOptions);else{const t=Jy(e,this.loadOptions);if(t.length===0)t.push(Ru(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?r=this.artifacts.userDefinedMetadata.signature:r=this.artifacts.signature,this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=zy(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ro(mc.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=mc.Instance.transformGraph(e.modelInitializer);this.initializer=new ro(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const r=Zy(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof He)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,r,s)=>(t[r]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function kr(n,e={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&n.load==null&&(n.endsWith("/")||(n=n+"/"),n=`${n}${ZD}${QD}`);const t=new JD(n,e);return await t.load(),t}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Ym=function(n,e){return(Ym=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])})(n,e)};function Qm(n,e){function t(){this.constructor=n}Ym(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Re=function(){return(Re=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function be(n,e,t,r){return new(t||(t=Promise))(function(s,o){function a(c){try{u(r.next(c))}catch(h){o(h)}}function i(c){try{u(r.throw(c))}catch(h){o(h)}}function u(c){var h;c.done?s(c.value):(h=c.value,h instanceof t?h:new t(function(l){l(h)})).then(a,i)}u((r=r.apply(n,e||[])).next())})}function ve(n,e){var t,r,s,o,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function i(u){return function(c){return function(h){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,r&&(s=2&h[0]?r.return:h[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,h[1])).done)return s;switch(r=0,s&&(h=[2&h[0],s.value]),h[0]){case 0:case 1:s=h;break;case 4:return a.label++,{value:h[1],done:!1};case 5:a.label++,r=h[1],h=[0];continue;case 7:h=a.ops.pop(),a.trys.pop();continue;default:if(s=a.trys,!((s=s.length>0&&s[s.length-1])||h[0]!==6&&h[0]!==2)){a=0;continue}if(h[0]===3&&(!s||h[1]>s[0]&&h[1]<s[3])){a.label=h[1];break}if(h[0]===6&&a.label<s[1]){a.label=s[1],s=h;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(h);break}s[2]&&a.ops.pop(),a.trys.pop();continue}h=e.call(n,a)}catch(l){h=[6,l],r=0}finally{t=s=0}if(5&h[0])throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}([u,c])}}}function Wn(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var r=Array(n),s=0;for(e=0;e<t;e++)for(var o=arguments[e],a=0,i=o.length;a<i;a++,s++)r[s]=o[a];return r}var sn=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ps=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],eP={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},tP={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},nP=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],rP=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function so(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function Zm(n){return be(this,void 0,void 0,function(){var e,t;return ve(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof He?[4,hi(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=so(n.width),e.height=so(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function Jm(n){return be(this,void 0,void 0,function(){var e,t,r,s,o,a;return ve(this,function(i){switch(i.label){case 0:return n instanceof He?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,hi(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,i.sent(),r,t]))];case 2:return o=document.createElement("canvas"),a=o.getContext("2d"),o.width=so(n.width),o.height=so(n.height),a.drawImage(n,0,0),[2,a.getImageData(0,0,o.width,o.height)]}})})}function sP(n){return be(this,void 0,void 0,function(){var e,t;return ve(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,Zm(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,id(e,4)]}})})}function eg(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got "+n);if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got "+n)}var Yr={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},oP=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,Jm(this.mask)]})})},n.prototype.toTensor=function(){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,sP(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function aP(n){return eg(n),"person"}var iP=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new IF.Pose({locateFile:function(s,o){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:o+"/"+s}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var o=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(o.segmentation={maskValueToLabel:aP,mask:new oP(s.segmentationMask)}),r.poses=[o]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(o,a){return{x:o.x*r.width,y:o.y*r.height,z:o.z,score:o.visibility,name:ps[a]}})};return t!=null&&(s.keypoints3D=t.map(function(o,a){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:ps[a]}})),s},n.prototype.estimatePoses=function(e,t,r){return be(this,void 0,void 0,function(){var s,o;return ve(this,function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof He?(o=ImageData.bind,[4,hi(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,a.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return a.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function uP(n){return be(this,void 0,void 0,function(){var e,t;return ve(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Re({},Yr);var o=Re({},s);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Yr.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Yr.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Yr.smoothSegmentation),o.modelType==null&&(o.modelType=Yr.modelType),o}(n),[4,(t=new iP(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function ds(n){return n instanceof He?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function tg(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function Mi(n){return n instanceof He?n:id(n)}function ng(n,e,t){return Ya(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function Ya(n,e){I(n.width!==0,function(){return e+" width cannot be 0."}),I(n.height!==0,function(){return e+" height cannot be 0."})}function Yo(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,o=n.locationData,a=o.relativeKeypoints[r].x*e.width,i=o.relativeKeypoints[r].y*e.height,u=o.relativeKeypoints[s].x*e.width,c=o.relativeKeypoints[s].y*e.height,h=2*Math.sqrt((u-a)*(u-a)+(c-i)*(c-i)),l=function(p,d,f){var g,y=p.locationData,w=f.rotationVectorStartKeypointIndex,$=f.rotationVectorEndKeypointIndex;g=f.rotationVectorTargetAngle?f.rotationVectorTargetAngle:Math.PI*f.rotationVectorTargetAngleDegree/180;var S=y.relativeKeypoints[w].x*d.width,T=y.relativeKeypoints[w].y*d.height,C=y.relativeKeypoints[$].x*d.width,_=y.relativeKeypoints[$].y*d.height;return tg(g-Math.atan2(-(_-T),C-S))}(n,e,t);return{xCenter:a/e.width,yCenter:i/e.height,width:h/e.width,height:h/e.height,rotation:l}}function rg(n){if(n.length!==16)throw new Error("Array length must be 16 but got "+n.length);return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function Qo(n,e,t,r,s,o,a){return n[e][s]*(n[t][o]*n[r][a]-n[t][a]*n[r][o])}function st(n,e,t){var r=(e+1)%4,s=(e+2)%4,o=(e+3)%4,a=(t+1)%4,i=(t+2)%4,u=(t+3)%4;return Qo(n,r,s,o,a,i,u)+Qo(n,s,o,r,a,i,u)+Qo(n,o,r,s,a,i,u)}function $c(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,o=n;s<o.length;s++){var a=o[s],i=a.x-.5,u=a.y-.5,c=t.ignoreRotation?0:e.rotation,h=Math.cos(c)*i-Math.sin(c)*u,l=Math.sin(c)*i+Math.cos(c)*u;h=h*e.width+e.xCenter,l=l*e.height+e.yCenter;var p=a.z*e.width,d=Re({},a);d.x=h,d.y=l,d.z=p,r.push(d)}return r}function sg(n,e){var t=function(r,s,o,a){var i=s-r,u=a-o;if(i===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var c=u/i;return{scale:c,offset:o-r*c}}(0,255,e[0],e[1]);return ae(function(){return Ie(ee(n,t.scale),t.offset)})}function Qa(n,e,t){var r,s,o,a,i,u,c,h,l,p,d,f,g,y,w=e.outputTensorSize,$=e.keepAspectRatio,S=e.borderMode,T=e.outputTensorFloatRange,C=ds(n),_=function(A,P){return P?{xCenter:P.xCenter*A.width,yCenter:P.yCenter*A.height,width:P.width*A.width,height:P.height*A.height,rotation:P.rotation}:{xCenter:.5*A.width,yCenter:.5*A.height,width:A.width,height:A.height,rotation:0}}(C,t),k=function(A,P,U){if(U===void 0&&(U=!1),!U)return{top:0,left:0,right:0,bottom:0};var H=P.height,G=P.width;Ya(P,"targetSize"),Ya(A,"roi");var q,te,ne=H/G,ue=A.height/A.width,ze=0,Le=0;return ne>ue?(q=A.width,te=A.width*ne,Le=(1-ue/ne)/2):(q=A.height/ne,te=A.height,ze=(1-ne/ue)/2),A.width=q,A.height=te,{top:Le,left:ze,right:ze,bottom:Le}}(_,w,$),R=(r=_,s=C.width,o=C.height,a=!1,i=r.width,u=r.height,c=a?-1:1,h=Math.cos(r.rotation),l=Math.sin(r.rotation),p=r.xCenter,d=r.yCenter,f=1/s,g=1/o,(y=new Array(16))[0]=i*h*c*f,y[1]=-u*l*f,y[2]=0,y[3]=(-.5*i*h*c+.5*u*l+p)*f,y[4]=i*l*c*g,y[5]=u*h*g,y[6]=0,y[7]=(-.5*u*h-.5*i*l*c+d)*g,y[8]=0,y[9]=0,y[10]=i*f,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,rg(y));return{imageTensor:ae(function(){var A=Mi(n),P=Kt(ng(R,C,w),[1,8]),U=S==="zero"?"constant":"nearest",H=$t.transform(Rt(_e(A,"float32")),P,"bilinear",U,0,[w.height,w.width]);return T!=null?sg(H,T):H}),padding:k,transformationMatrix:R}}function Sc(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function cP(n){return ae(function(){var e=function(s){return ae(function(){return[$e(s,[0,0,0],[1,-1,1]),$e(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:Ne(r),logits:Ne(t)}})}function og(n){return n!=null&&n.currentTime!=null}function Tc(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,a=0;a<n.length;++a){var i=n[a];t=Math.min(t,i.x),r=Math.max(r,i.x),s=Math.min(s,i.y),o=Math.max(o,i.y),e.locationData.relativeKeypoints.push({x:i.x,y:i.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:o,width:r-t,height:o-s},e}function lP(n,e,t,r){return be(this,void 0,void 0,function(){var s,o,a,i,u;return ve(this,function(c){switch(c.label){case 0:return n.sort(function(h,l){return Math.max.apply(Math,l.score)-Math.max.apply(Math,h.score)}),s=Kt(n.map(function(h){return[h.locationData.relativeBoundingBox.yMin,h.locationData.relativeBoundingBox.xMin,h.locationData.relativeBoundingBox.yMax,h.locationData.relativeBoundingBox.xMax]})),o=et(n.map(function(h){return h.score[0]})),[4,$t.nonMaxSuppressionAsync(s,o,e,t)];case 1:return[4,(a=c.sent()).array()];case 2:return i=c.sent(),u=n.filter(function(h,l){return i.indexOf(l)>-1}),ot([s,o,a]),[2,u]}})})}function ag(n,e){return n.map(function(t){var r=Re(Re({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function hP(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,a,i,u,c,h,l,p,d,f,g,y,w,$,S,T,C,_,k,R,A,P;return ve(this,function(U){switch(U.label){case 0:if(r=Ne(e,[0]),s=r.shape,o=s[0],a=s[1],i=s[2],n.length!==i)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+n.length+", heatmap length: "+i);return u=[],[4,r.buffer()];case 1:for(c=U.sent(),h=0;h<n.length;h++)if(l=n[h],p=Re({},l),u.push(p),d=Math.trunc(p.x*a),f=Math.trunc(p.y*o),!(d<0||d>=a||f<0||d>=o)){for(g=Math.trunc((t.kernelSize-1)/2),y=Math.max(0,d-g),w=Math.min(a,d+g+1),$=Math.max(0,f-g),S=Math.min(o,f+g+1),T=0,C=0,_=0,k=0,R=$;R<S;++R)for(A=y;A<w;++A)P=c.get(R,A,h),T+=P,k=Math.max(k,P),C+=A*P,_+=R*P;k>=t.minConfidenceToRefine&&T>0&&(p.x=C/a/T,p.y=_/o/T)}return r.dispose(),[2,u]}})})}function Cc(n,e){var t=e.left,r=e.top,s=e.left+e.right,o=e.top+e.bottom;return n.map(function(a){return Re(Re({},a),{x:(a.x-t)/(1-s),y:(a.y-r)/(1-o),z:a.z/(1-s)})})}function pP(n,e,t){return Xs()==="webgl"?function(r,s,o){var a=o.combineWithPreviousRatio.toFixed(2),i={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `+a+`);

      setOutput(outputValue);
    }
`},u=Mx();return ae(function(){var c=u.compileAndRun(i,[r,s]);return Pn().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):ae(function(){var r=fe(e,.5),s=lo(r),o=fe(1,Ti(1,ee(s,Ie(5.68842,ee(s,Ie(-.748699,ee(s,Ie(-57.8051,ee(s,Ie(291.309,ee(s,-624.717)))))))))));return Ie(e,ee(fe(n,e),ee(o,t.combineWithPreviousRatio)))})}function dP(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,a,i;return ve(this,function(u){switch(u.label){case 0:return r=n[0],s=n[1],o=function(c,h,l){return ae(function(){var p,d,f,g;l.reverseOutputOrder?(d=Ne($e(c,[0,l.boxCoordOffset+0],[-1,1])),p=Ne($e(c,[0,l.boxCoordOffset+1],[-1,1])),g=Ne($e(c,[0,l.boxCoordOffset+2],[-1,1])),f=Ne($e(c,[0,l.boxCoordOffset+3],[-1,1]))):(p=Ne($e(c,[0,l.boxCoordOffset+0],[-1,1])),d=Ne($e(c,[0,l.boxCoordOffset+1],[-1,1])),f=Ne($e(c,[0,l.boxCoordOffset+2],[-1,1])),g=Ne($e(c,[0,l.boxCoordOffset+3],[-1,1]))),d=Ie(ee(ke(d,l.xScale),h.w),h.x),p=Ie(ee(ke(p,l.yScale),h.h),h.y),l.applyExponentialOnBoxSize?(f=ee(pn(ke(f,l.hScale)),h.h),g=ee(pn(ke(g,l.wScale)),h.w)):(f=ee(ke(f,l.hScale),h.h),g=ee(ke(g,l.wScale),h.h));var y=fe(p,ke(f,2)),w=fe(d,ke(g,2)),$=Ie(p,ke(f,2)),S=Ie(d,ke(g,2)),T=yt([W(y,[l.numBoxes,1]),W(w,[l.numBoxes,1]),W($,[l.numBoxes,1]),W(S,[l.numBoxes,1])],1);if(l.numKeypoints)for(var C=0;C<l.numKeypoints;++C){var _=l.keypointCoordOffset+C*l.numValuesPerKeypoint,k=void 0,R=void 0;l.reverseOutputOrder?(k=Ne($e(c,[0,_],[-1,1])),R=Ne($e(c,[0,_+1],[-1,1]))):(R=Ne($e(c,[0,_],[-1,1])),k=Ne($e(c,[0,_+1],[-1,1])));var A=Ie(ee(ke(k,l.xScale),h.w),h.x),P=Ie(ee(ke(R,l.yScale),h.h),h.y);T=yt([T,W(A,[l.numBoxes,1]),W(P,[l.numBoxes,1])],1)}return T})}(s,e,t),a=ae(function(){var c=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=Ed(r,-t.scoreClippingThresh,t.scoreClippingThresh)),c=xs(c)):c}),[4,fP(o,a,t)];case 1:return i=u.sent(),ot([o,a]),[2,i]}})})}function fP(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,a,i,u,c,h,l,p,d,f;return ve(this,function(g){switch(g.label){case 0:return r=[],[4,n.data()];case 1:return s=g.sent(),[4,e.data()];case 2:for(o=g.sent(),a=0;a<t.numBoxes;++a)if(!(t.minScoreThresh!=null&&o[a]<t.minScoreThresh||(i=a*t.numCoords,u=mP(s[i+0],s[i+1],s[i+2],s[i+3],o[a],t.flipVertically,a),(c=u.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((h=u.locationData).relativeKeypoints=[],l=t.numKeypoints*t.numValuesPerKeypoint,p=0;p<l;p+=t.numValuesPerKeypoint)d=i+t.keypointCoordOffset+p,f={x:s[d+0],y:t.flipVertically?1-s[d+1]:s[d+1]},h.relativeKeypoints.push(f);r.push(u)}return[2,r]}})})}function mP(n,e,t,r,s,o,a){return{score:[s],ind:a,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-t:n,xMax:r,yMax:o?1-n:t,width:r-e,height:t-n}}}}function gP(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Nc(n,e,t,r){return be(this,void 0,void 0,function(){var s,o,a,i,u,c,h,l;return ve(this,function(p){switch(p.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,o=s/e.numLandmarks,[4,n.data()];case 1:for(a=p.sent(),i=[],u=0;u<e.numLandmarks;++u)c=u*o,(l={x:0,y:0}).x=t?e.inputImageWidth-a[c]:a[c],o>1&&(l.y=r?e.inputImageHeight-a[c+1]:a[c+1]),o>2&&(l.z=a[c+2]),o>3&&(l.score=gP(e.visibilityActivation,a[c+3])),i.push(l);for(h=0;h<i.length;++h)(l=i[h]).x=l.x/e.inputImageWidth,l.y=l.y/e.inputImageHeight,l.z=l.z/e.inputImageWidth/(e.normalizeZ||1);return[2,i]}})})}function Ec(n,e,t){var r=n.width,s=n.height,o=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(o=function(h,l){return l.rotation!=null?h+=l.rotation:l.rotationDegree!=null&&(h+=Math.PI*l.rotationDegree/180),tg(h)}(o,t)),o===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var a=(e.width*r*t.shiftX*Math.cos(o)-e.height*s*t.shiftY*Math.sin(o))/e.width,i=(e.width*r*t.shiftX*Math.sin(o)+e.height*s*t.shiftY*Math.cos(o))/e.height;n.xCenter=n.xCenter+a,n.yCenter=n.yCenter+i}if(t.squareLong){var u=Math.max(r*e.width,s*e.height);r=u/e.width,s=u/e.height}else if(t.squareShort){var c=Math.min(r*e.width,s*e.height);r=c/e.width,s=c/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function yP(n,e){return n.map(function(t){var r=Re(Re({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var wn=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Zo=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new wn(this.getAlpha(this.minCutOff)),this.dx=new wn(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,a=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(a),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(e,this.getAlpha(i),u)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),Za=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Wn(e);o=1/r}return e.map(function(a,i){var u=Re(Re({},a),{x:s.xFilters[i].apply(a.x,t,o),y:s.yFilters[i].apply(a.y,t,o)});return a.z!=null&&(u.z=s.zFilters[i].apply(a.z,t,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Zo(t.config)}),this.yFilters=e.map(function(r){return new Zo(t.config)}),this.zFilters=e.map(function(r){return new Zo(t.config)}))},n}(),Jo=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new wn(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,o=Math.trunc(t);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)s=1;else{for(var a=e*r-this.lastValue*this.lastValueScale,i=o-this.lastTimestamp,u=a,c=i,h=(1+this.window.length)*(1e6/30),l=0,p=this.window;l<p.length;l++){var d=p[l];if(c+d.duration>h)break;u+=d.distance,c+=d.duration}var f=u/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(f)),this.window.unshift({distance:a,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,s)},n}(),xP=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Wn(e);o=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(a,i){var u=Re(Re({},a),{x:s.xFilters[i].apply(a.x,t,o),y:s.yFilters[i].apply(a.y,t,o)});return a.z!=null&&(u.z=s.zFilters[i].apply(a.z,t,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Jo(t.config)}),this.yFilters=e.map(function(r){return new Jo(t.config)}),this.zFilters=e.map(function(r){return new Jo(t.config)}))},n}(),ea=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new xP(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new Za(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,o){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var a=o!=null?function(c,h){return(c.width*h.width+c.height*h.height)/2}(o,r):1,i=s?ag(e,r):e,u=this.keypointsFilter.apply(i,t,a);return s?yP(u,r):u},n}(),kc=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(i){return new wn(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var o=e[s],a=Re({},o);a.score=this.visibilityFilters[s].apply(o.score),r.push(a)}return r},n}(),bP={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},dr={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},vP={maxPoses:1,flipHorizontal:!1},wP={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},$P=.3,Ic={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},SP={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},TP={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},CP={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},NP={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},EP={kernelSize:7,minConfidenceToRefine:.5},Rc={alpha:.1},kP={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},IP={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},RP={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},_P={activation:"none"},AP={combineWithPreviousRatio:.7},OP=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,Zm(this.mask)]})})},n.prototype.toImageData=function(){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,Jm(this.mask)]})})},n.prototype.toTensor=function(){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function FP(n){return eg(n),"person"}var DP=function(){function n(e,t,r,s,o,a){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=o,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(l){l.reduceBoxesInLowestLayer==null&&(l.reduceBoxesInLowestLayer=!1),l.interpolatedScaleAspectRatio==null&&(l.interpolatedScaleAspectRatio=1),l.fixedAnchorSize==null&&(l.fixedAnchorSize=!1);for(var p=[],d=0;d<l.numLayers;){for(var f=[],g=[],y=[],w=[],$=d;$<l.strides.length&&l.strides[$]===l.strides[d];){var S=Sc(l.minScale,l.maxScale,$,l.strides.length);if($===0&&l.reduceBoxesInLowestLayer)y.push(1),y.push(2),y.push(.5),w.push(.1),w.push(S),w.push(S);else{for(var T=0;T<l.aspectRatios.length;++T)y.push(l.aspectRatios[T]),w.push(S);if(l.interpolatedScaleAspectRatio>0){var C=$===l.strides.length-1?1:Sc(l.minScale,l.maxScale,$+1,l.strides.length);w.push(Math.sqrt(S*C)),y.push(l.interpolatedScaleAspectRatio)}}$++}for(var _=0;_<y.length;++_){var k=Math.sqrt(y[_]);f.push(w[_]/k),g.push(w[_]*k)}var R=0,A=0;if(l.featureMapHeight.length>0)R=l.featureMapHeight[d],A=l.featureMapWidth[d];else{var P=l.strides[d];R=Math.ceil(l.inputSizeHeight/P),A=Math.ceil(l.inputSizeWidth/P)}for(var U=0;U<R;++U)for(var H=0;H<A;++H)for(var G=0;G<f.length;++G){var q={xCenter:(H+l.anchorOffsetX)/A,yCenter:(U+l.anchorOffsetY)/R,width:0,height:0};l.fixedAnchorSize?(q.width=1,q.height=1):(q.width=g[G],q.height=f[G]),p.push(q)}d=$}return p}(bP);var i=et(this.anchors.map(function(l){return l.width})),u=et(this.anchors.map(function(l){return l.height})),c=et(this.anchors.map(function(l){return l.xCenter})),h=et(this.anchors.map(function(l){return l.yCenter}));this.anchorTensor={x:c,y:h,w:i,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?Kt([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return be(this,void 0,void 0,function(){var s,o,a,i,u,c,h,l,p,d,f,g,y,w,$,S,T,C,_,k,R,A,P;return ve(this,function(U){switch(U.label){case 0:return s=function(H){var G;if((G=H==null?vP:Re({},H)).maxPoses==null&&(G.maxPoses=1),G.maxPoses<=0)throw new Error("Invalid maxPoses "+G.maxPoses+". Should be > 0.");if(G.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return G}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:og(e)?1e6*e.currentTime:null,o=ds(e),a=ae(function(){return _e(Mi(e),"float32")}),(i=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(a)]);case 1:if((u=U.sent()).length===0)return this.reset(),a.dispose(),[2,[]];c=u[0],i=this.poseDetectionToRoi(c,o),U.label=2;case 2:return[4,this.poseLandmarksByRoi(i,a)];case 3:return h=U.sent(),a.dispose(),h==null?(this.reset(),[2,[]]):(l=h.landmarks,p=h.auxiliaryLandmarks,d=h.poseScore,f=h.worldLandmarks,g=h.segmentationMask,y=this.poseLandmarkFiltering(l,p,f,o),w=y.actualLandmarksFiltered,$=y.auxiliaryLandmarksFiltered,S=y.actualWorldLandmarksFiltered,T=this.poseLandmarksToRoi($,o),this.regionOfInterest=T,C=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(_=w!=null?ag(w,o):null)!=null&&_.forEach(function(H,G){H.name=ps[G]}),(k=S)!=null&&k.forEach(function(H,G){H.name=ps[G]}),R={score:d,keypoints:_,keypoints3D:k},C!==null&&(A=ae(function(){var H=Rt(C,2),G=Ys(H,[[0,0],[0,0],[0,1]]);return Bd(G,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||ot(C),P={maskValueToLabel:FP,mask:new OP(A)},R.segmentation=P),[2,[R]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=pP(t,e,AP),ot(e)),ot(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),ot([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(ot(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Kt([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,a,i,u,c,h,l;return ve(this,function(p){switch(p.label){case 0:return t=Qa(e,SP),r=t.imageTensor,s=t.padding,o=this.detectorModel.predict(r),a=cP(o),i=a.boxes,[4,dP([u=a.logits,i],this.anchorTensor,wP)];case 1:return(c=p.sent()).length===0?(ot([r,o,u,i]),[2,c]):[4,lP(c,this.maxPoses,$P)];case 2:return h=p.sent(),l=function(d,f){d===void 0&&(d=[]);for(var g=f.left,y=f.top,w=f.left+f.right,$=f.top+f.bottom,S=0;S<d.length;S++){var T=d[S],C=T.locationData.relativeBoundingBox,_=(C.xMin-g)/(1-w),k=(C.yMin-y)/(1-$),R=C.width/(1-w),A=C.height/(1-$);C.xMin=_,C.yMin=k,C.width=R,C.height=A,C.xMax=_+R,C.yMax=k+A;var P=T.locationData.relativeKeypoints;P&&P.forEach(function(U){var H=(U.x-g)/(1-w),G=(U.y-y)/(1-$);U.x=H,U.y=G})}return d}(h,s),ot([r,o,u,i]),[2,l]}})})},n.prototype.poseDetectionToRoi=function(e,t){return Ec(Yo(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Ic)},n.prototype.poseLandmarksByRoi=function(e,t){return be(this,void 0,void 0,function(){var r,s,o,a,i,u,c,h,l,p,d,f,g,y;return ve(this,function(w){switch(w.label){case 0:if(r=ds(t),s=Qa(t,TP,e),o=s.imageTensor,a=s.padding,i=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType);return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),c=this.landmarkModel.execute(o,u),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(h=w.sent())==null?(ot(c),ot(o),[2,null]):(l=h.landmarks,p=h.auxiliaryLandmarks,d=h.poseScore,f=h.worldLandmarks,g=h.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,a,i,l,p,f,g)]);case 2:return y=w.sent(),ot(c),ot(o),[2,Re({poseScore:d},y)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,o,a,i,u){return be(this,void 0,void 0,function(){var c,h,l,p,d,f;return ve(this,function(g){return c=Cc(o,r),h=Cc(a,r),l=$c(c,t),p=$c(h,t),d=function(y,w){for(var $=[],S=0,T=y;S<T.length;S++){var C=T[S],_=C.x,k=C.y,R=w.rotation,A=Math.cos(R)*_-Math.sin(R)*k,P=Math.sin(R)*_+Math.cos(R)*k,U=Re({},C);U.x=A,U.y=P,$.push(U)}return $}(i,t),f=null,this.enableSegmentation&&(f=ae(function(){var y=u.shape,w=y[0],$=y[1],S=function(_){var k=rg(new Array(16).fill(0));k[0][0]=st(_,0,0),k[1][0]=-st(_,0,1),k[2][0]=st(_,0,2),k[3][0]=-st(_,0,3),k[0][2]=st(_,2,0),k[1][2]=-st(_,2,1),k[2][2]=st(_,2,2),k[3][2]=-st(_,2,3),k[0][1]=-st(_,1,0),k[1][1]=st(_,1,1),k[2][1]=-st(_,1,2),k[3][1]=st(_,1,3),k[0][3]=-st(_,3,0),k[1][3]=st(_,3,1),k[2][3]=-st(_,3,2),k[3][3]=st(_,3,3);for(var R=_[0][0]*k[0][0]+_[1][0]*k[0][1]+_[2][0]*k[0][2]+_[3][0]*k[0][3],A=0;A<k.length;A++)for(var P=0;P<k.length;P++)k[A][P]/=R;return k}(s),T=Kt(ng(S,{width:$,height:w},e),[1,8]),C=[1,w,$,1];return Ne($t.transform(W(u,C),T,"bilinear","constant",0,[e.height,e.width]),[0,3])}),ot(u)),[2,{landmarks:l,auxiliaryLandmarks:p,worldLandmarks:d,segmentationMask:f}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,a,i,u,c,h,l,p,d,f;return ve(this,function(g){switch(g.label){case 0:return t=e[0],r=e[1],s=e[2],o=e[3],a=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(i=g.sent()[0])<.5?[2,null]:[4,Nc(t,CP)];case 2:return[4,hP(g.sent(),s,EP)];case 3:return u=g.sent(),c=u.slice(0,33),h=u.slice(33,35),[4,Nc(o,NP)];case 4:return l=g.sent(),p=l.slice(0,33),d=function(y,w,$){$===void 0&&($=!0);for(var S=[],T=0;T<y.length;T++){var C=Re({},w[T]);$&&(C.score=y[T].score),S.push(C)}return S}(c,p,!0),f=this.enableSegmentation?function(y,w,$){return ae(function(){var S=Ne(y,[0]),T=S.shape[2];if(T===1){var C=S;switch(w.activation){case"none":break;case"sigmoid":C=xs(C);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+w.activation+")")}var _=$?$t.resizeBilinear(C,[$.height,$.width]):C;return Ne(_,[2])}throw new Error("Unsupported number of tensor channels "+T)})}(a,_P):null,[2,{landmarks:c,auxiliaryLandmarks:h,poseScore:i,worldLandmarks:d,segmentationMask:f}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return Ec(Yo(Tc(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Ic)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var o,a,i;if(this.timestamp!=null&&this.enableSmoothing){var u=Yo(Tc(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new kc(Rc)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new kc(Rc)),a=this.visibilitySmoothingFilterAuxiliary.apply(t),i=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new ea(kP)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,s,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new ea(IP)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,s,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new ea(RP)),i=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else o=e,a=t,i=r;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:i}},n}();function PP(n){return be(this,void 0,void 0,function(){var e,t,r,s,o,a;return ve(this,function(i){switch(i.label){case 0:return e=function(u){var c=Re({},u==null?dr:u);if(c.enableSmoothing==null&&(c.enableSmoothing=dr.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=dr.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=dr.smoothSegmentation),c.modelType==null&&(c.modelType=dr.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=dr.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([kr(e.detectorModelUrl,{fromTFHub:t}),kr(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=i.sent(),o=s[0],a=s[1],[2,new DP(o,a,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var jn,pt,ig=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but encountered "+t.maxTracks);if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but encountered "+t.maxAge);if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+t.keypointTrackerParams.keypointConfidenceThreshold);if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but encountered "+t.keypointTrackerParams.minNumberOfKeypoints);for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var o=s[r];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive but encountered "+o)}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),o=[],a=0,i=Array.from(Array(e.length).keys());a<i.length;a++){var u=i[a];if(s.length!==0){for(var c=-1,h=-1,l=0,p=s;l<p.length;l++){var d=p[l],f=t[u][d];f>=this.minSimilarity&&f>h&&(c=d,h=f)}if(c>=0){var g=this.tracks[c];g=Object.assign(g,this.createTrack(e[u],r,g.id)),e[u].id=g.id;var y=s.indexOf(c);s.splice(y,1)}else o.push(u)}else o.push(u)}for(var w=0,$=o;w<$.length;w++){u=$[w];var S=this.createTrack(e[u],r);this.tracks.push(S),e[u].id=S.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:Wn(e.keypoints).map(function(o){return Re({},o)})};return e.box!==void 0&&(s.box=Re({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),LP=function(n){function e(t){return n.call(this,t)||this}return Qm(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(o){return r.iou(s,o)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),o=Math.max(t.box.yMin,r.box.yMin),a=Math.min(t.box.xMax,r.box.xMax),i=Math.min(t.box.yMax,r.box.yMax);if(s>=a||o>=i)return 0;var u=(a-s)*(i-o);return u/(t.box.width*t.box.height+r.box.width*r.box.height-u)},e}(ig),BP=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return Qm(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,o=t;s<o.length;s++){for(var a=o[s],i=[],u=0,c=this.tracks;u<c.length;u++){var h=c[u];i.push(this.oks(a,h))}r.push(i)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,o=0,a=0,i=0;i<t.keypoints.length;++i){var u=t.keypoints[i],c=r.keypoints[i];if(!(u.score<this.keypointThreshold||c.score<this.keypointThreshold)){a+=1;var h=Math.pow(u.x-c.x,2)+Math.pow(u.y-c.y,2),l=2*this.keypointFalloff[i];o+=Math.exp(-1*h/(2*s*Math.pow(l,2)))}}return a<this.minNumKeyoints?0:o/a},e.prototype.area=function(t){var r=this,s=t.filter(function(u){return u.score>r.keypointThreshold}),o=Math.min.apply(Math,Wn([1],s.map(function(u){return u.x}))),a=Math.max.apply(Math,Wn([0],s.map(function(u){return u.x}))),i=Math.min.apply(Math,Wn([1],s.map(function(u){return u.y})));return(a-o)*(Math.max.apply(Math,Wn([0],s.map(function(u){return u.y})))-i)},e}(ig);function ug(n){switch(n){case pt.BlazePose:return ps.reduce(function(e,t,r){return e[t]=r,e},{});case pt.PoseNet:case pt.MoveNet:return sn.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model "+n+" is not supported.")}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(jn||(jn={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(pt||(pt={}));Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case pt.BlazePose:return eP;case pt.PoseNet:case pt.MoveNet:return tP;default:throw new Error("Model "+n+" is not supported.")}},getAdjacentPairs:function(n){switch(n){case pt.BlazePose:return rP;case pt.PoseNet:case pt.MoveNet:return nP;default:throw new Error("Model "+n+" is not supported.")}},getKeypointIndexByName:ug});var _c=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],cg={modelType:"SinglePose.Lightning",enableSmoothing:!0},Ac={},Oc={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},ta={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Fc={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function MP(n,e,t,r){for(var s={},o=0,a=sn;o<a.length;o++){var i=a[o];s[i]=[e[t[i]].y*r.height,e[t[i]].x*r.width]}if(function($,S){return($[S.left_hip].score>.2||$[S.right_hip].score>.2)&&($[S.left_shoulder].score>.2||$[S.right_shoulder].score>.2)}(e,t)){var u=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,h=function($,S,T,C,_){for(var k=["left_shoulder","right_shoulder","left_hip","right_hip"],R=0,A=0,P=0;P<k.length;P++)(te=Math.abs(C-T[k[P]][0]))>R&&(R=te),(ne=Math.abs(_-T[k[P]][1]))>A&&(A=ne);for(var U=0,H=0,G=0,q=Object.keys(T);G<q.length;G++){var te,ne,ue=q[G];$[S[ue]].score<.2||((te=Math.abs(C-T[ue][0]))>U&&(U=te),(ne=Math.abs(_-T[ue][1]))>H&&(H=ne))}return[R,A,U,H]}(e,t,s,u,c),l=h[0],p=h[1],d=h[2],f=h[3],g=Math.max(1.9*p,1.9*l,1.2*d,1.2*f),y=[u-(g=Math.min(g,Math.max(c,r.width-c,u,r.height-u))),c-g];if(g>Math.max(r.width,r.height)/2)return Ja(n==null,r);var w=2*g;return{yMin:y[0]/r.height,xMin:y[1]/r.width,yMax:(y[0]+w)/r.height,xMax:(y[1]+w)/r.width,height:(y[0]+w)/r.height-y[0]/r.height,width:(y[1]+w)/r.width-y[1]/r.width}}return Ja(n==null,r)}function Ja(n,e){var t,r,s,o;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):(t=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:o,yMax:s+t,xMax:o+r,height:t,width:r}}function VP(n){var e,t=n==null?cg:Re({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(_c.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+_c);if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=jn.BoundingBox),t.trackerType===jn.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=Dc(ta,r);return s.keypointTrackerParams=Re({},ta.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=ta;else{if(t.trackerType!==jn.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Dc(Fc,e)):t.trackerConfig=Fc}return t}function Dc(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var UP=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=ug(pt.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Za(Oc),this.cropRegionFilterYMin=new wn(.9),this.cropRegionFilterXMin=new wn(.9),this.cropRegionFilterYMax=new wn(.9),this.cropRegionFilterXMax=new wn(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===jn.Keypoint?this.tracker=new BP(t.trackerConfig):t.trackerType===jn.BoundingBox&&(this.tracker=new LP(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,a;return ve(this,function(i){switch(i.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Xs()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=i.sent(),i.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},o=0,a=0;a<17;++a)s.keypoints[a]={y:r[3*a],x:r[3*a+1],score:r[3*a+2]},s.keypoints[a].score>.2&&(++o,s.score+=s.keypoints[a].score);return o>0&&(s.score/=o),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,a,i,u,c;return ve(this,function(h){switch(h.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Xs()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=h.sent(),h.label=3;case 3:for(t.dispose(),s=[],o=r.length/56,a=0;a<o;++a)for(s[a]={keypoints:[]},i=56*a+51,s[a].box={yMin:r[i],xMin:r[i+1],yMax:r[i+2],xMax:r[i+3],width:r[i+3]-r[i+1],height:r[i+2]-r[i]},u=56*a+55,s[a].score=r[u],s[a].keypoints=[],c=0;c<17;++c)s[a].keypoints[c]={y:r[56*a+3*c],x:r[56*a+3*c+1],score:r[56*a+3*c+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=Ac),be(this,void 0,void 0,function(){var s,o,a,i,u,c;return ve(this,function(h){switch(h.label){case 0:return t=function(l){return l==null?Ac:Re({},l)}(t),e==null?(this.reset(),[2,[]]):(r==null?og(e)&&(r=1e6*e.currentTime):r*=1e3,s=Mi(e),o=ds(s),a=Rt(s,0),e instanceof He||s.dispose(),i=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,o,r)]);case 1:return i=h.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,o,r)];case 3:i=h.sent(),h.label=4;case 4:for(u=0;u<i.length;++u)for(c=0;c<i[u].keypoints.length;++c)i[u].keypoints[c].name=sn[c],i[u].keypoints[c].y*=o.height,i[u].keypoints[c].x*=o.width;return[2,i]}})})},n.prototype.estimateSinglePose=function(e,t,r){return be(this,void 0,void 0,function(){var s,o,a,i,u=this;return ve(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Ja(this.cropRegion==null,t)),s=ae(function(){var h=Kt([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),l=En([1],"int32"),p=[u.modelInputResolution.height,u.modelInputResolution.width];return _e($t.cropAndResize(e,h,l,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(o=c.sent(),s.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<o.keypoints.length;++a)o.keypoints[a].y=this.cropRegion.yMin+o.keypoints[a].y*this.cropRegion.height,o.keypoints[a].x=this.cropRegion.xMin+o.keypoints[a].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,r,1)),i=MP(this.cropRegion,o.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(i),[2,[o]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return be(this,void 0,void 0,function(){var s,o,a,i,u,c,h,l,p,d,f,g=this;return ve(this,function(y){switch(y.label){case 0:return t.width>t.height?(o=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=$t.resizeBilinear(e,[a,o]),u=o,c=32*Math.ceil(a/32),i=Ys(s,[[0,0],[0,c-a],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*t.width/t.height),a=this.multiPoseMaxDimension,s=$t.resizeBilinear(e,[a,o]),u=32*Math.ceil(o/32),c=a,i=Ys(s,[[0,0],[0,0],[0,u-o],[0,0]])),s.dispose(),e.dispose(),h=_e(i,"int32"),i.dispose(),[4,this.runMultiPersonPoseModel(h)];case 1:for(l=y.sent(),h.dispose(),l=l.filter(function(w){return w.score>=g.minPoseScore}),d=0;d<l.length;++d)for(p=0;p<l[d].keypoints.length;++p)l[d].keypoints[p].y*=c/a,l[d].keypoints[p].x*=u/o;if(this.enableTracking&&(this.tracker.apply(l,r),this.enableSmoothing)){for(d=0;d<l.length;++d)this.keypointFilterMap.has(l[d].id)||this.keypointFilterMap.set(l[d].id,new Za(Oc)),l[d].keypoints=this.keypointFilterMap.get(l[d].id).apply(l[d].keypoints,r,1);f=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(w,$){f.has($)||g.keypointFilterMap.delete($)})}return[2,l]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:o,height:s-t,width:o-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function WP(n){return n===void 0&&(n=cg),be(this,void 0,void 0,function(){var e,t,r,s;return ve(this,function(o){switch(o.label){case 0:return e=VP(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,kr(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=o.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,kr(s,{fromTFHub:r})];case 3:t=o.sent(),o.label=4;case 4:return Xs()==="webgl"&&B().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new UP(t,e)]}})})}var Pc={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Lc=["MobileNetV1","ResNet50"],Bc={MobileNetV1:[8,16],ResNet50:[16]},zP=[8,16,32],Mc={MobileNetV1:[.5,.75,1],ResNet50:[1]},Vc=[1,2,4],GP={maxPoses:1,flipHorizontal:!1},HP={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},jP=[-123.15,-115.9,-103.06];function na(n){return Math.floor(n/2)}var KP=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(na(e),e);)this.exchange(e,na(e)),e=na(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function XP(n,e,t,r,s,o){for(var a=o.shape,i=a[0],u=a[1],c=!0,h=Math.max(t-s,0),l=Math.min(t+s+1,i),p=h;p<l;++p){for(var d=Math.max(r-s,0),f=Math.min(r+s+1,u),g=d;g<f;++g)if(o.get(p,g,n)>e){c=!1;break}if(!c)break}return c}function qP(n){return be(this,void 0,void 0,function(){return ve(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function lg(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function hg(n,e,t){var r=lg(n.heatmapY,n.heatmapX,n.id,t),s=r.y,o=r.x;return{x:n.heatmapX*e+o,y:n.heatmapY*e+s}}function pg(n,e,t,r){var s=t.x,o=t.y;return n.some(function(a){var i,u,c,h,l,p,d=a.keypoints;return i=o,u=s,c=d[r].y,h=d[r].x,(l=c-i)*l+(p=h-u)*p<=e})}var Uc=sn.reduce(function(n,e,t){return n[e]=t,n},{}),dg=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[Uc[e],Uc[t]]}),ra=dg.map(function(n){return n[1]}),Wc=dg.map(function(n){return n[0]});function zc(n,e,t){return n<e?e:n>t?t:n}function sa(n,e,t,r){return{y:zc(Math.round(n.y/e),0,t-1),x:zc(Math.round(n.x/e),0,r-1)}}function Gc(n,e){return{x:n.x+e.x,y:n.y+e.y}}function Hc(n,e,t,r,s,o,a,i){i===void 0&&(i=2);for(var u=r.shape,c=u[0],h=u[1],l={y:e.y,x:e.x},p=Gc(l,function($,S,T){var C=T.shape[2]/2;return{y:T.get(S.y,S.x,$),x:T.get(S.y,S.x,C+$)}}(n,sa(l,o,c,h),a)),d=0;d<i;d++){var f=sa(p,o,c,h),g=lg(f.y,f.x,t,s);p=Gc({x:f.x*o,y:f.y*o},{x:g.x,y:g.y})}var y=sa(p,o,c,h),w=r.get(y.y,y.x,t);return{y:p.y,x:p.x,name:sn[t],score:w}}function YP(n,e,t,r,s,o){var a=e.shape[2],i=ra.length,u=new Array(a),c=n.part,h=n.score,l=hg(c,r,t);u[c.id]={score:h,name:sn[c.id],y:l.y,x:l.x};for(var p=i-1;p>=0;--p){var d=ra[p],f=Wc[p];u[d]&&!u[f]&&(u[f]=Hc(p,u[d],f,e,t,r,o))}for(p=0;p<i;++p)d=Wc[p],f=ra[p],u[d]&&!u[f]&&(u[f]=Hc(p,u[d],f,e,t,r,s));return u}function QP(n,e,t){return t.reduce(function(r,s,o){var a=s.y,i=s.x,u=s.score;return pg(n,e,{y:a,x:i},o)||(r+=u),r},0)/t.length}function ZP(n,e,t,r,s,o,a,i){return a===void 0&&(a=.5),i===void 0&&(i=20),be(this,void 0,void 0,function(){var u,c,h,l,p,d,f,g,y,w,$,S;return ve(this,function(T){switch(T.label){case 0:return[4,qP([n,e,t,r])];case 1:for(u=T.sent(),c=u[0],h=u[1],l=u[2],p=u[3],d=[],f=function(C,_,k){for(var R=k.shape,A=R[0],P=R[1],U=R[2],H=new KP(A*P*U,function(ue){return ue.score}),G=0;G<A;++G)for(var q=0;q<P;++q)for(var te=0;te<U;++te){var ne=k.get(G,q,te);ne<C||XP(te,ne,G,q,_,k)&&H.enqueue({score:ne,part:{heatmapY:G,heatmapX:q,id:te}})}return H}(a,1,c),g=i*i;d.length<o&&!f.empty();)y=f.dequeue(),w=hg(y.part,s,h),pg(d,g,w,y.part.id)||($=YP(y,c,h,s,l,p),S=QP(d,g,$),d.push({keypoints:$,score:S}));return[2,d]}})})}function JP(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return ae(function(){var o,a,i=W(n,[t*r,s]),u=Td(i,0),c=Rt(ke(u,me(r,"int32")),1),h=Rt((o=u,a=r,ae(function(){var l=ke(o,me(a,"int32"));return fe(o,ee(l,me(a,"int32")))})),1);return yt([c,h],1)})}function e3(n,e,t){return ae(function(){var r=function(s,o){for(var a=[],i=0;i<sn.length;i++){var u=s.get(i,0).valueOf(),c=s.get(i,1).valueOf(),h=t3(u,c,i,o),l=h.x,p=h.y;a.push(p),a.push(l)}return Kt(a,[sn.length,2])}(n,t);return Ie(_e(ee(n.toTensor(),me(e,"int32")),"float32"),r)})}function t3(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+sn.length)}}function n3(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,a,i,u,c,h,l,p;return ve(this,function(d){switch(d.label){case 0:return r=0,s=JP(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return o=d.sent(),a=o[0],i=o[1],u=o[2],[4,(c=e3(u,t,i)).buffer()];case 2:return h=d.sent(),l=Array.from(function(f,g){for(var y=g.shape[0],w=new Float32Array(y),$=0;$<y;$++){var S=g.get($,0),T=g.get($,1);w[$]=f.get(S,T,$)}return w}(a,u)),p=l.map(function(f,g){return r+=f,{y:h.get(g,0),x:h.get(g,1),score:f,name:sn[g]}}),s.dispose(),c.dispose(),[2,{keypoints:p,score:r/p.length}]}})})}function jc(n,e){return(n-1)%e==0}var Kc="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Xc="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function qc(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var Yc=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;I(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"});var s,o,a=(s=t.inputResolution,o=t.outputStride,{height:qc(s.height,o),width:qc(s.width,o)});(function(i){I(zP.indexOf(i)>=0,function(){return"outputStride of "+i+" is invalid. It must be either 8 or 16."})})(t.outputStride),function(i,u){I(jc(i.height,u),function(){return"height of "+i.height+" is invalid for output stride "+u+"."}),I(jc(i.width,u),function(){return"width of "+i.width+" is invalid for output stride "+u+"."})}(a,t.outputStride),this.inputResolution=a,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=GP),be(this,void 0,void 0,function(){var r,s,o,a,i,u,c,h,l,p,d,f,g,y,w;return ve(this,function($){switch($.label){case 0:return r=function(S){var T=S;if(T.maxPoses==null&&(T.maxPoses=1),T.maxPoses<=0)throw new Error("Invalid maxPoses "+T.maxPoses+". Should be > 0.");if(T.maxPoses>1){if((T=Re(Re({},HP),T)).scoreThreshold<0||T.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+T.scoreThreshold+". Should be in range [0.0, 1.0]");if(T.nmsRadius<=0)throw new Error("Invalid nmsRadius "+T.nmsRadius+".")}return T}(t),e==null?[2,[]]:(this.maxPoses=r.maxPoses,s=Qa(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=s.imageTensor,a=s.padding,i=this.architecture==="ResNet50"?Ie(o,jP):sg(o,[-1,1]),u=this.posenetModel.predict(i),this.architecture==="ResNet50"?(c=Ne(u[2],[0]),h=Ne(u[3],[0]),l=Ne(u[0],[0]),p=Ne(u[1],[0])):(c=Ne(u[0],[0]),h=Ne(u[1],[0]),l=Ne(u[2],[0]),p=Ne(u[3],[0])),d=xs(h),this.maxPoses!==1?[3,2]:[4,n3(d,c,this.outputStride)]);case 1:return g=$.sent(),f=[g],[3,4];case 2:return[4,ZP(d,c,l,p,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 3:f=$.sent(),$.label=4;case 4:return y=ds(e),w=function(S,T,C,_){var k=T.height,R=T.width,A=k/(C.height*(1-_.top-_.bottom)),P=R/(C.width*(1-_.left-_.right)),U=-_.top*C.height,H=-_.left*C.width;if(P===1&&A===1&&U===0&&H===0)return S;for(var G=0,q=S;G<q.length;G++)for(var te=0,ne=q[G].keypoints;te<ne.length;te++){var ue=ne[te];ue.x=(ue.x+H)*P,ue.y=(ue.y+U)*A}return S}(f,y,this.inputResolution,a),r.flipHorizontal&&(w=function(S,T){for(var C=0,_=S;C<_.length;C++)for(var k=0,R=_[C].keypoints;k<R.length;k++){var A=R[k];A.x=T.width-1-A.x}return S}(w,y)),o.dispose(),i.dispose(),ot(u),c.dispose(),h.dispose(),l.dispose(),p.dispose(),d.dispose(),[2,w]}})})},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function r3(n){return n===void 0&&(n=Pc),be(this,void 0,void 0,function(){var e,t,r,s,o;return ve(this,function(a){switch(a.label){case 0:return(e=function(h){var l=h||Pc;if(l.architecture==null&&(l.architecture="MobileNetV1"),Lc.indexOf(l.architecture)<0)throw new Error("Invalid architecture "+l.architecture+". Should be one of "+Lc);if(l.inputResolution==null&&(l.inputResolution={height:257,width:257}),l.outputStride==null&&(l.outputStride=16),Bc[l.architecture].indexOf(l.outputStride)<0)throw new Error("Invalid outputStride "+l.outputStride+". Should be one of "+Bc[l.architecture]+" for architecture "+l.architecture+".");if(l.multiplier==null&&(l.multiplier=1),Mc[l.architecture].indexOf(l.multiplier)<0)throw new Error("Invalid multiplier "+l.multiplier+". Should be one of "+Mc[l.architecture]+" for architecture "+l.architecture+".");if(l.quantBytes==null&&(l.quantBytes=4),Vc.indexOf(l.quantBytes)<0)throw new Error("Invalid quantBytes "+l.quantBytes+". Should be one of "+Vc+" for architecture "+l.architecture+".");if(l.architecture==="MobileNetV1"&&l.outputStride===32&&l.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return l}(n)).architecture!=="ResNet50"?[3,2]:(i=e.outputStride,u=e.quantBytes,c="model-stride"+i+".json",t=u===4?Xc+"float/"+c:Xc+"quant"+u+"/"+c,[4,kr(e.modelUrl||t)]);case 1:return r=a.sent(),[2,new Yc(r,e)];case 2:return s=function(h,l,p){var d={1:"100",.75:"075",.5:"050"},f="model-stride"+h+".json";return p===4?Kc+"float/"+d[l]+"/"+f:Kc+"quant"+p+"/"+d[l]+"/"+f}(e.outputStride,e.multiplier,e.quantBytes),[4,kr(e.modelUrl||s)];case 3:return o=a.sent(),[2,new Yc(o,e)]}var i,u,c})})}function y3(n,e){return be(this,void 0,void 0,function(){var t,r;return ve(this,function(s){switch(n){case pt.PoseNet:return[2,r3(e)];case pt.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,PP(e)];if(t.runtime==="mediapipe")return[2,uP(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r);case pt.MoveNet:return[2,WP(e)];default:throw new Error(n+" is not a supported model name.")}})})}var x3={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};export{y3 as a,EO as b,x3 as l,pt as o};
